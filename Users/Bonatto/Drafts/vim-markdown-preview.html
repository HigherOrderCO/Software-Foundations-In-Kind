<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>vim-markdown-preview.html</title>
  <link rel="icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEACABoBQAAFgAAACgAAAAQAAAAIAAAAAEACAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAKCgr/FRUX/xYWGP8YGBr/GRkb/xsbHP8dHR7/Hh4f/x4eIP8fHyD/ICAh/yMjJP8kJCX/JiYo/ygoKv8pKSr/LCwu/y0tLv80NDT/QUFC/0ZGR/9MTE7/UFBR/1JSUv9bW1v/XFxc/2BgYP9hYWP/aGhp/2xsbP9ycnL/d3d3/3l5e/98fHz/f3+A/2dn/P9z3a//cNX8/4CAgP+Xl5f/nZ2e/56en/+fn5//n5+h/6amp/+rq6v/rKys/7CvsP+zs7T/uLi5/7u7u/+8vLz/wMDA/8fHx//Kysr/zc3N/9HR0f/d3d3/3t7e/+Xl5f/q6ur/6+vr/+3t7f/z8/P/9fX1//b29v/39/f/+Pj4//n5+f/6+vr/+/v7//z8/P/9/f3//v7+//////8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/NCYmJiYmJiYmJiYmJiYmNCZKSkpKSkpKSkpKSkpKSiYmSkpKRisdRkMbMklKSkomJkpKSSEiNUhEEQwpSUpKJiZKSi8LHhhAPAwBDDZKSiYmSkoWACA7SEc6HAEaSkomJkpKBxI/SkpKSj4ICkpKJiZKSgUTR0pKSkpGDwZKSiYmSkoTED1KSkpKOQQVSkomJkpKKgowMy4sNycIMUpKJiZKSkEZDgkDAgsNH0VKSiYmSkpKQigUBgkXLUhKSkomJkpKSkpKSkpKSkpKSkpKJiYmJiYmJiYmJiYmJiYmJiYmIyUkNDQ0NDQ0NDQ0NDQmOCYmJiYmJiYmJiYmJiYmOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=" />
  <link rel="stylesheet" href="/__/grip/static/octicons/octicons.css" />
  <style>
    /* Page tweaks */
    .preview-page {
      margin-top: 64px;
      margin-bottom: 21px;
    }
    /* User-content tweaks */
    .timeline-comment-wrapper > .timeline-comment:after,
    .timeline-comment-wrapper > .timeline-comment:before {
      content: none;
    }
    /* User-content overrides */
    .discussion-timeline.wide {
      width: 920px;
    }
  </style>
</head>
<body>
  <div class="page">
    <div id="preview-page" class="preview-page" data-autorefresh-url="">
    <main id="js-repo-pjax-container">
      <div class="clearfix new-discussion-timeline container-xl px-3 px-md-4 px-lg-5">
        <div class="repository-content">
          <div class="clearfix">
            <div class="Layout Layout--flowRow-until-md Layout--sidebarPosition-end Layout--sidebarPosition-flowRow-end">
              <div class="Layout-main">

                

                  <div id="readme" class="Box md Box--responsive">
                    
                      <div class="Box-header d-flex border-bottom-0 flex-items-center flex-justify-between color-bg-default rounded-top-2">
                        <div class="d-flex flex-items-center">
                          <h2 class="Box-title">
                            vim-markdown-preview.html
                          </h2>
                        </div>
                      </div>
                    
                    <div class="Box-body px-5 pb-5">
                      <article id="grip-content" class="markdown-body entry-content container-lg">
                        <h1><a id="user-content-capítulo-3" class="anchor" aria-hidden="true" href="#capítulo-3"><span aria-hidden="true" class="octicon octicon-link"></span></a>CAPÍTULO 3</h1>
<h2><a id="user-content-indução-prova-por-indução" class="anchor" aria-hidden="true" href="#indução-prova-por-indução"><span aria-hidden="true" class="octicon octicon-link"></span></a>Indução: Prova por Indução</h2>
<h3><a id="user-content-módulo-de-indução" class="anchor" aria-hidden="true" href="#módulo-de-indução"><span aria-hidden="true" class="octicon octicon-link"></span></a>módulo de indução</h3>
<p>Nesse capítulo nós veremos sobre provas por indução, mas antes de prosseguirmos
para a indução em si, podemos analisar casos simples onde apenas a reflexão do
caso já prova o teorema.</p>
<div class="highlight highlight-source-rust"><pre><span class="pl-v">Problems</span><span class="pl-kos">.</span><span class="pl-en">t0</span> <span class="pl-kos">(</span>n<span class="pl-kos">:</span> <span class="pl-v">Nat</span><span class="pl-kos">)</span> <span class="pl-kos">:</span> <span class="pl-kos">(</span><span class="pl-v">Equal</span> <span class="pl-v">Nat</span> <span class="pl-kos">(</span><span class="pl-v">Nat</span><span class="pl-kos">.</span><span class="pl-c1">add</span> <span class="pl-v">Nat</span><span class="pl-kos">.</span><span class="pl-c1">zero</span> n<span class="pl-kos">)</span> n<span class="pl-kos">)</span><span class="pl-kos"></span></pre></div>
<p>Ao verificar verificar o objetivo do teorema, recebemos a seguinte resposta:</p>
<div class="highlight highlight-source-shell"><pre>Inspection.
- Goal: (Equal Nat n n)
Kind.Context:
- n <span class="pl-c1">:</span> Nat
On <span class="pl-s"><span class="pl-pds">'</span>problems0.kind2<span class="pl-pds">'</span></span>:
   64 <span class="pl-k">|</span> Problems.t0 n              = <span class="pl-k">?</span></pre></div>
<p>No <em>Problems.t0</em> o Kind reduz a soma de "<em>0 + n</em>" automaticamente para <em>n</em> e
que devemos provar a igualdade entre <em>n</em> e <em>n</em>. Nesse caso basta escrever "<em>Equal</em>.<strong>refl</strong>" e obtemos a resposta de
confirmação:</p>
<p>"<em>All terms check.</em>"</p>
<div class="highlight highlight-source-rust"><pre><span class="pl-v">Problems</span><span class="pl-kos">.</span><span class="pl-en">t1</span> <span class="pl-kos">(</span>n<span class="pl-kos">:</span> <span class="pl-v">Nat</span><span class="pl-kos">)</span> <span class="pl-kos">:</span> <span class="pl-kos">(</span><span class="pl-v">Equal</span> <span class="pl-v">Nat</span> <span class="pl-kos">(</span><span class="pl-v">Nat</span><span class="pl-kos">.</span><span class="pl-c1">add</span> n <span class="pl-v">Nat</span><span class="pl-kos">.</span><span class="pl-c1">zero</span><span class="pl-kos">)</span> n<span class="pl-kos">)</span><span class="pl-kos"></span></pre></div>
<p>Feito o primeiro problema, o seguinte é muito similar, é a soma de "<em>n + 0 = n</em>" e essa similaridade pode nos levar a crer que basta invocar a reflexão. Entretanto, no primeiro caso o Kind reduz automaticamente e nesse nós obtemos o seguinte retorno:</p>
<div class="highlight highlight-source-shell"><pre>Inspection.
- Goal: (Equal _ (Nat.add n Nat.zero) n)
Kind.Context:
- n <span class="pl-c1">:</span> Nat
On <span class="pl-s"><span class="pl-pds">'</span>problems01.kind2<span class="pl-pds">'</span></span>:
   67 <span class="pl-k">|</span> Problems.t1 n = <span class="pl-k">?</span></pre></div>
<p>No primeiro caso o Kind reduz pois o <em>zero</em> está à direita e o <em>Type
Checker</em> já reduz automaticamente, a soma de entre <em>0</em> e <em>n</em> para <em>n</em>.
Entretanto, quando o primeiro <em>input</em> é uma variável, o Kind necessita
verificar para cada caso e como é um número natural, há infinitos casos a serem
testatos, isto é, de zero a infinito.</p>
<p>De início podemos pensar que são tantos casos e que é impossível analisar todos
eles, já que são infinitos, mas logo percebemos que é possível reduzir a dois,
um é o número <em>zero</em> e o outro é um número que <em>sucede</em> o <em>zero</em> <em>n</em> vezes
depois.</p>
<p>Analizando para o caso de <em>zero</em> nosso objetivo é provar que <em>zero</em> é igual
a <em>zero</em>:</p>
<div class="highlight highlight-source-shell"><pre>- Goal: (Equal _ Nat.zero Nat.zero)</pre></div>
<p>Agora basta dar o <em>Equal</em>.<strong>refl</strong> e o caso zero já foi comprovado, basta
apenas responder para o <em>sucessor</em> de <em>zero</em></p>
<p>Nosso objetivo é provar que para todo número <em>n</em>, ao adicionar <em>0</em> o
resultado será <em>n</em>, mas já temos uma nova ferramenta que nos auxilia nessa
prova e é a prova para o caso <em>zero</em>, basta reduzir <em>n</em> até que o
necessário seja apenas a reflexão e podemos fazer isso por meio da
recursão e para isso definimos o novo <em>n</em> como o antecessor dele. No Kind nós
podemos fazer isso simplesmente definindo o <em>n</em> atual como sendo o sucessor
do próximo <em>n</em> e chamar a função para n recursivamente. Isso é feito da
seguinte forma:</p>
<div class="highlight highlight-source-rust"><pre><span class="pl-v">Problems</span><span class="pl-kos">.</span><span class="pl-en">t1</span> <span class="pl-kos">(</span><span class="pl-v">Nat</span><span class="pl-kos">.</span><span class="pl-c1">succ</span> n<span class="pl-kos">)</span>   = ?</pre></div>
<p>e temos como novo objetivo provar que o sucessor da soma entre <em>n</em> e <em>0</em> é
igual ao sucessor de <em>n</em></p>
<div class="highlight highlight-source-shell"><pre>- Goal: (Equal _ (Nat.succ (Nat.add n Nat.zero)) (Nat.succ n))</pre></div>
<p>Para trabalhar com a indução nessa recursão, devemos definir uma variável para
o caso original de <em>n</em></p>
<div class="highlight highlight-source-rust"><pre><span class="pl-v">Problems</span><span class="pl-kos">.</span><span class="pl-en">t1</span> <span class="pl-kos">(</span>n<span class="pl-kos">:</span> <span class="pl-v">Nat</span><span class="pl-kos">)</span>       <span class="pl-kos">:</span> <span class="pl-kos">(</span><span class="pl-v">Equal</span> <span class="pl-kos">(</span><span class="pl-v">Nat</span><span class="pl-kos">.</span><span class="pl-c1">add</span> n <span class="pl-v">Nat</span><span class="pl-kos">.</span><span class="pl-c1">zero</span><span class="pl-kos">)</span> n<span class="pl-kos">)</span>
<span class="pl-v">Problems</span><span class="pl-kos">.</span><span class="pl-c1">t1</span> <span class="pl-v">Nat</span><span class="pl-kos">.</span><span class="pl-c1">zero</span>       = <span class="pl-v">Equal</span><span class="pl-kos">.</span><span class="pl-c1">refl</span>
<span class="pl-v">Problems</span><span class="pl-kos">.</span><span class="pl-en">t1</span> <span class="pl-kos">(</span><span class="pl-v">Nat</span><span class="pl-kos">.</span><span class="pl-c1">succ</span> n<span class="pl-kos">)</span>   =
     let ind = <span class="pl-v">Problems</span><span class="pl-kos">.</span><span class="pl-c1">t1</span> n
     ?<span class="pl-kos"></span></pre></div>
<p>Ao dar o <em>Type Check</em> temos como retorno a seguinte resposta:</p>
<div class="highlight highlight-source-shell"><pre>Inspection.
- Goal: (Equal _ (Nat.succ (Nat.add n Nat.zero)) (Nat.succ n))
Kind.Context:
- n   <span class="pl-c1">:</span> Nat
- ind <span class="pl-c1">:</span> (Equal _ (Nat.add n Nat.zero) n)
- ind = (Problems.t1 n)
On <span class="pl-s"><span class="pl-pds">'</span>problems01.kind2<span class="pl-pds">'</span></span>:
   72 <span class="pl-k">|</span>     <span class="pl-k">?</span></pre></div>
<p>Ao analizar nosso objetivo e a indução, percebemos que a única diferença entre
o objetivo e a nossa variável <em>ind</em> é o <em>Nat</em>.<strong>succ</strong>, basta então
incrementar a variável <em>ind</em> com o <em>Nat</em>.<strong>succ</strong>, para isso nós criamos uma
nova variável e usamos uma função <em>lambda</em>:</p>
<div class="highlight highlight-source-rust"><pre><span class="pl-k">let</span> app = <span class="pl-kos">(</span><span class="pl-v">Equal</span><span class="pl-kos">.</span><span class="pl-en">apply</span> <span class="pl-kos">(</span>x =&gt; <span class="pl-kos">(</span><span class="pl-v">Nat</span><span class="pl-kos">.</span><span class="pl-c1">succ</span> x<span class="pl-kos">)</span><span class="pl-kos">)</span> ind<span class="pl-kos">)</span><span class="pl-kos"></span></pre></div>
<p>No caso acima nós chamamos a função <em>Equal</em>.<strong>apply</strong> para aplicar a nossa
função <em>lambda</em> ao <em>ind</em>. A função <code>x =&gt; (Nat.succ x)</code> serve para adicionar
<em>Nat</em>.<strong>succ</strong> a todo elemento recebido na variável. Como nossa variável <em>ind</em>
é uma função que recebe uma outra variável <em>n</em>, a nossa função <em>lambda</em>
incrementa a <em>n</em> com <em>Nat</em>.<strong>succ</strong>, o que retorna exatamente o nosso
objetivo:</p>
<div class="highlight highlight-source-shell"><pre>Inspection.
- Goal: (Equal Nat (Nat.succ (Nat.add n Nat.zero)) (Nat.succ n))
Kind.Context:
- n   <span class="pl-c1">:</span> Nat
- ind <span class="pl-c1">:</span> (Equal Nat (Nat.add n Nat.zero) n)
- ind = (Problems.t1 n)
- app <span class="pl-c1">:</span> (Equal Nat (Nat.succ (Nat.add n Nat.zero)) (Nat.succ n))
- app = (Equal.apply Nat Nat (Nat.add n Nat.zero) n (x =<span class="pl-k">&gt;</span> (Nat.succ x)) ind)
On <span class="pl-s"><span class="pl-pds">'</span>problems01.kind2<span class="pl-pds">'</span></span>:
   72 <span class="pl-k">|</span>     <span class="pl-k">?</span></pre></div>
<p>Podemos perceber que o <em>app</em> é exatamente igual ao <em>Goal</em>, que é o nosso
objetivo e basta apenas retornar ele, o app para que o <em>Type Check</em> valide
a nossa prova:
<em>All terms check.</em></p>

                      </article>
                    </div>
                  </div>

                

              </div>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>
  </div><script>
    function showCanonicalImages() {
      var images = document.getElementsByTagName('img');
      if (!images) {
        return;
      }
      for (var index = 0; index < images.length; index++) {
        var image = images[index];
        if (image.getAttribute('data-canonical-src') && image.src !== image.getAttribute('data-canonical-src')) {
          image.src = image.getAttribute('data-canonical-src');
        }
      }
    }

    function scrollToHash() {
      if (location.hash && !document.querySelector(':target')) {
        var element = document.getElementById('user-content-' + location.hash.slice(1));
        if (element) {
           element.scrollIntoView();
        }
      }
    }

    function autorefreshContent(eventSourceUrl) {
      var initialTitle = document.title;
      var contentElement = document.getElementById('grip-content');
      var source = new EventSource(eventSourceUrl);
      var isRendering = false;

      source.onmessage = function(ev) {
        var msg = JSON.parse(ev.data);
        if (msg.updating) {
          isRendering = true;
          document.title = '(Rendering) ' + document.title;
        } else {
          isRendering = false;
          document.title = initialTitle;
          contentElement.innerHTML = msg.content;
          showCanonicalImages();
        }
      }

      source.onerror = function(e) {
        if (e.readyState === EventSource.CLOSED && isRendering) {
          isRendering = false;
          document.title = initialTitle;
        }
      }
    }

    window.onhashchange = function() {
      scrollToHash();
    }

    window.onload = function() {
      scrollToHash();
    }

    showCanonicalImages();

    var autorefreshUrl = document.getElementById('preview-page').getAttribute('data-autorefresh-url');
    if (autorefreshUrl) {
      autorefreshContent(autorefreshUrl);
    }
  </script>
</body>
</html>