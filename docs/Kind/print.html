<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="guide/Started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guide/About.html"><strong aria-hidden="true">1.1.</strong> About Kind</a></li><li class="chapter-item expanded "><a href="guide/Installation.html"><strong aria-hidden="true">1.2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="cli/World.html"><strong aria-hidden="true">1.3.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="cli/kind.html"><strong aria-hidden="true">1.4.</strong> Hello Kind!</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Book</li><li class="chapter-item expanded "><a href="Book/chapter_02/2,1.html"><strong aria-hidden="true">2.</strong> Basics: Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/chapter_02/2,2.html"><strong aria-hidden="true">2.1.</strong> Enumerated Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/chapter_02/2,2,1.html"><strong aria-hidden="true">2.1.1.</strong> Days of the Week</a></li></ol></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,3.html"><strong aria-hidden="true">2.2.</strong> Booleans</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,4.html"><strong aria-hidden="true">2.3.</strong> Function Types</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,5.html"><strong aria-hidden="true">2.4.</strong> Modules</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,6.html"><strong aria-hidden="true">2.5.</strong> Numbers</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,7.html"><strong aria-hidden="true">2.6.</strong> Proof by Simplification</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,8.html"><strong aria-hidden="true">2.7.</strong> Proof by Application</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,9.html"><strong aria-hidden="true">2.8.</strong> Proof by Case Analysis</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,10.html"><strong aria-hidden="true">2.9.</strong> Proof by Rewriting</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,11.html"><strong aria-hidden="true">2.10.</strong> Equal.chain and Equal.mirror</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,12.html"><strong aria-hidden="true">2.11.</strong> More Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="Book/chapter_03/3.html"><strong aria-hidden="true">3.</strong> Induction: Proof by Induction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/chapter_03/3,1.html"><strong aria-hidden="true">3.1.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="Book/chapter_03/3,2.html"><strong aria-hidden="true">3.2.</strong> More Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="Book/chapter_04/4.html"><strong aria-hidden="true">4.</strong> Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/chapter_04/4,1.html"><strong aria-hidden="true">4.1.</strong> Lists of Numbers</a></li><li class="chapter-item expanded "><a href="Book/chapter_04/4,2.html"><strong aria-hidden="true">4.2.</strong> Reasoning about Lists</a></li><li class="chapter-item expanded "><a href="Book/chapter_04/4,3.html"><strong aria-hidden="true">4.3.</strong> Maybe</a></li></ol></li><li class="chapter-item expanded "><a href="Book/chapter_05/5.html"><strong aria-hidden="true">5.</strong> Polymorphism</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/chapter_05/5,1.html"><strong aria-hidden="true">5.1.</strong> Functions as Data</a></li><li class="chapter-item expanded "><a href="Book/chapter_05/5,2.html"><strong aria-hidden="true">5.2.</strong> Additional Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="Book/chapter_06/6.html"><strong aria-hidden="true">6.</strong> Logic in Kind</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/chapter_06/6,1.html"><strong aria-hidden="true">6.1.</strong> Logical Connectives</a></li><li class="chapter-item expanded "><a href="Book/chapter_06/6,2.html"><strong aria-hidden="true">6.2.</strong> Falsehood and Negation</a></li><li class="chapter-item expanded "><a href="Book/chapter_06/6,3.html"><strong aria-hidden="true">6.3.</strong> Truth, Equivalence, and Quantification</a></li><li class="chapter-item expanded "><a href="Book/chapter_06/6,4.html"><strong aria-hidden="true">6.4.</strong> Programming with Propositions</a></li><li class="chapter-item expanded "><a href="Book/chapter_06/6,5.html"><strong aria-hidden="true">6.5.</strong> Applying Theorems to Arguments</a></li><li class="chapter-item expanded "><a href="Book/chapter_06/6,6.html"><strong aria-hidden="true">6.6.</strong> Kind vs Set Theory</a></li><li class="chapter-item expanded "><a href="Book/chapter_06/6,7.html"><strong aria-hidden="true">6.7.</strong> Classical vs. Constructive Logic</a></li></ol></li><li class="chapter-item expanded "><a href="Book/chapter_07/7.html"><strong aria-hidden="true">7.</strong> Inductively Defined Propositions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/chapter_07/7.1.html"><strong aria-hidden="true">7.1.</strong> Using Evidence in Proofs</a></li><li class="chapter-item expanded "><a href="Book/chapter_07/7.2.html"><strong aria-hidden="true">7.2.</strong> Inductive Relations</a></li><li class="chapter-item expanded "><a href="Book/chapter_07/7.3.html"><strong aria-hidden="true">7.3.</strong> Case Study: Regular Expressions</a></li><li class="chapter-item expanded "><a href="Book/chapter_07/7.4.html"><strong aria-hidden="true">7.4.</strong> Case Study: Improving Reflection</a></li><li class="chapter-item expanded "><a href="Book/chapter_07/7.5.html"><strong aria-hidden="true">7.5.</strong> Additional Exercises</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="Contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Hello, world! Welcome to the wonderful world of programming. This is an incredibly exciting and challenging field, full of possibilities and opportunities. We are eager to see what you will create and build during your learning journey.</p>
<p>When it comes to programming, it is essential to understand the importance of precision and safety in code. That's why we would like to talk about Kind, a powerful formal model checker for real-time systems. It allows you to specify desired properties for your system and automatically generates test cases to ensure that the system meets these properties. This is particularly valuable for critical projects, such as security systems, where accuracy and safety are crucial.</p>
<p>Programming is a constant journey of learning and personal development. Don't feel discouraged if you encounter difficulties along the way, these difficulties are part of the learning process and opportunities to grow and evolve. Remember that we are here to help you along the way, don't hesitate to ask for help if you need it.</p>
<p>Be prepared to work hard and face challenges, but also be prepared to celebrate your accomplishments and achievements. Remember to have fun and enjoy every moment of this incredible learning journey.</p>
<p>Good luck on your learning journey, and we look forward to seeing what you will create and build.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starting"><a class="header" href="#starting">Starting</a></h1>
<h2 id="welcome-to-kind"><a class="header" href="#welcome-to-kind">Welcome to Kind!</a></h2>
<p>Kind is an efficient, minimalist, and practical language that aims to rethink functional programming from scratch with a modern and consistent design.</p>
<p>The goal of this documentation is to be as simple as possible to learn Kind. That's why we decided to adopt a minimalist and simple design so that you can quickly find what you need.</p>
<p>Quick Navigation Index</p>
<ul>
<li>About Kind;</li>
<li>Installation guide for MacOS, Linux, and Windows;</li>
<li>Command guide;</li>
<li>Learning the basic concepts of Kind;</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-kind"><a class="header" href="#hello-kind">Hello, Kind!</a></h1>
<p>Kind is a programming language that aims to be practical and conventional. It is statically typed, which means that data types are defined beforehand and checked at compile time. These types are powerful enough to allow the proof of mathematical theorems.</p>
<p>When creating a new program in Kind, you have access to a vast universe of resources and functionalities. It's like all the tools you need are already there, ready to be used. With each new function or library you discover, it's like a new part of this universe is revealed.</p>
<p>Just like in a real universe, there is always something new to be discovered in Kind. There is a plethora of resources and tools available for you to explore and use in your programs. With such variety, it's possible to create solutions for practically any problem you can imagine.</p>
<p>If you're interested in learning more about programming and exploring the vast universe of Kind, then becoming a Kind programmer can be an exciting and rewarding adventure. There are many other Kind programmers out there to collaborate and learn with, making this journey even more exciting.</p>
<p>In summary, Kind is a modern, powerful, and versatile programming language that offers many opportunities for those who want to learn and explore the vast universe of programming. If you're interested in becoming a Kind programmer, there are many resources available to help you get started, from official documentation to active communities of users and developers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>This guide teaches you how to download and install Kind through Rust, using &quot;Cargo&quot;, a tool used to manage packages. It may be necessary to have an internet connection to proceed with this guide.</p>
<p>Firstly, install Rust using this <a href="https://www.rust-lang.org/tools/install">link</a></p>
<ul>
<li><em>Currently, Cargo is the only way to install Kind.</em></li>
<li><em>This guide was written when Kind was in beta version. Therefore, it is necessary to install the</em> <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly version</a>.</li>
</ul>
<h3 id="installing-kind-on-linux-or-macos"><a class="header" href="#installing-kind-on-linux-or-macos">Installing Kind on Linux or MacOS</a></h3>
<p>Use your package manager (Cargo) to install Kind. To do this, open the terminal and type the following code:</p>
<pre><code>cargo +nightly install kind2
</code></pre>
<h3 id="installing-kind-on-windows"><a class="header" href="#installing-kind-on-windows">Installing Kind on Windows</a></h3>
<p>For Windows users, it is possible to use Kind through CMD or WSL2. If you choose WSL, the installation method is in this <a href="https://harsimranmaan.medium.com/install-and-setup-rust-development-environment-on-wsl2-dccb4bf63700">link</a>.</p>
<p>Use your package manager (Cargo) to install Kind. To do this, open Bash(WSL2) or Terminal(CMD) and type the following command:</p>
<pre><code>cargo +nightly install kind2
</code></pre>
<h3 id="cloning-the-kind-repository---method-1"><a class="header" href="#cloning-the-kind-repository---method-1">Cloning the Kind Repository - Method 1</a></h3>
<p>Clone the Kind repository using the git command &quot;git clone&quot;, as follows:</p>
<pre><code>git clone https://github.com/HigherOrderCO/Kind
</code></pre>
<p>After the cloning step, use the following command for installation:</p>
<pre><code>cargo +nightly install --path crates/kind-cli --force
</code></pre>
<h3 id="cloning-the-kind-repository---method-2"><a class="header" href="#cloning-the-kind-repository---method-2">Cloning the Kind Repository - Method 2</a></h3>
<p>Cargo allows you to install using git, without the need to clone any repository, as follows:</p>
<pre><code>cargo +nightly install --git https://github.com/HigherOrderCO/kind.git 
</code></pre>
<p>By following the above steps, we can start using Kind.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h1>
<p>At this point, Kind should already be installed on your machine. If not, please go back to the installation and follow the instructions.</p>
<p>In this guide, we will be using command lines and text editors, so make sure your terminal is open to proceed with the steps.</p>
<h3 id="creating-the-files"><a class="header" href="#creating-the-files">Creating the Files</a></h3>
<p>First of all, create a directory to store the Kind files. It is recommended to use a dedicated directory to keep all exercises and examples, but feel free to do as you please. The three commands below will create a directory named 'KindExamples' and a file named 'hello_world.kind2' inside the project directory. Use them in order:</p>
<pre><code class="language-diff">// Linux, Mac or WSL
mkdir KindExamples
cd    KindExamples
touch hello_world.kind2
</code></pre>
<p>The .kind2 extension is what makes it a Kind file. For example, a file that ends with .exe is an executable; .js is a JavaScript file; .rs is a Rust file, etc.</p>
<p>If the commands were used correctly, the hello_world.kind2 file should be inside the KindExamples folder. So let's have some fun, CODING!</p>
<h3 id="hello-world-1"><a class="header" href="#hello-world-1">Hello World</a></h3>
<p>Open the hello_world.kind2 file in your text editor, it will be empty, but don't worry. From now on, there will be some advanced concepts. Everything will make sense in the future, and pertinent concepts will be explained in due time. It is recommended that you manually type the codes, instead of copying and pasting them into your file.</p>
<p>Let's write your first code in the hello_world.kind2 file:</p>
<pre><code class="language-Rust">Main {
  &quot;Hello, Kind!&quot;
}
</code></pre>
<h3 id="type-checking"><a class="header" href="#type-checking">Type Checking</a></h3>
<p>With the code ready, you should use Type Checking to check if everything is in order. The type checker is still unknown in this guide, but it will be explained in more detail later. For now, just understand it as a checker that verifies if the file is correctly &quot;typed&quot;.</p>
<p>To check the type of a Kind file, simply use the command <code>kind2 check nomeDoArquivo.kind2</code>. For the hello_world.kind2 file, it would be:</p>
<pre><code>kind2 check hello_world.kind2
</code></pre>
<p>The message <code>All terms check.</code> means your file is ready!</p>
<pre><code>All terms check.
</code></pre>
<p>Is the type checking correct? Then let's run the code.</p>
<h3 id="running-the-code"><a class="header" href="#running-the-code">Running the code</a></h3>
<p>To run a file in Kind, use the command <code>kind2 run nomeDoArquivo.kind2</code>. It should look like this:</p>
<pre><code>kind2 run hello_world.kind2
</code></pre>
<p>And there you go! Your terminal should print &quot;Hello, Kind!&quot; back to you.</p>
<h4 id="remember-to-do-all-the-steps-above-check-the-type-and-then-run"><a class="header" href="#remember-to-do-all-the-steps-above-check-the-type-and-then-run">Remember to do all the steps above, check the type, and then run</a></h4>
<p>Great, now that you have your first Kind program running, you can start exploring more about the language and its features. Congratulations on your progress!</p>
<p>If you have any questions or need help, don't hesitate to ask. We are always available to help!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-kind-1"><a class="header" href="#hello-kind-1">Hello Kind!</a></h1>
<p>Now that you have learned how to create and run a Kind file, let's dive deeper into the basics of Kind. In the next section, you will learn about Kind's type system, syntax, variables, and functions.</p>
<h4 id="kinds-type-system"><a class="header" href="#kinds-type-system">Kind's Type System</a></h4>
<p>Kind has a static type system, which means that the type of a variable must be known at compile-time. Kind has a rich type system that includes primitive types, algebraic data types, and type parameters.</p>
<h4 id="kind-syntax"><a class="header" href="#kind-syntax">Kind Syntax</a></h4>
<p>Kind's syntax is inspired by functional programming languages like Haskell. The syntax is concise and expressive, making it easy to read and write code. It uses indentation instead of braces to define blocks of code.</p>
<h4 id="variables"><a class="header" href="#variables">Variables</a></h4>
<p>In Kind, variables are declared using the keyword let followed by the variable name. For example:</p>
<pre><code>let x = 42
</code></pre>
<h4 id="functions"><a class="header" href="#functions">Functions</a></h4>
<p>Functions in Kind are declared using the first letter capitalized. The function may take parameters or not and returns a value. For example:</p>
<pre><code>Nat.add (a: Nat) (b: Nat) : Nat
</code></pre>
<p>This is just a brief overview of the basics of Kind. You will learn more about these concepts as you progress through the guide. Now that you have learned about Kind's basics, it's time to move on to the next section and learn about advanced concepts in Kind programming.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>The functional programming style brings programming closer to simple and everyday
mathematics: If a procedure or method has no side effects, then (ignoring efficiency)
all we need to understand about it is how to map inputs to outputs - in other words,
we can think of it as a concrete method that computes a mathematical function.
This is one sense of &quot;functional&quot; in &quot;functional programming&quot;. The direct connection
between programs and simple mathematical objects supports both the formality of
correctness proofs and informal reasoning about program behavior.</p>
<p>The other sense in which functional programming is &quot;functional&quot; is that it emphasizes
the use of functions as first-class values - that is, values that can be passed as
arguments to other functions, returned as results, included in data structures, etc.
The recognition that functions can be treated in this way as data enables a range of
useful commands.</p>
<p>Other common features of functional languages include algebraic data types and pattern
matching, which make it easy to construct and manipulate data structures, and sophisticated
polymorphic type systems, supporting abstraction and code reuse. Kind contains all of these
features.</p>
<p>The first half of this chapter introduces the most basic elements of the Kind functional
programming language. The second half introduces some basic techniques that can be used
to prove properties about programs in Kind.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="enumerated-types"><a class="header" href="#enumerated-types">Enumerated Types</a></h2>
<p>An unusual aspect of Kind, similar to other proof languages such as Idris and Coq, is that its built-in toolset is quite small. For example, instead of providing the usual range of primitive types (booleans, lists, strings, etc), Kind has only two primitive types (U60: unsigned 60-bit binary integers) and (F60: unsigned 60-bit binary floating point numbers) and offers a powerful mechanism for defining new data types from scratch, from which all these familiar types and more can be derived.</p>
<p>To demonstrate how the definition mechanism works, let's start with a simple example.</p>
<!-- TODO Esse bloco de texto será relevante quando tivermos um sistema de pacotes apropriado -->
<!-- Naturally, the Idris distribution comes with extensive standard libraries providing
definitions of booleans, numbers, and many common data structures like lists and
hash tables (see the prelude and contrib packages), as well as the means to write
type-safe effectful code (see the effects package) and pruvlioj, a toolkit for proof
automation and program construction. But there is nothing magic or primitive
about these library definitions. To illustrate this, we will explicitly recapitulate
all the definitions we need in this course, rather than just getting them implicitly
from the library. -->
<div style="break-before: page; page-break-before: always;"></div><h3 id="days-of-the-week"><a class="header" href="#days-of-the-week">Days of the Week</a></h3>
<p>The following declaration tells Kind that we are declaring a new set of data - a Type.</p>
<pre><code class="language-rust ignore">type Day {  // Day is a Type
  monday    // Monday    is a Day
  tuesday   // Tuesday   is a Day
  wednesday // Wednesday is a Day
  thursday  // Thursday  is a Day
  friday    // Friday    is a Day
  saturday  // Saturday  is a Day
  sunday    // Sunday    is a Day
}</code></pre>
<p>The type is called <code>Day</code>, and its members are <code>Monday</code>, <code>Tuesday</code>, <code>Wednesday</code>, etc. The <code>&lt;name&gt; : &lt;type&gt;</code> definition can be read as &quot;name is a type&quot;.
Above, we have both an example of creating a new <code>Day : Type</code>, and declaring an element of an existing type <code>Wednesday : Day</code>.</p>
<p>Now that we have defined what a Day is, we can write functions that operate using this type. Type the following:</p>
<pre><code class="language-rust ignore">NextWeekday (d: Day) : Day</code></pre>
<p>This declares that we have a function called NextWeekday, which takes an argument called <code>d</code>, of type <code>Day</code>, and returns a <code>Day</code>. Continue defining the function as follows:</p>
<pre><code class="language-rust ignore">NextWeekday Day.monday  = ?
NextWeekday Day.tuesday    = ?
NextWeekday Day.wednesday  = ?
NextWeekday Day.thursday = ?
NextWeekday Day.friday   = ?
NextWeekday Day.saturday  = ?
NextWeekday Day.sunday  = ?</code></pre>
<p>Here, we are doing what we call <em>pattern matching</em>. We are declaring how the function should run for each possibility of the input <code>d</code>. It won't always be necessary to do this, as will be shown in examples later on.</p>
<p>Finally, complete the functions by writing what each one should return, and use spaces to style as you prefer:</p>
<pre><code class="language-rust ignore">NextWeekday Day.monday = Day.tuesday
NextWeekday Day.tuesday   = Day.quarta
NextWeekday Day.wednesday = Day.thursday
NextWeekday Day.thursday = Day.sexta
NextWeekday Day.friday  = Day.monday
NextWeekday Day.saturday = Day.monday
NextWeekday Day.sunday = Day.monday</code></pre>
<p>With the function finished, we can check its operation with some examples. The main way to do this in Kind is to create a <code>Main</code> function in your file and run it with the command <code>kind2 run &lt;file&gt;</code>.</p>
<p>For example, if you write the following <code>Main</code> and run the file:</p>
<pre><code class="language-rust ignore">Main {
  // Two workdays after Saturday
  NextWeekday (NextWeekday Day.saturday)
}</code></pre>
<p>You should get something like:</p>
<pre><code class="language-terminal">(Day.tuesday)
</code></pre>
<p>Another way to test your code is to say what we expect the code to return, through a proof:</p>
<pre><code class="language-rust ignore">// // The third workday after a Monday is a Thursday
TestNextWeekday : Equal Day (NextWeekday (NextWeekday (NextWeekday Day.monday))) Day.thursday
TestNextWeekday = Equal.refl</code></pre>
<p>The details of how proofs work will be explained later on. For now, what needs to be understood is:</p>
<ul>
<li>We have the realization that <code>(NextWeekday (NextWeekday (NextWeekday Day.monday)))</code> is equal to <code>Day.thursday</code></li>
<li>This realization was named <code>TestNextWeekday</code></li>
<li><code>TestNextWeekday = Equal.refl</code> says that the realization can be proven using only simplification on both sides.</li>
</ul>
<p>To test that this proof (and any other proof going forward) is correct, you need to check the file using the command <code>kind2 check &lt;file&gt;</code>, which should return something like:</p>
<pre><code class="language-terminal">All terms check.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="booleans"><a class="header" href="#booleans">Booleans</a></h3>
<p>Similarly, we can declare the <code>Bool</code> type for booleans:</p>
<pre><code class="language-rust ignore">type Bool {
 true
 false
}</code></pre>
<!-- TODO mudar isso aqui caso tenhamos um gerenciador de pacotes -->
<p>We are declaring our own booleans just to demonstrate how to do everything from scratch. Kind has its own default implementation of booleans in the standard package (<a href="Book/chapter_02/github.com/Kindelia/Wikind">Wikind</a>), along with many other structures and proofs.</p>
<p>In fact, at the time of writing, you need to be working within the Wikind folder to do proofs and the theorem resolution utilities are not built-in.</p>
<p>Functions that operate on booleans are defined in the same way as seen earlier:</p>
<pre><code class="language-rust ignore">// Negação lógica
Notb (b: Bool) : Bool
Notb Bool.true  = Bool.false
Notb Bool.false = Bool.true

// E lógico
Andb (b1: Bool) (b2: Bool) : Bool
Andb Bool.true  b2 = b2
Andb Bool.false b2 = Bool.false

// OU lógico
Orb (b1: Bool) (b2: Bool) : Bool
Orb Bool.true  b2 = Bool.true
Orb Bool.false b2 = b2</code></pre>
<p>The last two functions demonstrate the syntax of Kind for multi-argument functions, and also show that it is possible to <em>pattern match</em> only on some of the variables of the function, not necessarily all.</p>
<p>The cases of the last function can be exhaustively tested (all possibilities) as shown below, creating the truth table of the logical operation.</p>
<pre><code class="language-rust ignore">TestOrb1 : Equal Bool (Orb Bool.true Bool.false) Bool.true
TestOrb1 = Equal.refl

TestOrb2 : Equal Bool (Orb Bool.false Bool.false) Bool.false
TestOrb2 = Equal.refl

TestOrb3 : Equal Bool (Orb Bool.false Bool.true) Bool.true
TestOrb3 = Equal.refl

TestOrb4 : Equal Bool (Orb Bool.true Bool.true) Bool.true
TestOrb4 = Equal.refl</code></pre>
<h4 id="nandb"><a class="header" href="#nandb">Nandb</a></h4>
<p>Replace the hole &quot;?&quot;, completing the following function;</p>
<p>then check if it is correct using the following statements (Analogous to how it was done for the <code>Orb</code> function). The function returns <code>Bool.true</code> if any of its inputs is <code>Bool.false</code>.</p>
<pre><code class="language-rust ignore">Nandb (b1: Bool) (b2: Bool) : Bool
Nandb b1 b2 = ?

Test_nandb1 : Equal Bool (Nandb Bool.true Bool.false) Bool.true
Test_nandb1 = ?

Test_nandb2 : Equal Bool (Nandb Bool.false Bool.false) Bool.true
Test_nandb2 = ?

Test_nandb3 : Equal Bool (Nandb Bool.false Bool.true) Bool.true
Test_nandb3 = ?

Test_nandb4 : Equal Bool (Nandb Bool.true Bool.true) Bool.false
Test_nandb4 = ?</code></pre>
<h4 id="and3"><a class="header" href="#and3">And3</a></h4>
<p>Do the same for the <code>Andb3</code> function below. This function should return <code>Bool.true</code> if all inputs are <code>Bool.true</code>, and <code>Bool.false</code> otherwise.</p>
<pre><code class="language-rust ignore">Andb3 (b1: Bool) (b2: Bool) (b3: Bool) : Bool
Andb3 b1 b2 b3 = ?

Test_andb3_1 Equal Bool (Andb3 Bool.true Bool.true Bool.true) Bool.true
Test_andb3_1 = ?

Test_andb3_2 Equal Bool (Andb3 Bool.false Bool.true Bool.true) Bool.false
Test_andb3_2 = ?

Test_andb3_3 Equal Bool (Andb3 Bool.true Bool.false Bool.true) Bool.false
Test_andb3_3 = ?

Test_andb3_4 Equal Bool (Andb3 Bool.true Bool.true Bool.false) Bool.false
Test_andb3_4 = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="types-of-functions"><a class="header" href="#types-of-functions">Types of functions</a></h2>
<p>All expressions in Kind have a type, describing what type of thing it computes.
For example, <code>Bool.true</code> has type <code>Bool</code>, just like <code>Notb Bool.true</code> also has type <code>Bool</code>.</p>
<p>Functions like <code>Notb</code>, before they receive arguments, also have a type, just like <code>Bool.true</code> or <code>Bool.false</code>.
Their types are called Function Types, and are denoted with arrows.</p>
<p><code>Notb</code>, for example, would be denoted as <code>Bool -&gt; Bool</code>, which can be read as
&quot;a function that takes a <code>Bool</code> as input and returns a value of type <code>Bool</code>&quot;.
Similarly, the type of the <code>Andb</code> function is <code>Bool -&gt; Bool -&gt; Bool</code>, meaning
&quot;a function that takes two arguments of type <code>Bool</code> and returns a value of type <code>Bool</code>&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<!-- TODO fill in when we have a module system -->
<p>We don't have a module system yet :pensive:. To use functions from other files,
you need to create a file within the same directory (e.g., the root folder of <a href="Book/chapter_02/github.com/Kindelia/Wikind">Wikind</a>).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="numbers"><a class="header" href="#numbers">Numbers</a></h2>
<p>The types we have defined so far are examples of enumerated types: their definitions explicitly enumerate a finite set of elements. A more interesting way to define a type is to establish a collection of inductive rules describing its elements. For example, we can define natural numbers as follows:</p>
<pre><code class="language-rust ignore">type Nat {
  zero
  succ (pred: Nat)
}</code></pre>
<p>This definition can be read as:</p>
<ul>
<li><code>Nat.zero</code> is a natural number;</li>
<li><code>Nat.succ</code> is a constructor that takes a natural number, constructing another natural number;
<ul>
<li>That is, if <code>n</code> is a natural number, then <code>(Nat.succ n)</code> will also be.</li>
</ul>
</li>
</ul>
<p>Every type defined inductively (such as <code>Nat</code>, <code>Bool</code> ou <code>Dia</code>) is a set of expressions. The definition of <code>Nat</code> says how expressions of type <code>Nat</code> can be constructed:</p>
<ul>
<li>The expression <code>Nat.zero</code> belongs to the set of <code>Nat</code>;</li>
<li>If <code>n</code> is an expression in the set of <code>Nat</code>, then <code>(Nat.succ n)</code> is also an expression in the set of <code>Nat</code>;</li>
<li>Expressions formed in these two ways are the only ones that belong to <code>Nat</code>.</li>
</ul>
<p>The same rules apply to our definitions of <code>Dia</code> and <code>Bool</code>.
The annotations we used for them are analogous to the <code>Nat.zero</code> constructor, indicating that they do not receive any arguments.</p>
<p>These three conditions demonstrate the power of inductive declarations. They imply that the expression <code>Nat.zero</code>, the expression <code>(Nat.succ Nat.zero)</code>, the expression <code>(Nat.succ (Nat.succ Nat.zero))</code> and so on, are of the <code>Nat</code> set, while other expressions such as <code>Bool.true</code>, <code>(Andb Bool.true Bool.false)</code>, and <code>(Nat.succ (Nat.succ Bool.false))</code> are not.</p>
<p>We can write simple functions using <em>pattern matching</em> on natural numbers in the same way we did above - for example, the predecessor function:</p>
<pre><code class="language-rust ignore">Pred (n: Nat) : Nat
// Since natural numbers are strictly non-negative,
// we use as a convention that anything that would be
// less than 0 returns 0
Pred  Nat.zero    = Nat.zero
Pred (Nat.succ k) = k</code></pre>
<p>The second pattern can be read as: &quot;if <code>n</code> has the form <code>(Nat.succ k)</code> for some k, return k.&quot;</p>
<pre><code class="language-rust ignore">MinusTwo (n: Nat) : Nat
MinusTwo  Nat.zero               = Nat.zero
MinusTwo (Nat.succ  Nat.zero)    = Nat.zero
MinusTwo (Nat.succ (Nat.succ k)) = k</code></pre>
<!-- TODO atualizar isso aqui pro sugar de números naturais, se vier a existir -->
<p>To avoid having to write a sequence of <code>Nat.succ</code> every time you want a <code>Nat</code>, you can use the <code>n</code> suffix at the end of any number, for example o <code>5n</code>, which takes a number written in the primitive type <code>U60</code> plus the <code>n</code> suffix and returns the corresponding <code>Nat</code>.
{...}</p>
<!-- TODO -->
<pre><code class="language-rust ignore">Test : Equal Nat 6n (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))
Test = Equal.refl</code></pre>
<!-- TODO conferir q eu não estou delirando nesse parágrafo -->
<p>The <code>Nat.succ</code> constructor has type <code>Nat -&gt; Nat</code>, as do the functions <code>MinusTwo</code> and <code>Pred</code>. They are all things that, when applied to a <code>Nat</code>, return a <code>Nat</code>. The essential difference between <code>Nat.succ</code> and the other two, however, is that functions come with reduction rules - for example, <code>Pred (Nat.succ Nat.zero)</code> is reducible to <code>Nat.zero</code> - while <code>Nat.succ</code> does not. Although it is a function applicable to an argument, it does not compute anything.</p>
<p>For most number function definitions, <em>pattern matching</em> alone is not enough: we will also need recursion. For example, to check whether a number <code>n</code> is even, we can recursively check whether <code>n-2</code> is even.</p>
<pre><code class="language-rust ignore">Evenb (n: Nat) : Bool
Evenb  Nat.zero               = Bool.true
Evenb (Nat.succ  Nat.zero)    = Bool.false
Evenb (Nat.succ (Nat.succ k)) = Evenb k</code></pre>
<p>We can define O<code>ddb</code> (a function to check if a number is odd) with a similar recursive declaration, but we also have a simpler and somewhat easier to work with definition:</p>
<pre><code class="language-rust ignore">Oddb (n: Nat) : Bool
Oddb n = Notb (Evenb n)</code></pre>
<pre><code class="language-rust ignore">TestOddb1 : Equal Bool (Oddb 1n) Bool.true
TestOddb1 = Equal.refl

TestOddb2 : Equal Bool (Oddb 4n) Bool.false
TestOddb2 = Equal.refl</code></pre>
<p>Naturally, we can also define functions with multiple arguments by recursion.</p>
<pre><code class="language-rust ignore">Plus (n: Nat) (m: Nat) : Nat
Plus  Nat.zero    m = m
Plus (Nat.succ k) m = Nat.succ (Plus k m)</code></pre>
<p>Adding <code>3n</code> and <code>2n</code> will return 5n as expected.
The simplification that Kind performs to arrive at this value can be visualized as follows:</p>
<pre><code class="language-terminal">Plus (Nat.succ (Nat.succ (Nat.succ Nat.zero))) (Nat.succ (Nat.succ Nat.zero))

&gt; Nat.succ (Plus (Nat.succ (Nat.succ Nat.zero)) (Nat.succ (Nat.succ Nat.zero)))
by the second rule of Plus

&gt; Nat.succ (Nat.succ (Plus (Nat.succ Nat.zero)) (Nat.succ (Nat.succ Nat.zero)))
by the second rule of Plus

&gt; Nat.succ (Nat.succ (Nat.succ (Plus Nat.zero (Nat.succ (Nat.succ Nat.zero)))))
by the second rule of Plus

&gt; Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))
by the first rule of Plus
</code></pre>
<p>Multiplication can be defined using the definition of Plus, as follows:</p>
<pre><code class="language-rust ignore">Mult (n: Nat) (m: Nat) : Nat
Mult  Nat.zero    m = Nat.zero
Mult (Nat.succ k) m = Plus m (Mult k m)</code></pre>
<pre><code class="language-rust ignore">TestMult1 : Equal Nat (Mult 3n 3n) 9n
TestMult1 = Equal.refl</code></pre>
<p>You can also use <em>pattern matching</em> on two expressions at the same time:</p>
<pre><code class="language-rust ignore">Minus (n: Nat) (m: Nat) : Nat
Minus  Nat.zero     m           = Nat.zero
Minus  n            Nat.zero    = n
Minus (Nat.succ k) (Nat.succ j) = Minus k j</code></pre>
<!-- TODO conferir se wildcard no lhs já está funcionando -->
<!-- The _ in the first line is a wildcard pattern. Writing _ in a
pattern is the same as writing some variable that doesn’t get used on the
right-hand side. This avoids the need to invent a bogus variable name. -->
<p>The <code>Exp</code> function can be defined using <code>Mult</code> (analogous to how <code>Mult</code> is defined using <code>Plus</code>):</p>
<pre><code class="language-rust ignore">Exp (base: Nat) (power: Nat) : Nat
Exp base  Nat.zero    = Nat.succ Nat.zero
Exp base (Nat.succ k) = Mult base (Exp base k)</code></pre>
<h4 id="factorial"><a class="header" href="#factorial">Factorial</a></h4>
<p>Recall the basic mathematical definition of factorial:</p>
<p>\[\mathrm
Factorial(n) = \begin{cases}
\text{if $n$} = 0\,&amp; 1 \<br />
\\ \text{else} &amp; n * Factorial(n-1)
\end{cases}
\]</p>
<p>\[
f(x)=\begin{cases}x&amp;(x = 1)\\x f(x-1)&amp;(x\gt 1)\end{cases} , x\in \Bbb{N}
\]</p>
<p>Translate the factorial function into Kind2:</p>
<pre><code class="language-rust ignore">Factorial (n: Nat) : Nat
Factorial n = ?</code></pre>
<pre><code class="language-rust ignore">TestFactorial1 : Equal Nat (Factorial 3n ) 6n
TestFactorial1 = ?

TestFactorial2 : Equal Nat (Factorial 5n) 120n
TestFactorial2 = ?</code></pre>
<p>The <code>Eql</code> function tests equality between Naturals, returning a boolean.</p>
<pre><code class="language-rust ignore">Eql (n: Nat) (m: Nat) : Bool
Eql  Nat.zero     Nat.zero    = Bool.true
Eql  Nat.zero    (Nat.succ j) = Bool.false
Eql (Nat.succ k)  Nat.zero    = Bool.false
Eql (Nat.succ k) (Nat.succ j) = Eql k j</code></pre>
<p>The<code>Lte</code> function tests if the first argument is less than or equal to the second, returning a boolean.</p>
<pre><code class="language-rust ignore">Lte (n: Nat) (m: Nat) : Bool
Lte  Nat.zero     m           = Bool.true
Lte (Nat.succ k)  Nat.zero    = Bool.false
Lte (Nat.succ k) (Nat.succ j) = Lte k j</code></pre>
<pre><code class="language-rust ignore">TestLte1 : Equal Bool (Lte 2n 2n) Bool.true
TestLte1 = Equal.refl

TestLte2 : Equal Bool (Lte 2n 4n) Bool.true
TestLte2 = Equal.refl

TestLte3 : Equal Bool (Lte 4n 2n) Bool.false
TestLte3 = Equal.refl</code></pre>
<h4 id="blt_nat"><a class="header" href="#blt_nat">Blt_nat</a></h4>
<p>The <code>Blt_nat</code>function tests the &quot;less than&quot; relationship in natural numbers.
Instead of creating a new recursive function, define it using previously defined functions.</p>
<pre><code class="language-rust ignore">Blt_nat (n: Nat) (m: Nat) : Bool
Blt_nat n m = ?</code></pre>
<pre><code class="language-rust ignore">Test_blt_nat_1 : Equal Bool (Blt_nat 2n 2n) Bool.false
Test_blt_nat_1 = ?

Test_blt_nat_2 : Equal Bool (Blt_nat 2n 4n) Bool.true
Test_blt_nat_2 = ?

Test_blt_nat_3 : Equal Bool (Blt_nat 4n 2n) Bool.false
Test_blt_nat_3 = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="proof-by-simplification"><a class="header" href="#proof-by-simplification">Proof by Simplification</a></h2>
<p>Now that we have defined some data types and functions, let's start proving properties of their behaviors. In fact, we have already been doing this: each function in the previous sections that starts with <code>Test</code> makes a precise assertion about the behavior of some function for specific inputs. The proofs of these assertions were always the same: use <code>Equal.refl</code> to check that both sides are indeed identical.</p>
<p>The same type of &quot;proof by simplification&quot; can be used to prove more interesting properties. For example, the fact that <code>Nat.zero</code> is a &quot;neutral element&quot; on the left-hand side of addition can be proven simply by observing that <code>Plus Nat.zero n</code> reduces to <code>n</code>, regardless of what <code>n</code> is, a fact that can be read directly from the definition of <code>Plus</code>.</p>
<pre><code class="language-rust ignore">Plus_Z_n (n: Nat) : Equal Nat (Plus Nat.zero n) n
Plus_Z_n n = Equal.refl</code></pre>
<p>Other similar theorems can be proven in a similar way.</p>
<pre><code class="language-rust ignore">Plus_1_l (n: Nat) : Equal Nat (Plus (Nat.succ Nat.zero) n) (Nat.succ n)
Plus_1_l n = Equal.refl

Mult_0_l (n: Nat) : Equal Nat (Mult Nat.zero n) Nat.zero
Mult_0_l n = Equal.refl </code></pre>
<p>The <code>_l</code> indicates that the proof involves the value on the left-hand side. For example: the proof of adding 1 on the left-hand side <code>(Plus_1_l)</code> or the proof of multiplying by zero on the left-hand side <code>(Mult_0_l)</code>.</p>
<p>Although simplification is powerful enough to prove some general facts, there are several statements that cannot be demonstrated with simplification alone. For example, we cannot use it to prove that <code>Nat.zero</code> is a neutral element for addition on the right-hand side.</p>
<pre><code class="language-rust ignore">Plus_n_Z (n: Nat) : Equal Nat n (Plus n Nat.zero)
Plus_n_Z n = Equal.refl</code></pre>
<pre><code class="language-diff">- ERROR Type mismatch  

   • Got      : Equal Nat n n
   • Expected : Equal Nat n (Plus n 0n)

   • Context: 
   •   n : Nat 

   Plus_n_Z n = Equal.refl
                ┬─────────
                └Here!
</code></pre>
<p>(Can you explain why this is?)</p>
<p>The next chapter will introduce the concept of induction, a powerful technique that can be used to demonstrate this theorem. For now, however, let's see some more simple types of proof.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="proof-by-application"><a class="header" href="#proof-by-application">Proof by Application</a></h2>
<p>Our first tool for proving non-trivial theorems will be applying functions to both sides of an equality. For this, we will use the function <code>Equal.apply</code>, which takes an equality (<code>Equal</code>) and a function, and applies this function to both sides of the equality, generating a new equality.</p>
<p>For example:</p>
<pre><code class="language-rust ignore">Example_apply (n: Nat) (m: Nat) (e: Equal Nat m n) : Equal Nat (Nat.succ m) (Nat.succ n)
Example_apply n m e = ?</code></pre>
<p>What do we have here? We have a proof that takes another proof/equality as argument. This means that we will carry out our proof assuming that the proof given as argument is also true. So, reading the statement of the proof, we have: &quot;Given two naturals, <code>m</code> and <code>n</code>, and a proof that they are equal, prove that <code>Nat.succ m</code> and <code>Nat.succ n</code> are also equal&quot;.</p>
<p>We learned in our math classes that applying a function to both sides of an equality preserves the equality (<code>x/2 = 3 -&gt; 2x/2 = 23</code>), and we can see that to prove what we want, we need to apply the function <code>Nat.succ</code> to both sides of <code>e</code>, using <code>Equal.apply</code>.</p>
<pre><code class="language-diff">+ INFO  Inspection.

  • Expected: (Equal Nat (Nat.succ m) (Nat.succ n)) 

  • Context: 
  •   n : Nat 
  •   m : Nat 
  •   e : (Equal Nat m n) 

  Example_apply n m e = ?
                        ┬
                        └Here!
</code></pre>
<p>How does <code>Equal.apply</code> work: It takes as first argument the function to be applied to both sides, and as second argument the equality to which to apply the function. If you didn't understand the passage of the argument function (<code>x =&gt; Nat.succ x</code>), it is what we call a lambda function, and is also known as an anonymous function. Lambda functions are identified by their arrow <code>=&gt;</code>, where on the left side of the arrow is the name of the function argument - use any name you want - and on the right side is the body of the function: what it returns. Our current lambda function is a function that takes any <code>x</code> and returns <code>Nat.succ x</code>.</p>
<p>We can see the result of this by <code>check</code> the file:</p>
<pre><code class="language-diff">+ INFO  Inspection.

  • Expected: (Equal Nat (Nat.succ m) (Nat.succ n)) 

  • Context: 
  •   n : Nat 
  •   m : Nat 
  •   e       : (Equal Nat m n) 
  •   e_apply : (Equal Nat (Nat.succ m) (Nat.succ n)) 
  •   e_apply = (Equal.apply Nat Nat m n (x =&gt; (Nat.succ x)) e) 

  let e_apply = Equal.apply (x =&gt; Nat.succ x) e
      ?
      ┬
      └Here!
</code></pre>
<p>As <code>e_apply</code> is an equality of type <code>Equal Nat (Nat.succ m) (Nat.succ n)</code>, the proof we are looking for is simply to return it, and we will have concluded our proof.</p>
<pre><code class="language-rust ignore">Example_apply (n: Nat) (m: Nat) (e: Equal Nat m n) : Equal Nat (Nat.succ m) (Nat.succ n)
Example_apply n m e =
  let e_apply = Equal.apply (x =&gt; Nat.succ x) e
  e_apply</code></pre>
<pre><code class="language-terminal">  All terms checked.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="proof-by-case-analysis"><a class="header" href="#proof-by-case-analysis">Proof by Case Analysis</a></h2>
<p>The next tool for formal proofs will be case analysis, which means using <em>pattern matching</em> in the proof. For example, let's prove that the logical AND of anything and False is always False:</p>
<pre><code class="language-rust ignore">Example_case_analysis (b: Bool) : Equal Bool (Andb b1 Bool.false) Bool.false
Example_case_analysis b = ?</code></pre>
<p>Although it may seem like a proof that could be solved simply with <code>Equal.refl</code>, it's not the case. This is because the <code>Andb</code> function pattern matches on the first argument, and we don't have its value in the proof, so it remains &quot;stuck&quot;.</p>
<p>To give a value to it and show that the proof is correct for both <code>Bool</code> values, we <em>pattern match</em> in the proof, creating two different proofs: one for when <code>b</code> is <code>Bool.true</code> and one for when it's <code>Bool.false</code>.</p>
<pre><code class="language-rust ignore">Example_case_analysis (b: Bool) : Equal Bool (Andb b Bool.false) Bool.false
Example_case_analysis Bool.true  = ?
Example_case_analysis Bool.false = ?</code></pre>
<p>And both of these proofs are directly solvable with <code>Equal.refl</code>, since the <em>type checker</em> can reduce both of them to <code>Equal Bool.false Bool.false</code> directly.</p>
<pre><code class="language-rust ignore">Example_case_analysis (b: Bool) : Equal Bool (Andb b Bool.false) Bool.false
Example_case_analysis Bool.true  = Equal.refl
Example_case_analysis Bool.false = Equal.refl</code></pre>
<!-- TODO Reescrita no Kind2 é uma caixa de minhocas por si só,
talvez colocar mais pro final do capítulo,
ao talvez até colocar depois desse capítulo -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="proof-by-rewriting"><a class="header" href="#proof-by-rewriting">Proof by Rewriting</a></h2>
<p>This theorem is a bit more interesting than the previous ones:</p>
<pre><code class="language-rust ignore">Plus_id_example (n: Nat) (m: Nat) (e: Equal Nat n m) : Equal Nat (Plus n n) (Plus m m)</code></pre>
<p>As shown before, this is a proof that has another proof or hypothesis within its arguments: in this case, we have <code>Equal n m</code> - meaning, <code>n</code> and <code>m</code> are equal.</p>
<p>Since n and m are arbitrary numbers, we can't just use simplification to prove the theorem. Instead, we observe that, since we assume <code>Equal n m</code>, we could substitute <code>n</code> for <code>m</code> in the goal and both sides will be equal. The function we use to perform this substitution is <code>Equal.rewrite</code>.</p>
<!-- TODO revisar esse parágrafo -->
<p>Since we can't rewrite directly in the goal, we use another equality and make it equal to the goal. In our case, we will use an <code>Equal.apply</code> on <code>e</code> to obtain this equality.</p>
<pre><code class="language-rust ignore">Plus_id_example (n: Nat) (m: Nat) (e: Equal Nat n m) : Equal Nat (Plus n n) (Plus m m)

Plus_id_example n m e =
  let app = Equal.apply (k =&gt; Plus k n) e
  ? </code></pre>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: Equal Nat (Plus n n) (Plus m m) 

   • Context: 
   •   n   : Nat 
   •   m   : Nat 
   •   e   : Equal Nat n m 
   •   app : Equal Nat (Plus n n) (Plus m n) 
   •   app = Equal.apply Nat Nat n m (k =&gt; (Plus k n)) e
    
   let app = Equal.apply (k =&gt; Plus k n) e
      ?
      ┬
      └Here!
</code></pre>
<p>This <code>app</code> will be of type <code>Equal (Plus n n) (Plus m n)</code>, as shown in the comment. With this done, we need to replace <code>n</code> with <code>m</code> on the right-hand side of the equality, and for that we use rewrite:</p>
<pre><code class="language-rust ignore">Plus_id_example (n: Nat) (m: Nat) (e: Equal Nat n m) : Equal Nat (Plus n n) (Plus m m)
Plus_id_example n m e =
  let app = Equal.apply (k =&gt; Plus k n) e
  let rrt = Equal.rewrite e (x =&gt; Equal (Plus n n) (Plus m x)) app
  rrt</code></pre>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: Equal Nat (Plus n n) (Plus m m) 

   • Context: 
   •   n   : Nat 
   •   m   : Nat 
   •   e   : Equal Nat n m 
   •   app : Equal Nat (Plus n n) (Plus m n) 
   •   app = Equal.apply Nat Nat n m (k =&gt; (Plus k n)) e 
   •   rrt : Equal Nat (Plus n n) (Plus m m) 
   •   rrt = Equal.rewrite Nat n m e (x =&gt; Equal Nat (Plus n n) (Plus m x)) app
</code></pre>
<p>The return value of the <code>Equal.rewrite</code> operation will be the proof we need, so we just return the result directly from the function.</p>
<h4 id="plus_id_exercise"><a class="header" href="#plus_id_exercise">Plus_id_exercise</a></h4>
<p>Prove that:</p>
<pre><code class="language-rust ignore">Plus_id_exercise (n: Nat) (m: Nat) (o: Nat) (e1: Equal Nat n m) (e2: Equal Nat m o) : Equal Nat (Plus n m) (Plus m o)
Plus_id_exercise n m o e1 e2 = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="equalchain-and-equalmirror"><a class="header" href="#equalchain-and-equalmirror">Equal.chain and Equal.mirror</a></h2>
<p>In this section we will not discuss any inherently new tool, but rather some proof utilities to make use of the previous tools easier.</p>
<p>Consider the example:</p>
<pre><code class="language-rust ignore">Example_mirror (a: Nat) (b: Nat) (e: Equal Nat a b) : Equal Nat b a</code></pre>
<p>It seems like a trivial example. If <code>a</code> is equal to <code>b</code>, then <code>b</code> is equal to <code>a</code>, right? Although correct, the type checker of Kind does not recognize this equality, because for it, the order is important. For such situations, we have the function <code>Equal.mirror</code>, which simply swaps the sides of an equality.</p>
<pre><code class="language-rust ignore">Example_mirror (a: Nat) (b: Nat) (e: Equal Nat a b) : Equal Nat b a
Example_mirror a b e = 
   let mir = Equal.mirror e
   mir</code></pre>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: Equal Nat b a 

   • Context: 
   •   a   : Nat 
   •   b   : Nat 
   •   e   : Equal Nat a b
   •   mir : Equal Nat b a 
   •   mir = Equal.mirror Nat a b e
</code></pre>
<p>Although it may not seem very useful at the moment, this operation is very useful for our second utility: <code>Equal.chain</code>. <code>Equal.chain</code> is a specific case of <code>Equal.rewrite</code>, in which you rewrite an entire side of an equality using another.</p>
<pre><code class="language-rust ignore">Example_chain (a: Nat) (b: Nat) (c: Nat) (e1: Equal Nat b (Plus a a)) (e2 : Equal Nat c (Plus a a)) : Equal Nat b c</code></pre>
<p>Since we already know <code>Equal.rewrite</code>, we could use it to solve this theorem, but instead we will use <code>Equal.chain</code>.<code>Equal.chain</code> works by &quot;chaining&quot; two equalities that have the same expression on the right side of the first equality and on the left side of the second, &quot;gluing&quot; these equalities together by the common expression, generating a new equality with the other two expressions (<code>Equal.chain (a = b) (b = c) = (a = c)</code>). For example, in our example, the right side of the two equalities is equal. If we use <code>Equal.mirror</code> on one of them, we can then use <code>Equal.chain</code> on them:</p>
<pre><code class="language-rust ignore">Example_chain (a: Nat) (b: Nat) (c: Nat) (e1: Equal Nat b (Plus a a)) (e2 : Equal Nat c (Plus a a)) : Equal Nat b c
Example_chain a b c e1 e2 =
  let e3 = Equal.mirror e2
  let chn = Equal.chain e1 e3
</code></pre>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: Equal Nat b c

   • Context: 
   •   a   : Nat 
   •   b   : Nat 
   •   c   : Nat 
   •   e1  : Equal Nat b (Plus a a) 
   •   e2  : Equal Nat c (Plus a a) 
   •   e3  : Equal Nat (Plus a a) c
   •   e3  = Equal.mirror Nat c (Plus a a) e2
   •   chn : Equal Nat b c
   •   chn = Equal.chain Nat b (Plus a a) c e1 e3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="more-exercises"><a class="header" href="#more-exercises">More Exercises</a></h2>
<h4 id="boolean_functions"><a class="header" href="#boolean_functions">Boolean_functions</a></h4>
<p>Use the knowledge taught so far to solve the theorem:</p>
<pre><code class="language-rust ignore">Identity_fn_applied_twice (f: Bool -&gt; Bool) (e: (x: Bool) -&gt; Equal Bool (f x) x) (b : Bool) : Equal Bool (f (f b)) b
Identity_fn_applied_twice f e b = ?</code></pre>
<p>Then, solve the <code>negation_fn_applied_twice</code> theorem, which is the same as the previous one, but changing the hypothesis to <code>Equal (f x) (Not x)</code></p>
<h4 id="andb_eq_orb"><a class="header" href="#andb_eq_orb">Andb_eq_orb</a></h4>
<p>Prove the following theorem (Remember that you can prove intermediate theorems separately):</p>
<pre><code class="language-rust ignore">Andb_eq_orb (b: Bool) (c: Bool) (e: Equal Bool (Andb b c) (Orb b c)) : Equal Bool b c
Andb_eq_orb b c prf = ?</code></pre>
<h4 id="binary"><a class="header" href="#binary">Binary</a></h4>
<p>Consider a different representation of natural numbers using a binary system instead of unary. That is, instead of having only zero or one successor of a number, we can have:</p>
<ul>
<li>zero;</li>
<li>twice a number;</li>
<li>twice a number plus 1.</li>
</ul>
<ol>
<li>First, write an inductive definition of this type, calling it <code>Bin</code>. (Remember that, in essence, the definition of <code>Nat</code> as <code>zero</code> or <code>succ n</code> has no intrinsic meaning. It only says that an element of <code>Nat</code> can be a <code>zero</code> or a s<code>ucc n</code> if <code>n</code> is also <code>Nat</code>. The interpretation of this as a system of values 0, 1, 2, etc., comes from how we work with this type <code>Nat</code>. Your definition of <code>Bin</code> ideally will be as simple as well. It will be the functions you make on <code>Bin</code> that will give mathematical sense to it).</li>
<li>Then write an <code>Incr</code> function to increment a <code>Bin</code>, and a <code>Bin_to_nat</code> function to convert from <code>Bin</code> to <code>Nat</code>.</li>
<li>Write five proofs that test your increment and conversion functions. Note that incrementing a binary and then converting it should result in the same result as converting it first and then incrementing the <code>Nat</code>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="induction-proof-by-induction"><a class="header" href="#induction-proof-by-induction">Induction: Proof by Induction</a></h1>
<h2 id="induction"><a class="header" href="#induction">Induction</a></h2>
<p>In this chapter, we will learn about proof by induction. Before we move on to induction itself, we can analyze simple cases where the reflection of the case already proves the theorem.</p>
<pre><code class="language-rust ignore">Problems.t0 (n: Nat) : Equal Nat (Plus Nat.zero n) n</code></pre>
<p>When checking the theorem statement, we receive the following response:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: (Equal Nat n n) 

   • Context: 
   •   n : Nat 

    Problems.t0 n = ?
                    ┬
                    └Here!
</code></pre>
<p>In <em>Problems.t0</em>, Kind automatically reduces the sum of <code>0 + n</code> to <em>n</em>, and we need to prove the equality between <em>n</em> and <em>n</em>. In this case, we simply write <code>Equal.refl</code> and we get the confirmation response:</p>
<pre><code class="language-terminal">All terms check.

</code></pre>
<pre><code class="language-rust ignore">Problems.t1 (n: Nat) : Equal Nat (Plus n Nat.zero) n</code></pre>
<p>After solving the first problem, the next one is very similar, it is the sum of <code>n + 0 = n</code> and this similarity may lead us to believe that invoking the reflection is enough. However, in the first case, Kind automatically reduces and in this one, we get the following response:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: (Equal Nat (Plus n 0n) n) 

   • Context: 
   •   n   : Nat 

   Problems.t1 n = ?
                   ┬
                   └Here!
</code></pre>
<p>In the first case, Kind reduces because <code>zero</code> is on the right side and the <code>Type Checker</code> automatically reduces the sum between <code>0</code> and <code>n</code> to <code>n</code>. However, when the first <em>input</em> is a variable, Kind needs to check for each case and as it is a natural number, there are infinitely many cases to be tested, that is, from zero to infinity.</p>
<p>At first, we may think that there are so many cases and it is impossible to analyze all of them, as there are infinitely many, but soon we realize that it is possible to reduce them to two, one is the number <code>zero</code> and the other is a number that <code>succeeds</code> <code>zero n</code> times after.</p>
<p>Analyzing the case of zero, our goal is to prove that <code>zero</code> is equal to <code>zero</code>:</p>
<pre><code class="language-rust ignore">• Expected: Equal Nat Nat.zero Nat.zero</code></pre>
<p>Now, we just need to give the <code>Equal.refl</code> and the zero case has been proven, we just need to respond to the <code>successor</code> of <code>zero</code>.</p>
<p>Our goal is to prove that for every number <code>n</code>, adding <code>0</code> will result in <code>n</code>, but we already have a new tool that helps us in this proof and it is the proof for the <code>zero</code> case, we just need to reduce <code>n</code> until the only thing needed is reflection, and we can do this by recursion and to do that we define the new <code>n</code> as its predecessor. In Kind, we can simply do this by defining the current <code>n</code> as the successor of the next n and recursively calling the function for <code>n</code>. This is done as follows:</p>
<pre><code class="language-rust ignore">Problems.t1 (Nat.succ n)   = ?</code></pre>
<p>and our new goal is to prove that the successor of the sum between <code>n</code> and <code>0</code> is equal to the successor of <code>n</code>.</p>
<pre><code class="language-rust ignore">- Expected: Equal Nat (Nat.succ (Plus n Nat.zero)) (Nat.succ n)</code></pre>
<p>To work with induction in this recursion, we must define a variable for the original case of <code>n</code>.</p>
<pre><code class="language-rust ignore">Problems.t1 (n: Nat)       : Equal (Plus n Nat.zero) n
Problems.t1 Nat.zero       = Equal.refl
Problems.t1 (Nat.succ n)   =
    let ind = Problems.t1 n
    ?</code></pre>
<p>When we give the <code>Type Check</code>, we get the following response:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: (Equal Nat (Nat.succ (Plus n 0n)) (Nat.succ n)) 

   • Context: 
   •   n   : Nat 
   •   ind : (Equal Nat (Plus n 0n) n) 
   •   ind = (Problems.t1 n) 

   let ind = Problems.t1 n
     ?
     ┬
     └Here!
</code></pre>
<p>When analyzing our goal and induction, we realize that the only difference between the goal and our variable <code>ind</code> is the <code>Nat.succ</code>. Therefore, we just need to increment the <code>ind</code> variable with <code>Nat.succ</code>. To do this, we create a new variable and use a <code>lambda</code> function:</p>
<pre><code class="language-rust ignore">let app = Equal.apply (x =&gt; (Nat.succ x)) ind</code></pre>
<p>In the above case, we call the <code>Equal.apply</code> function to apply our <code>lambda</code> function to <code>ind</code>. The <code>x =&gt; (Nat.succ x)</code> function serves to add <code>Nat.succ</code> to every element received in the variable. Since our <code>ind</code> variable is a function that takes another variable <code>n</code>, our <code>lambda</code> function increments <code>n</code> with <code>Nat.succ</code>, which returns exactly our goal:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: (Equal Nat (Nat.succ (Plus n 0n)) (Nat.succ n)) 

   • Context: 
   •   n   : Nat 
   •   ind : (Equal Nat (Plus n 0n) n) 
   •   ind = (Problems.t1 n) 
   •   app : (Equal Nat (Nat.succ (Plus n 0n)) (Nat.succ n)) 
   •   app = (Equal.apply Nat Nat (Plus n 0n) n (x =&gt; (Nat.succ x)) ind)  

   let app = Equal.apply (x =&gt; (Nat.succ x)) ind
      ?
      ┬
      └Here!
</code></pre>
<p>We can see that the <code>app</code> is exactly the same as the <code>Expected</code>, which is our goal, and we just need to return it, the app, for the <code>Type Check</code> to validate our proof:</p>
<pre><code class="language-terminal">All terms check.

</code></pre>
<p>There are cases where induction is even simpler - all we need to do is understand what is happening. Let's say we want to prove that a number <code>n</code> minus itself is always equal to <code>zero</code>, regardless of what that number is. How would we do it?
First, we check the case where n is <code>zero</code>, and it is a true equality - <code>zero</code> minus <code>zero</code> is equal to <code>zero</code>. Then, we induct the case to the case of <code>zero</code>, which we know is true. Seems complicated? It's not - it's ridiculously simple. Let's see how it looks in <code>Kind</code>:</p>
<pre><code class="language-rs ignore">Minus_diag (n: Nat)     : Equal Nat (Minus  n n) Nat.zero
Minus_diag Nat.zero     = Equal.refl
Minus_diag (Nat.succ n) = Minus_diag n
</code></pre>
<p>Notice, this is a simple induction - we say the proof holds for the number and its predecessor, and through recursion, for all predecessors up to <code>zero</code>, which we verified to be true.
In other words, we prove, in just three lines, that a natural number minus itself will always result in <code>zero</code>, regardless of what that number is.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<p>Prove the following using induction. You may need previously proven results.</p>
<pre><code class="language-rust ignore">Mult_0_r (n: Nat) : Equal Nat (Mult n Nat.zero) Nat.zero
Mult_0_r n = ?

Plus_n_sm (n: Nat) (m: Nat) : Equal Nat (Nat.succ (Plus n m)) (Plus n (Nat.succ m))
Plus_n_sm n m = ?

Plus_comm (n: Nat) (m: Nat) : Equal Nat (Plus n m) (Plus m n)
Plus_comm n m = ?

Add_0_r (n: Nat) : Equal Nat (Plus n Nat.zero) n
Add_0_r n = ?

Plus_assoc (n: Nat) (m: Nat) (p: Nat) : Equal Nat (Plus n (Plus m p)) (Plus (Plus n m) p)
Plus_assoc n m p = ?</code></pre>
<p>Consider the following function that doubles its input.</p>
<pre><code class="language-rust ignore">Double (n: Nat)     : Nat
Double Nat.zero     = Nat.zero
Double (Nat.succ n) = Nat.succ (Nat.succ (Double n))</code></pre>
<p>Use induction to prove the following theorems about <code>Double</code>:</p>
<pre><code class="language-rust ignore">Double_plus (n: Nat) : Equal Nat (Double n) (Plus n n)
Double_plus n = ?</code></pre>
<p>Some theorems require analyzing the best way to prove them, for example, to prove that a number is even, we could prove it for its successor, but that would require us to prove it for the successor of the successor, making the proof of <code>Evenb</code> more difficult by induction. So it's important to realize when it is necessary and when it is not.</p>
<pre><code class="language-rust ignore">Evenb_s (n: Nat) : Equal Bool (Evenb (Nat.succ n)) (Notb  (Evenb n))
Evenb_s n = ?</code></pre>
<h2 id="another-case"><a class="header" href="#another-case">Another case</a></h2>
<p>Let's verify if the equality <code>n +(m + 1) = 1 + (n + m)</code> is true.</p>
<p>First, our problem:</p>
<pre><code class="language-rust ignore">Problems.t2 (n: Nat) (m: Nat) : Equal Nat (Plus n (Nat.succ m)) (Nat.succ(Plus n m))</code></pre>
<p>We verify the base case, when <code>n</code> is zero:</p>
<pre><code class="language-rust ignore">Problems.t2 Nat.zero m = Equal.refl</code></pre>
<p>and move on to the next case</p>
<pre><code class="language-rust ignore">Problems.t2 (Nat.succ n) m = ?</code></pre>
<p>and our current goal becomes:</p>
<pre><code class="language-rust ignore">• Expected: Equal Nat (Nat.succ (Plus n (Nat.succ m))) (Nat.succ (Nat.succ (Plus n m)))</code></pre>
<p>Translating, the successor of the addition of <code>n</code> and the successor of <code>m</code> is equal to the successor of the successor of the addition of <code>n</code> and <code>m</code>. To solve this problem, we will invoke induction:</p>
<pre><code class="language-rust ignore">let ind = Problems.t2 n m</code></pre>
<p>and our current goal is to prove that:</p>
<pre><code class="language-rust ignore">• Expected: Equal Nat (Nat.succ (Plus n (Nat.succ m))) (Nat.succ (Nat.succ (Plus n m)))</code></pre>
<p>Again, translating, that the <code>successor</code> of the addition of <code>n</code> and the <code>successor</code> of <code>m</code> is equal to the <code>successor</code> of the <code>successor</code> of the addition of <code>n</code> and <code>m</code>.</p>
<p>But now we have a very useful tool, our variable ind which is:</p>
<pre><code class="language-rust ignore">Equal Nat (Plus n (Nat.succ m)) (Nat.succ (Plus n m))</code></pre>
<p>Now, analyzing our goal and our variable ind, we can see that it is enough to add <code>Nat.succ</code> to both sides of the induction, and it will be exactly the same as our goal. To do this, we will use a <code>lambda</code> function:</p>
<pre><code class="language-rust ignore">let app = Equal.apply (x =&gt; (Nat.succ x)) ind</code></pre>
<p>And our variable <code>app</code> will return our goal:</p>
<pre><code class="language-rust ignore">Equal Nat (Nat.succ (Plus n (Nat.succ m))) (Nat.succ (Nat.succ (Plus n m)))</code></pre>
<p>Just return app and Kind will give us the coveted <code>All terms check</code>.</p>
<h1 id="using-other-theorems"><a class="header" href="#using-other-theorems">Using other theorems</a></h1>
<p>In Kind, as in informal mathematics, large proofs are often divided into a sequence of theorems, with later proofs referring to earlier theorems. But sometimes a proof will require some varied fact that is too trivial and of too little general interest to give it its own higher-level name. In these cases, it is convenient to be able to simply state and prove the necessary &quot;sub-theorem&quot; exactly at the point where it is used.</p>
<p>Let's analyze the following addition commutation theorem:</p>
<pre><code class="language-rust ignore">Problems.t3 (n: Nat) (m: Nat) : Equal Nat (Plus n  m) (Plus m n)</code></pre>
<p>In the first case, for <code>n</code> and <code>m</code> equal to zero we have a reflection:</p>
<pre><code class="language-rust ignore">Problems.t3 Nat.zero Nat.zero = Equal.refl</code></pre>
<p>So we move on to the next case:</p>
<pre><code class="language-rust ignore">Problems.t3 (Nat.succ n) m = ?</code></pre>
<p>And here it seems that we have a new problem:</p>
<pre><code class="language-rust ignore">Expected: Equal Nat (Nat.succ (Plus n m)) (Plus m (Nat.succ n))
</code></pre>
<p>Analyzing the problem, we realize that there is a theorem already proven within it, that the <code>successor</code> of the addition of two numbers is equal to the addition of one number with its <code>successor</code>, so we can use that to our advantage.</p>
<p>We will start by applying a <code>Nat.succ</code> to our original problem:</p>
<pre><code class="language-rust ignore">let ind_a = Equal.apply (x =&gt; (Nat.succ x)) (Problems.t3 n m )</code></pre>
<p>Then we invoke our already solved problem, <code>Problems.t2</code>:</p>
<pre><code class="language-rust ignore">let ind_b = Problems.t2 m n</code></pre>
<p>When we give the <code>Type Check</code>, the terminal returns:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: (Equal Nat (Nat.succ (Plus n m)) (Plus m (Nat.succ n))) 

   • Context: 
   •   n     : Nat 
   •   m     : Nat 
   •   ind_a : (Equal Nat (Nat.succ (Plus n m)) (Nat.succ (Plus m n))) 
   •   ind_a = (Equal.apply Nat Nat (Plus n m) (Plus m n) (x =&gt; (Nat.succ x)) (Problems.t3 n m)) 
   •   ind_b : (Equal Nat (Plus m (Nat.succ n)) (Nat.succ (Plus m n))) 
   •   ind_b = (Problems.t2 m n) 
 
   let ind_b = Problems.t2 m n
     ?
     ┬
     └Here!
</code></pre>
<p>Now we can see that the first part of <code>ind_a</code> is the inverse of the first part of our goal and the first part of <code>ind_b</code> is equal to the second part of the goal, we just need to organize and join the necessary parts. To do this, we will use <code>Equal.mirror</code> and <code>Equal.chain</code>.</p>
<pre><code class="language-rust ignore">let ind_c = Equal.chain ind_b Equal.mirror ind_a</code></pre>
<p>And <code>ind_c</code> returns a value similar to the desired one:</p>
<pre><code class="language-rust ignore">• Expected: Equal Nat (Nat.succ (Plus n m)) (Plus m (Nat.succ n))
•   ind_c : Equal Nat (Plus m (Nat.succ n)) (Nat.succ (Plus n m))</code></pre>
<p>We can see that one is the other mirrored, to make them equal, we will use <code>Equal.mirror</code> again:</p>
<pre><code class="language-rust ignore">let app = Equal.mirror ind_c</code></pre>
<p>When we call <code>app</code>, the <code>Type Check</code> returns the message <code>All terms checked</code> and thus we prove, through induction and using another proof, the commutation of addition, that the sum of <code>n</code> and <code>m</code> is equal to the sum of <code>m</code> and <code>n</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="more-exercises-1"><a class="header" href="#more-exercises-1">More exercises</a></h2>
<p>You can use <code>rewrite</code> or <code>chain</code> in this proof, choose whichever you find easiest.</p>
<pre><code class="language-rust ignore">Plus_swap (n: Nat) (m: Nat) (p: Nat) : Equal Nat (Plus n (Plus m p)) (Plus m (Plus n p))
Plus_swap n m p = ?</code></pre>
<p>Now prove the commutativity of multiplication. (You will probably need to define and prove a separate auxiliary theorem to be used in the proof of this. You may find <code>Plus_swap</code> useful.)</p>
<pre><code class="language-rust ignore">Mult_comm (n: Nat) (m: Nat) : Equal Nat (Mult n m) (Mult m n)
Mult_comm n m = ?</code></pre>
<p>Take a piece of paper. For each of the following theorems, first think whether (a) it can be proven using just simplification and rewriting, (b) also requires case analysis (destruction), or (c) also requires induction. Write down your prediction.</p>
<p>Then, fill in the proof. (There is no need to submit your piece of paper; this is just to encourage you to reflect before hacking!)</p>
<pre><code class="language-rust ignore">Lte_refl (n: Nat) : Equal Bool Bool.true (Lte n n)
Lte_refl n = ?

Zero_nbeq_s (n: Nat) : Equal Bool (Eql (Nat.zero) (Nat.succ n)) Bool.false
Zero_nbeq_s n = ?

And_false_r (b: Bool) : Equal Bool (Andb b Bool.false) Bool.false
And_false b = ?

S_nbeq_0 (n: Nat) : Equal Bool (Eql (Nat.succ n) Nat.zero) Bool.false

Mult_1_l (n: Nat) : Equal Nat (Mult (Nat.succ Nat.zero) n) n
Mult_1_l n = ?

All3_spec (b: Bool) (c: Bool) : Equal Bool (Orb (Orb (Andb b c) (Notb  b)) (Notb  c)) Bool.true
All3_spec b c = ?

Mult_plus_distr_r (n: Nat) (m: Nat) (p: Nat) : Equal Nat (Mult (Plus n m) p) (Plus (Mult n p) (Mult m p))
Mult_plus_distr_r n m p = ?

Mult_assoc (n: Nat) (m: Nat) (p: Nat) : Equal Nat (Mult (Mult m p)) (Mult (Mult n m) p)
Mult_assoc n m p = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h1>
<h2 id="lists--working-with-structured-data"><a class="header" href="#lists--working-with-structured-data">Lists : Working with Structured Data</a></h2>
<p>From now on, we will see structured data, especially lists and pairs, which can contain elements of various types. In the type definition, we will already show them with <code>polymorphic</code> types, but don't worry, we will talk about it in the next chapter. For now, let's just ignore the type and follow the explanation. It will make more sense as we progress in our study.</p>
<h3 id="data-structures-1"><a class="header" href="#data-structures-1">Data Structures</a></h3>
<p>In an inductive type definition, each constructor can receive any number of arguments -- none like <code>Bool</code>, <code>Empty</code>, or one like <code>Nat</code> -- and we have the <code>Pair</code> that receives two arguments (which can even be other two pairs) and returns a type:</p>
<pre><code class="language-rust ignore">record Pair (a) (b) </code></pre>
<p>The two received arguments are transformed into the first component, <code>fst</code>, and the second, <code>snd</code>.</p>
<pre><code class="language-rust ignore">record Pair (a) (b) {
  fst : a
  snd : b
} </code></pre>
<p>The way to construct a pair of <code>Nat</code> is as follows:</p>
<pre><code class="language-rust ignore">Pair.new Nat Nat a b  : (Pair a b)</code></pre>
<p>Here are two simple functions to extract the first and second components of a pair. The definitions also illustrate how to pattern match on two constructor arguments.</p>
<pre><code class="language-rust ignore">Fst (pair: Pair Nat Nat) : Nat
Fst (Pair.new Nat Nat fst snd) = fst</code></pre>
<pre><code class="language-bash">Example 1: (Fst Nat (List Nat) (Pair 2n [1n,2n,3n])) -&gt;  2n
</code></pre>
<pre><code class="language-rust ignore">Snd (pair: Pair Nat Nat) : Nat
Snd (Pair.new Nat Nat fst snd) = snd</code></pre>
<pre><code class="language-bash">Example 2: (Snd Nat (List Nat) (Pair 2n [1n,2n,3n])) -&gt; [1n,2n,3n]
</code></pre>
<h4 id="some-proofs"><a class="header" href="#some-proofs">Some proofs</a></h4>
<p>Let's try to prove some simple facts about pairs. If we declare things in a particular (and slightly peculiar) way, we can complete proofs with just reflexivity:</p>
<pre><code class="language-rust ignore">Surjective_pairing (p: Pair Nat Nat) : Equal (Pair Nat Nat) p (Pair.new (Fst p) (Snd p))
Surjective_pairing (Pair.new Nat Nat fst snd) = Equal.refl</code></pre>
<p>But <code>Equal.refl</code> is not enough if the statement is:</p>
<pre><code class="language-rust ignore">Surjective_pairing (Pair.new Nat Nat fst snd) = Equal.refl</code></pre>
<p>Since Kind expects</p>
<pre><code class="language-rust ignore">Equal (Pair Nat Nat) p (Pair.new (Fst p) (Snd p))</code></pre>
<p>And received</p>
<pre><code class="language-rust ignore">Equal p p</code></pre>
<p>We must &quot;expose&quot; the internal structure of the <code>pair</code> so that the <code>Type Checker</code> can verify whether <code>p</code> is really equal to <code>Pair.new (Fst p) (Snd p)</code>.</p>
<h4 id="snd_fst_is_swap"><a class="header" href="#snd_fst_is_swap">Snd_fst_is_swap</a></h4>
<pre><code class="language-rust ignore">Snd_fst_is_swap (p: Pair Nat Nat ) : Equal (Pair Nat Nat) (Pair.swap Nat Nat (Pair.swap Nat Nat p) p)
Snd_fst_is_swap (Pair.new Nat Nat fst snd) = ? </code></pre>
<h4 id="fst_swap_is_snd"><a class="header" href="#fst_swap_is_snd">Fst_swap_is_snd</a></h4>
<pre><code class="language-rust ignore">Fst_swap_is_inverse (p: Pair Nat Nat) (a: Nat) (b: Nat) : Equal (Pair Nat Nat) (Pair.swap Nat Nat (Pair.new a b) (Pair.new b a))
Fst_swap_is_inverse p a b = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="number-lists"><a class="header" href="#number-lists">Number Lists</a></h2>
<p>Generalizing the definition of pairs, we can describe the type of number lists as follows: &quot;A list is either the empty list or a set of one element and another list&quot;, this type is not composed of a <code>head</code> and a <code>tail</code>.</p>
<pre><code class="language-rust ignore">type List (t) {
  nil
  cons (head: t) (tail: List t)
}</code></pre>
<p>As we are dealing with only one type, it is interesting to rewrite the list type for a defined one, the chosen one was <code>Nat</code>:</p>
<pre><code class="language-rust ignore">type NatList {
  nil
  cons (head: Nat) (tail: NatList)
}</code></pre>
<p>or</p>
<pre><code class="language-rust ignore">type NatList {
   List Nat
}</code></pre>
<p>We can see that in both notations, there is a <code>head</code> and a <code>tail</code>, with the
<code>head</code> receiving an element of type <code>Nat</code> and the <code>tail</code> receiving a list of type <code>Nat</code>.</p>
<p>For example, a list of three natural numbers 1n, 2n, and 3n would be written as follows:</p>
<p><code>[1n, 2n, 3n]</code></p>
<p>However, the Kind reads it differently:</p>
<p><code>[1n, [2n, 3n]]</code></p>
<p>where <code>1n</code> is the head and <code>[2n, 3n]</code> is the tail. Likewise, looking at a
list of 4 elements <code>[1n, 2n, 3n, 4n]</code>, we now see it as follows:</p>
<p><code>[1n, [2n, [3n, 4n]]]</code></p>
<p>The list has the <code>head</code> <code>1n</code> and the <code>tail</code> <code>[2n, [3n, 4n]]</code>, which, in turn, has the
<code>head</code> <code>2n</code> and the <code>tail</code> <code>[3n, 4n]</code> which also has its <code>head</code> <code>3n</code> and its <code>tail</code> <code>4n</code>.</p>
<p>It may seem scary, but it's a friendly monster:</p>
<p><img src="Book/chapter_04/../../Imgs/listmonster.png" alt="img" /></p>
<p>[fonte da imagem: http://learnyouahaskell.com/starting-out]</p>
<h3 id="repeat"><a class="header" href="#repeat">Repeat</a></h3>
<p>The function <code>repeat</code> takes a number <code>n</code> and a value, returning a list of size <code>n</code> where all elements are the declared value.</p>
<pre><code class="language-rust ignore">// Exemplo: (Repeat 3 Bool.true) -&gt; [True, True, True]
Repeat (x: Nat) (count: Nat) : List Nat
Repeat x Nat.zero            = [] 
Repeat x (Nat.succ count)    = List.cons Nat x (Repeat count x)</code></pre>
<h3 id="length"><a class="header" href="#length">Length</a></h3>
<p>The function <code>length</code> calculates the size of the list.</p>
<pre><code class="language-rust ignore">// Exemplo: (Length [1,2,3]) -&gt; 3
Length (xs: List Nat) : Nat
Length List.nil              = 0n
Length (List.cons head tail) = (Nat.succ (Length tail))</code></pre>
<h3 id="concat"><a class="header" href="#concat">Concat</a></h3>
<p>The function <code>concat</code> concatenates (appends) two lists.</p>
<pre><code class="language-rust ignore">Concat (xs: List Nat) (ys: List Nat) : List Nat
Concat (List.nil)            ys = ys
Concat (List.cons head tail) ys = List.cons Nat head (Concat tail ys)</code></pre>
<h3 id="head-and-tail"><a class="header" href="#head-and-tail">Head and Tail</a></h3>
<p>The head function returns the first element (the &quot;head&quot;) of the list, while tail returns everything except the first element (the &quot;tail&quot;). Of course, an empty list has no first element, so we must handle this case with a <code>Maybe</code> type, receiving a <code>Maybe.none</code> if the list is empty or a <code>Maybe.some</code> if it has a value.</p>
<pre><code class="language-rust ignore">// Exemplo: (Head 0n [1n,2n,3n]) -&gt; 1n
Head (default: Nat) (xs: List Nat) :  Nat
Head default (List.nil)            = default
Head default (List.cons head tail) = head</code></pre>
<pre><code class="language-rust ignore">// Exemplo: (Tail Nat [1,2,3]) -&gt; [2,3]
Tail (xs: List Nat)        : List Nat
Tail (List.nil)            = []
Tail (List.cons head tail) = tail</code></pre>
<pre><code class="language-rust ignore">Test_head1 : Equal Nat (Head 0n [1n,2n,3n]) 1n
Test_head1 = Equal.refl</code></pre>
<pre><code class="language-rust ignore">Test_head2 : Equal Nat (Head 0n List.nil) 0n
Test_head2 = Equal.refl</code></pre>
<pre><code class="language-rust ignore">Test_head3 : Equal (List Nat) (Tail [1n, 2n, 3n]) [2n, 3n]
Test_head3 = Equal.refl</code></pre>
<h3 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h3>
<h4 id="list_funs"><a class="header" href="#list_funs">List_funs</a></h4>
<p>Complete the definitions of Nonzeros, Oddmembers, and Countoddmembers below. Take a look at the tests to understand what these functions should do.</p>
<pre><code class="language-rust ignore">Nonzeros (xs: List Nat) : List Nat
Nonzeros xs = ?</code></pre>
<pre><code class="language-rust ignore">Test_nonzeros : Equal (List Nat) (Nonzeros [0n,1n,0n,2n,3n,0n,0n]) [1n,2n,3n]
Test_nonzeros = ?</code></pre>
<pre><code class="language-rust ignore">Oddmembers (xs: List Nat) : List Nat
Oddmembers xs = ?</code></pre>
<pre><code class="language-rust ignore">Test_oddmembers : Equal (List Nat) (Oddmembers [0n,1n,0n,2n,3n,0n,0n]) [1n,3n]
Test_oddmembers = ?</code></pre>
<pre><code class="language-rust ignore">CountOddMembers (xs: List Nat)  : Nat
CountOddMembers xs = ?</code></pre>
<pre><code class="language-rust ignore">Test_countoddmembers1 : Equal Nat (CountOddMembers [1n,0n,3n,1n,4n,5n]) 4n
Test_countoddmembers1 = ?</code></pre>
<h4 id="alternate"><a class="header" href="#alternate">Alternate</a></h4>
<p>Complete the definition of alternate, which <code>compacts</code> two lists into one, alternating between elements taken from the first list and elements from the second. See the tests below for more specific examples.</p>
<pre><code class="language-rust ignore">Alternate (xs: List Nat) (ys: List Nat) : List Nat
Alternate xs ys = ?</code></pre>
<pre><code class="language-rust ignore">Test_alternate1 : Equal (List Nat) (Alternate [1n,2n,3n] [4n,5n,6n]) [1n,4n,2n,5n,3n,6n]
Test_alternate1 = ?</code></pre>
<pre><code class="language-rust ignore">Test_alternate2 : Equal (List Nat) (Alternate [1n] [4n,5n,6n]) [1n,4n,5n,6n]
Test_alternate2 = ?</code></pre>
<pre><code class="language-rust ignore">Test_alternate3 : Equal (List Nat) (Alternate  [1n,2n,3n] [4n]) [1n,4n,2n,3n]
Test_alternate3 = ? </code></pre>
<pre><code class="language-rust ignore">Test_alternate4 : Equal (List Nat) (Alternate [] [20n,30n]) [20n,30n]
Test_alternate4 = ?</code></pre>
<h4 id="functions-1"><a class="header" href="#functions-1">Functions</a></h4>
<p>Complete the following definitions for the count, sum, add, and member functions of natural number lists.</p>
<pre><code class="language-rust ignore">Count (v: Nat) (xs: List Nat) : Nat
Count v xs = ?</code></pre>
<pre><code class="language-rust ignore">Test_count1 : Equal Nat (Count 1n [1n,2n,3n,1n,4n,1n]) 3n
Test_count1 = ?</code></pre>
<pre><code class="language-rust ignore">Test_count2 : Equal Nat (Count 6n [1n,2n,3n,1n,4n,1n]) 0n
Test_count2 = ?</code></pre>
<pre><code class="language-rust ignore">Sum (xs: List Nat) (ys: List Nat) : List Nat
Sum xs ys = ?</code></pre>
<pre><code class="language-rust ignore">Test_sum1 : Equal Nat (Count 1n (Sum [1n,2n,3n] [1n,4n,1n])) 3n
Test_sum1 = ?</code></pre>
<pre><code class="language-rust ignore">Add (n: Nat) (xs: List Nat) : List Nat
Add n xs = ?</code></pre>
<pre><code class="language-rust ignore">Test_add1 : Equal Nat (Count 1n (Add 1n [1n,4n,1n])) 3n
Test_add1 = ?</code></pre>
<pre><code class="language-rust ignore">Test_add2 : Equal Nat (Count 5n (Add 1n [1n,4n,1n])) 0n
Test_add2 = ?</code></pre>
<pre><code class="language-rust ignore">Member (v: Nat) (xs: List Nat) : Bool
Member v xs = ?</code></pre>
<pre><code class="language-rust ignore">Test_member1 : Equal Bool (Member 1n [1n,4n,1n]) Bool.true
Test_member1 = ?</code></pre>
<pre><code class="language-rust ignore">Test_member2 : Equal Bool (Member 2n [1n,4n,1n]) Bool.false
Test_member2 = ?</code></pre>
<h4 id="more_functions"><a class="header" href="#more_functions">More_functions</a></h4>
<p>Here are some more functions of <code>List Nat</code> for you to practice with. When remove_one is applied to a list without the number to be removed, it should return the same unchanged list.</p>
<pre><code class="language-rust ignore">Remove_one (v: Nat) (xs: List Nat) : List Nat
Remove_one v xs = ?</code></pre>
<pre><code class="language-rust ignore">Test_remove_one1 : Equal Nat (Count 5n (Remove_one 5n [2n,1n,5n,4n,1n])) 0n
Test_remove_one1 = ?</code></pre>
<pre><code class="language-rust ignore">Test_remove_one2 : Equal Nat (Count 5n (Remove_one 5n [2n,1n,4n,1n])) 0n
Test_remove_one2 = ?</code></pre>
<pre><code class="language-rust ignore">Test_remove_one3 : Equal Nat (Count 4n (Remove_one 5n [2n,1n,5n,4n,1n,4n])) 2n
Test_remove_one3 = ?</code></pre>
<pre><code class="language-rust ignore">Test_remove_one4 : Equal Nat (Count 5n (Remove_one 5n [2n,1n,5n,4n,5n,1n,4n])) 1n
Test_remove_one4 = ?</code></pre>
<pre><code class="language-rust ignore">Remove_all (v: Nat) (xs: List Nat) : List Nat
Remove_all v xs = ?</code></pre>
<pre><code class="language-rust ignore">Test_remove_all1  : Equal Nat (Count 5n (Remove_all 5n [2n,1n,5n,4n,1n])) 0n
Test_remove_all1  = ?</code></pre>
<pre><code class="language-rust ignore">Test_remove_all2  : Equal Nat (Count 5n (Remove_all 5n [2n,1n,4n,1n])) 0n
Test_remove_all2  = ?</code></pre>
<pre><code class="language-rust ignore">Test_remove_all3  : Equal Nat (Count 4n (Remove_all 5n [2n,1n,5n,4n,1n,4n])) 2n
Test_remove_all3  = ?</code></pre>
<pre><code class="language-rust ignore">Test_remove_all4  : Equal Nat (Count 5n (Remove_all 5n [2n,1n,5n,4n,5n,1n,4n,5n,1n,4n])) 0n
Test_remove_all4  = ?</code></pre>
<pre><code class="language-rust ignore">Subset (xs: List Nat) (ys: List Nat)  : Bool
Subset xs ys = ?</code></pre>
<pre><code class="language-rust ignore">Test_subset1 : Equal Bool (Subset [1n,2n] [2n,1n,4n,1n]) Bool.true
Test_subset1 = ?</code></pre>
<pre><code class="language-rust ignore">Test_subset2 : Equal Bool (Subset [1n,2n,2n] [2n,1n,4n,1n]) Bool.false
Test_subset2 = ?</code></pre>
<h4 id="theorem"><a class="header" href="#theorem">Theorem</a></h4>
<p>Write down an interesting theorem involving the count and add functions and prove it. Note that, as this problem is somewhat open-ended, you may come up with a theorem that is true but whose proof requires techniques you have not yet learned. Feel free to ask for help if you get stuck!</p>
<pre><code class="language-rust ignore">Theorem : ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="reasoning-about-lists"><a class="header" href="#reasoning-about-lists">Reasoning about Lists</a></h2>
<p>Just like numbers, simple facts about list processing functions can sometimes be entirely proven by simplification. For example, the simplification performed by <code>Equal.refl</code> is sufficient for this theorem...</p>
<pre><code class="language-rust ignore">`List.nil`_app (xs: List Nat) : Equal (Concat (List.nil Nat) xs) xs
`List.nil`_app xs = Equal.refl</code></pre>
<p>...this is because the Type &quot;sees&quot; the <code>List.nil</code> and automatically reduces equality just as it does with natural numbers and <code>Nat.zero</code>.</p>
<p>Furthermore, as with numbers, it is sometimes useful to perform a case analysis on the possible forms (empty or non-empty) of an unknown list.</p>
<pre><code class="language-rust ignore">Tl_length_pred (xs: List Nat)         : Equal Nat (Pred (Length xs)) (Length (Tail xs))
Tl_length_pred List.nil               = Equal.refl
Tl_length_pred (List.cons head tail)  = Equal.refl</code></pre>
<p>If the user does not open the cases and uses <code>Equal.refl</code> directly, the Type returns a type error:</p>
<pre><code class="language-diff">- ERROR  Type mismatch

   • Got      : Equal Nat (Nat.pred (Length xs)) (Nat.pred (Length xs)) 
   • Expected : Equal Nat (Nat.pred (Length xs)) (Length (Tail xs)) 

   • Context: 
   •   xs : (List Nat) 

   Tl_length_pred xs = Equal.refl
                       ┬─────────
                       └Here!
</code></pre>
<p>Similarly, some theorems require induction for their proofs.</p>
<ul>
<li><em>Micro-Sermon. Simply reading example proof scripts won't get you very far! It's important to work through the details of each one, using the Type and thinking about what each step achieves. Otherwise, it's more or less guaranteed that the exercises won't make sense when you get to them</em>. ( ಠ ʖ̯ ಠ)</li>
</ul>
<h3 id="induction-on-lists"><a class="header" href="#induction-on-lists">Induction on Lists</a></h3>
<p>Proofs by induction on data types like <code>List</code> are a bit less familiar than standard natural number induction, but the idea is equally simple. Each data declaration defines a set of data values that can be constructed using the declared constructors: a boolean can be True or False; a number can be Zero or Succ applied to another number; a list of naturals can be <code>List.nil</code> or <code>List.cons</code> applied to a number and a list.</p>
<p>Moreover, the applications of the declared constructors to each other are the only possible forms that elements of an inductively defined set can have, and this fact directly gives rise to a way of reasoning about inductively defined sets: a number is Zero or else it is Succ applied to a smaller number; a list is <code>List.nil</code> or else it is a <code>List.cons</code> applied to some number and a smaller list, etc. So, if we have in mind some proposition <code>p</code> that mentions a list<code>l</code> and we want to argue that <code>p</code> holds for all lists, we can reason as follows:</p>
<ul>
<li>First, show that <code>p</code> is true for <code>l</code> when <code>l</code> is <code>List.nil</code>.</li>
<li>Then show that <code>p</code> is true for <code>l</code> when <code>l</code> is <code>List.cons n l</code> for some number <code>n</code> and some smaller list <code>l</code>, assuming that <code>p</code> is true for <code>l</code>.</li>
</ul>
<p>Since larger lists can only be constructed from smaller lists, eventually reaching <code>List.nil</code>, these two arguments together establish the truth of <code>p</code> for all lists <code>l</code>. Here's a concrete example:</p>
<pre><code class="language-rust ignore">Concat_assoc (xs: List Nat) (ys: List Nat) (zs: List Nat) : Equal (Concat (Concat xs ys) zs) (Concat xs (Concat ys zs))
Concat_assoc List.nil                               ys zs = Equal.refl
Concat_assoc (List.cons Nat xs.head xs.tail)        ys zs = 
  let ind = Concat_assoc xs.tail ys zs
  let app = Equal.apply (x =&gt; (List.cons xs.head x)) ind
  app</code></pre>
<p>We are given three lists <code>xs</code>, <code>ys</code>, and <code>zs</code> and we check if concatenating <code>xs</code> and <code>ys</code> with <code>zs</code> is equal to concatenating <code>xs</code> with the concatenation of <code>ys</code> and <code>zs</code>.</p>
<p>For this, we check for the case where <code>xs</code> is an empty list, then we receive a reflection that the concatenation is between <code>ys</code> and <code>zs</code>, and it suffices to give an <code>Equal.refl</code>.</p>
<p>Next, we &quot;open up&quot; <code>xs</code> to obtain <code>xs.tail</code> for our induction, and we receive as the objective:</p>
<pre><code> • Expected: Equal (List Nat) (List.cons Nat xs.head (Concat (Concat xs.tail ys) zs)) (List.cons Nat xs.head (Concat xs.tail (Concat ys zs))) 
</code></pre>
<p>and our <code>ind</code> variable is:</p>
<pre><code> • ind: Equal (List Nat) (Concat (Concat xs.tail ys) zs) (Concat xs.tail (Concat ys zs))
</code></pre>
<p>it is sufficient to apply a L<code>ist.cons xs.head</code> on both sides of the equality to obtain the final objective, which is what we do in <code>app</code>:</p>
<pre><code> • app : Equal (List Nat) (List.cons Nat xs.head (Concat (Concat xs.tail ys) zs)) (List.cons Nat xs.head (Concat xs.tail (Concat ys zs)))
</code></pre>
<p><em>NOTE</em></p>
<p>e Type Check returns types <code>t2</code>, <code>t3</code>, and others generated in the same style, which we can ignore and even delete when comparing the return of variables, as we see in the following case</p>
<pre><code> • Expected: Equal (List Nat) (List.cons Nat xs.head (Concat (Concat xs.tail ys) zs)) (List.cons Nat xs.head (Concat xs.tail (Concat ys zs))) 
 •   app   : Equal (List Nat) (List.cons Nat xs.head (Concat (Concat xs.tail ys) zs)) (List.cons Nat xs.head (Concat xs.tail (Concat ys zs)))
</code></pre>
<!-- e apagando os tipos gerados e os `holes`:

```
- Expected: Equal (List) (List.cons xs.head (Concat (Concat xs.tail ys) zs)) (List.cons xs.head (Concat xs.tail (Concat ys zs))))
- app : Equal (List) (List.cons xs.head (Concat (Concat xs.tail ys) zs)) (List.cons xs.head (Concat xs.tail (Concat ys zs))))
``` -->
<!-- TODO holes -->
<p>This way it's easier to see that <code>app</code> and <code>Expected</code> are identical, so there's no need to be alarmed when seeing these generated types.</p>
<h4 id="reversing-a-list"><a class="header" href="#reversing-a-list">Reversing a list</a></h4>
<p>For a slightly more complicated example of inductive proof about lists, suppose we use <code>Concat</code> to define a list reversal function <code>Rev</code>:</p>
<pre><code class="language-rust ignore">Rev (xs: List Nat)        : List Nat
Rev List.nil              = List.nil Nat
Rev (List.cons head tail) = Concat (Rev tail) [head]

Test_rev1 : Equal (List Nat) (Rev [1n,2n,3n]) [3n,2n,1n]
Test_rev1 = Equal.refl

Test_rev2 : Equal (Rev List.nil) List.nil
Test_rev2 = Equal.refl</code></pre>
<h4 id="properties-of-rev"><a class="header" href="#properties-of-rev">Properties of Rev</a></h4>
<p>Now let's prove some theorems about the <code>Rev</code> we just defined. For something a bit more challenging than what we've seen, let's prove that reversing a list doesn't change its length. Our first attempt gets stuck at the successor case...</p>
<pre><code class="language-rust ignore">Rev_length_firsttry (xs: List Nat)              : Equal Nat (Length (Rev xs)) (Length xs)
Rev_length_firsttry List.nil                    = Equal.refl
Rev_length_firsttry (List.cons xs.head xs.tail) =
   let ind = Rev_length_firsttry xs.tail
   ?</code></pre>
<p>The <code>Type Check</code> returns the following goal and context:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: Equal Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Nat.succ (Length tail)) 

   • Context: 
   •   head : Nat 
   •   tail : (List Nat) 
   •   ind  : Equal Nat (Length (Rev tail)) (Length tail)
   •   ind  = (Rev_length_firsttry tail) 

   let ind = Rev_length_firsttry tail
      ?
      ┬
      └Here!
</code></pre>
<p>Now we have to prove that the length of the concatenation of the reverse of the tail of the list and its head is equal to the successor of the length of the tail, so we'll need to use some other proofs, one of which is that the length of the concatenation of two lists is the same as the sum of the lengths of each of them:</p>
<pre><code class="language-rust ignore">Concat_length (xs: List Nat) (ys: List Nat)  : Equal Nat (Length (Concat xs ys)) (Plus (Length xs) (Length ys))
Concat_length List.nil ys                    = Equal.refl
Concat_length (List.cons xs.head xs.tail) ys =
   let ind = Concat_length xs.tail ys
   let app = Equal.apply (x =&gt; (Nat.succ x)) ind
   app</code></pre>
<p>In addition to this proof, we'll use others already proven in previous chapters:</p>
<pre><code class="language-rust ignore">Plus_n_z (n: Nat)     : Equal Nat n (Plus n Nat.zero)
Plus_n_sn (n: Nat) (m: Nat) : Equal Nat (Nat.succ (Plus n m)) (Plus n (Nat.succ m))
Plus_comm (n: Nat) (m: Nat) : Equal Nat (Plus n m) (Plus m n)</code></pre>
<p>And now we can prove our theorem:</p>
<pre><code class="language-rust ignore">Rev_length (xs: List Nat)               : Equal Nat (Length (Rev xs)) (Length xs)
Rev_length List.nil                     = Equal.refl
Rev_length (List.cons Nat head tail)  =
   let ind   = Rev_length tail
   ?</code></pre>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: Equal Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Nat.succ (Length tail)) 

   • Context: 
   •   head : Nat 
   •   tail : (List Nat) 
   •   ind  : Equal Nat (Length (Rev tail)) (Length tail) 
   •   ind  = (Rev_length tail) 

   let ind   = Rev_length tail
      ?
      ┬
      └Here!
</code></pre>
<p>We create a variable with our auxiliary <code>Concat_length</code>:</p>
<pre><code class="language-rust ignore">Rev_length (xs: List Nat)             : Equal Nat (Length (Rev xs)) (Length xs)
Rev_length List.nil                   = Equal.refl
Rev_length (List.cons Nat head tail)  =
   let ind  = Rev_length tail
   let aux1 = Concat_length (Rev xs.tail) [xs.head]
   ?</code></pre>
<p>We receive a new context for our auxiliaries...</p>
<pre><code> • aux1: Equal Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Plus (Length (Rev tail)) 1n)
</code></pre>
<p>... the <code>aux1</code> is equal to the left side of our <code>Expected</code>, so half the work is already done, we just need the other side of the equality and for that we create a new variable, <code>aux2</code>:</p>
<pre><code class="language-rust ignore">let aux2 = Plus_comm (Length (Rev xs.tail)) (1n)</code></pre>
<p>Now our context is even better:</p>
<pre><code class="language-rust ignore"> • aux2: Equal Nat (Plus (Length (Rev tail)) 1n) (Nat.succ (Length (Rev tail))) </code></pre>
<p>As we make progress in our formal proofs, we can see that the left side of <code>aux2</code> is equal to the right side of <code>aux1</code>, and we can chain them together using <code>Equal.chain</code>:</p>
<pre><code class="language-rust ignore">let chn = Equal.chain aux1 aux2</code></pre>
<p>When we Type Check, we see our new context:</p>
<pre><code class="language-Terminal"> • chn : Equal Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Nat.succ (Length (Rev tail)))
</code></pre>
<p>Nossa variável <code>chn</code> é praticamente idêntica ao nosso <code>Expected</code> só diferindo na parte final, pois <code>Expected</code> espera um <code>Nat.succ (Length xs.tail)</code> e o <code>chn</code> nos dá <code>Nat.succ (Length (Rev xs.tail))</code>, mas nós temos a variável <code>ind</code> que nos retorna essa igualdade. Vamos relembrar:</p>
<p>Our <code>chn</code> variable is practically identical to our <code>Expected</code>, differing only in the final part, since <code>Expected</code> expects a <code>Nat.succ (Length xs.tail)</code> and <code>chn</code> gives us <code>Nat.succ (Length (Rev xs.tail))</code>, but we have the <code>ind</code> variable that returns us this equality. Let's remember:</p>
<pre><code class="language-Terminal"> • ind: Equal Nat (Length (Rev tail)) (Length tail) 
</code></pre>
<p>Incredible, isn't it? It returns exactly what we need, that the size of the reverse of the <code>tail</code> is equal to the size of the <code>tail</code>, so we just need to rewrite the <code>ind</code> variable in our <code>chn</code>:</p>
<pre><code class="language-rust ignore">let rrt = Equal.rewrite ind (x =&gt; Equal Nat (Length (Concat (Rev tail) (List.cons head (List.nil)))) (Nat.succ x )) chn</code></pre>
<p>Let's see our new context, only hiding the types for easier reading:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: Equal Nat (Length (Concat (Rev tail) (List.cons _ head (List.nil _)))) (Nat.succ (Length tail)) 

   • Context: 
   •   head : Nat 
   •   tail : (List Nat) 
   •   ind  : Equal Nat (Length (Rev tail)) (Length tail) 
   •   ind  = (Rev_length tail) 
   •   aux1 : Equal Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Plus (Length (Rev tail)) 1n) 
   •   aux1 = (Concat_length (Rev tail) (List.cons Nat head (List.nil Nat))) 
   •   aux2 : Equal Nat (Plus (Length (Rev tail)) 1n) (Nat.succ (Length (Rev tail))) 
   •   aux2 = (Plus_comm (Length (Rev tail)) 1n) 
   •   chn  : Equal Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Nat.succ (Length (Rev tail)))
   •   chn  = Equal.chain Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Plus (Length (Rev tail)) 1n) (Nat.succ (Length (Rev tail))) aux1 aux2 
   •   rrt  : Equal Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Nat.succ (Length tail)) 
   •   rrt  = Equal.rewrite Nat (Length (Rev tail)) (Length tail) ind (x =&gt; Equal Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Nat.succ x))) chn
</code></pre>
<p>Now it's much easier to see that our <code>rrt</code> is exactly our <code>Expected</code>, so our proof is as follows:</p>
<pre><code class="language-rust ignore">Rev_length (xs: List Nat)            : Equal Nat (Length (Rev xs)) (Length xs)
Rev_length List.nil                  = Equal.refl
Rev_length (List.cons Nat head tail) =
   let ind   = Rev_length tail
   let aux1  = Concat_length (Rev tail) [head]
   let aux2  = Plus_comm (Length (Rev tail)) (1n)
   let chn   = Equal.chain aux1 aux2
   let rrt = Equal.rewrite ind (x =&gt; Equal Nat (Length (Concat (Rev tail) [head])) (Nat.succ x)) chn
   rrt</code></pre>
<h3 id="list-exercises-part-1"><a class="header" href="#list-exercises-part-1">List Exercises, Part 1</a></h3>
<h4 id="list_exercises"><a class="header" href="#list_exercises">List_exercises</a></h4>
<p>Let's practice a little more with lists:</p>
<pre><code class="language-rust ignore">Concat_nil_r (xs: List Nat) : Equal (Concat xs List.nil) xs
Concat_nil_r xs = ?

Concat_assoc (xs: List Nat) (ys: List Nat) (zs: List Nat) : Equal (Concat (Concat xs ys) zs) (Concat xs (Concat ys zs))
Concat_assoc xs ys zs = ?

Rev_app_distr (xs: List Nat) (ys: List Nat) : Equal (Rev (Concat xs ys)) (Concat (Rev ys) (Rev xs))
Rev_app_distr xs ys = ?

Rev_involutive (xs: List Nat) : Equal (Rev (Rev xs)) xs
Rev_involutive xs = ?</code></pre>
<p>There is a short solution to the next one. If you find it too difficult or it starts to get too long, step back and try to find a simpler way.</p>
<pre><code class="language-rust ignore">Concat_assoc4 (l1: List Nat) (l2: List Nat) (l3: List Nat) (l4: List Nat) : Equal (List Nat) (Concat l1 (Concat l2 (Concat l3 l4))) (Concat (Concat (Concat l1 l2) l3) l4)
Concat_assoc4 l1 l2 l3 l4 = ? </code></pre>
<p>An exercise on your implementation of <code>Nonzeros</code>:</p>
<pre><code class="language-rust ignore">Nonzeros_app (xs: List Nat) (ys: List Nat) : Equal (List Nat) (Nonzeros (Concat xs ys)) (Concat (Nonzeros xs) (Nonzeros ys))
Nonzeros_app xs ys = ?</code></pre>
<h4 id="beq_natlist"><a class="header" href="#beq_natlist">Beq_NatList</a></h4>
<p>Fill in the definition of <code>beq_NatList</code>, which compares lists of numbers for equality. Prove that <code>beq_NatList</code> xs ys produces <code>Bool.true</code> for each list.</p>
<pre><code class="language-rust ignore">Beq_NatList (xs: List Nat) (ys: List Nat) : Bool
Beq_NatList xs ys = ? 

Test_beq_natlist1 : Equal Bool (Beq_list List.nil List.nil) Bool.true
Test_beq_natlist1 = ?

Test_beq_natlist2 : Equal Bool (Beq_list [1n,2n,3n] [1n,2n,3n]) Bool.true
Test_beq_natlist2 = ?

Test_beq_natlist3 : Equal Bool (Beq_list [1n,2n,3n] [1n,2n,4n]) Bool.false
Test_beq_natlist3 = ?

Beq_natlist_refl (xs: List Nat) : Equal Bool Bool.true (Beq_list xs xs)
Beq_natlist_refl xs = ?</code></pre>
<h3 id="list-exercises-part-2"><a class="header" href="#list-exercises-part-2">List Exercises, Part 2</a></h3>
<h4 id="proofs"><a class="header" href="#proofs">Proofs</a></h4>
<p>Prove the following theorem, it will help you in the next proof:</p>
<pre><code class="language-rust ignore">Ble_n_succ_n (n: Nat) : Equal Bool (Lte n (Nat.succ n)) Bool.true
Ble_n_succ_n n = ? </code></pre>
<p>Prove the following theorem, it will help you in the next proof:</p>
<pre><code class="language-rust ignore">Count_member_nonzero (xs: List Nat) : Equal Bool (Lte 1n (Count 1n (List.cons 1n xs))) Bool.true
Count_member_nonzero xs = ?</code></pre>
<h4 id="rev_injective"><a class="header" href="#rev_injective">Rev_injective</a></h4>
<p>Prove that the <code>Rev</code> function is injective - that is,</p>
<pre><code class="language-rust ignore">Rev_injective (xs: List Nat) (ys: List Nat) (e: Equal (List Nat) (Rev xs) (Rev ys)) :tail Equal (List Nat) xs ys
Rev_injective xs ys e = ?  </code></pre>
<h4 id="opcional-count_sum"><a class="header" href="#opcional-count_sum">Opcional: Count_sum</a></h4>
<p>Write an interesting theorem about Lists involving the functions count and sum, and prove it. (You may find that the difficulty of the test depends on how you set the count!)</p>
<pre><code class="language-rust ignore">Count_sum : ?
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="maybe"><a class="header" href="#maybe">Maybe</a></h2>
<p>Suppose we want to write a function that returns the nth number of a list.
We then define a number that is applied to a list of naturals and returns the number that occupies that position. Therefore, we need to define a number to be returned if the number is greater than the size of the list.</p>
<pre><code class="language-rust ignore">Nth_bad (n: Nat) (xs: List Nat)            : Nat
Nth_bad n List.nil                         = 42n // arbitrary value 
Nth_bad Nat.zero (List.cons head tail)     = head
Nth_bad (Nat.succ n) (List.cons head tail) = Nth_bad n tail</code></pre>
<p>This solution is not so good: if nth_bad returns 0, we cannot tell if that value actually appears in the input without further processing. A better alternative is to change the return type of nth_bad to include an error value as a possible result.</p>
<p>We call this type <code>Maybe</code>, because it may or may not have something; if it has, it is a <code>Maybe.some</code> of that something, if it does not have, it is a <code>Maybe.none</code>.</p>
<pre><code class="language-rust ignore">type Maybe (t) {
  none 
  some (value: t)
}</code></pre>
<p>We can then change the above definition of nth_bad to return None when the list is too short and Some when the list has enough members and appears at the position n. We call this new function nth_error to indicate that it may result in an error.</p>
<p>This proof also serves to introduce us to another feature of Kind, conditional expressions, the <code>if</code> and <code>else</code>.</p>
<pre><code class="language-rust ignore">Nth_error (n: Nat) (xs: List Nat) : Maybe Nat
Nth_error n List.nil              = Maybe.none
Nth_error n (List.cons head tail) = 
  let ind = Nth_error (Pred n) tail
  Bool.if (Eql n 0n) (Maybe.some Nat head) (ind)

Test_nth_error1 : Equal (Nth_error 0n [4n,5n,6n,7n]) (Maybe.some 4n)
Test_nth_error1 = Equal.refl

Test_nth_error2 : Equal (Nth_error 3n [4n,5n,6n,7n]) (Maybe.some 7n)
Test_nth_error2 = Equal.refl

Test_nth_error3 : Equal (Nth_error 9n [4n,5n,6n,7n]) Maybe.none
Test_nth_error3 = Equal.refl</code></pre>
<!-- TODO -->
<pre><code class="language-rust ignore">Extract (d: Nat) (o: Maybe Nat) : Nat
Extract d (Maybe.some k)        = k
Extract d (Maybe.none)          = d</code></pre>
<h4 id="head_error"><a class="header" href="#head_error">Head_error</a></h4>
<p>Using the same idea, correct the <code>Head</code> function from before so that we don't have to pass a default element for the case <code>List.nil</code>.</p>
<pre><code class="language-rust ignore">Head_error (xs: List Nat) : Maybe Nat
Head_error xs = ?

Test_head_error1 : Equal (Head_error List.nil) Maybe.none
Test_head_error1 = ?

Test_head_error2 : Equal (Head_error [1n]) (Maybe.some Nat 1n)
Test_head_error2 = ?

Test_head_error3 : Equal (Head_error  [5n,6n]) (Maybe.some Nat 5n)
Test_head_error3 = ?</code></pre>
<h4 id="opcional-extract_head"><a class="header" href="#opcional-extract_head">Opcional: Extract_head</a></h4>
<p>This exercise relates your new <code>Head_error</code> to the old <code>Head</code>.</p>
<pre><code class="language-rust ignore">Extract_head (l: List Nat) (default: Nat) : Equal Nat (Head default l)  (Extract default (Head_error l))
Extract_head l default = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h1>
<p>In this chapter, we continue our development of basic programming concepts. Our new essential principles are polymorphism (abstraction functions over the data types they manipulate) and higher-order functions (treating functions as data). We begin with polymorphism.</p>
<h2 id="polymorphic-lists"><a class="header" href="#polymorphic-lists">Polymorphic Lists</a></h2>
<p>In the last two chapters, we worked with polymorphic lists, you may just not have realized it. Obviously, interesting programs also need to be able to manipulate lists with elements of other types - lists of strings, lists of booleans, lists of lists, etc. We could just define a new inductive data type for each of them, for example...</p>
<pre><code class="language-rust ignore">type BoolList {
   nil 
   cons (head: Bool) (tail: List Bool) 
}</code></pre>
<p>...but that would quickly become tedious, in part because we have to compensate for different constructor names for each data type, but mainly because we also need to define new versions of all our list manipulation functions (length, rev, etc.) for each new data type definition.</p>
<p>To avoid all this repetition, <strong>Kind</strong> supports definitions of polymorphic inductive types. For example, here is a polymorphic list data type that we already saw in the previous chapter:</p>
<pre><code class="language-rust ignore">type List (t) {
   nil 
   cons (head: t) (tail: List t) 
}</code></pre>
<p>This type already exists in Kind and we can see that it is identical to BoolList, but with a type <code>a</code>, which receives any other type, be it <strong>Nat</strong>, <strong>Bool</strong>, <strong>Maybe</strong>, etc. We don't need to create a list type for each of the data types, we can use this one that adopts all existing forms.</p>
<p>What kind of thing is the List itself? A good way to think about it is that List is a Types function for inductive definitions; or, in other words, List is a Types function for Types. For any specific type x, the type List x is an inductively defined set of lists whose elements are of type x.</p>
<p>With this definition, when we use the constructors <code>List.nil</code> and <code>List.cons</code> to build lists, we need to tell Kind the type of elements in the lists we are building - that is, that <code>List.nil</code> and <code>List.cons</code> are now polymorphic constructors. Note the types of constructors:</p>
<pre><code class="language-rust ignore">record Pair (a) (b) {
  fst : a
  snd : b
}</code></pre>
<p>Our <strong>Pair</strong> type receives two other types, <code>a</code> and <code>b</code>, and returns a pair of the two types. It was not necessary to define whether the pair was of natural numbers, booleans, lists, bits or other pairs, we left the function capable of handling all possible pairs and this is thanks to <em>polymorphism</em>.</p>
<p>Now we can go back and make polymorphic versions of all the processing lists functions we wrote before. Here's the repeat function again, for example:</p>
<pre><code class="language-rust ignore">Repeat &lt;a: Type&gt; (x: a) (count: Nat) : List a
Repeat a x Nat.zero                  = List.nil
Repeat a x (Nat.succ count)          = List.cons x (Repeat x count)</code></pre>
<p>Just like with <code>List.nil</code> and <code>List.cons</code>, we can use repeat by first applying it to a type and then to its list argument:</p>
<pre><code class="language-rust ignore">Test_repeat1 : Equal (Repeat 4n 2n) (List.cons 4n (List.cons 4n List.nil))
Test_repeat1 = Equal.refl</code></pre>
<p>To use repeat to build other types of lists, we simply instantiate it with an appropriate type parameter:</p>
<pre><code class="language-rust ignore">Test_repeat2 : Equal (Repeat Bool.false 1n) (List.cons Bool.false List.nil)
Test_repeat2 = Equal.refl</code></pre>
<h3 id="type-annotation-inference"><a class="header" href="#type-annotation-inference">Type Annotation Inference</a></h3>
<p>Let's write the definition of <code>repeat</code> again, but this time omitting the type. However, please note that this is not a good practice to use the <code>hole</code>, it will only serve to understand the power of Kind and how it can help the user find what they want.</p>
<pre><code class="language-rust ignore">Repeat (x: _) (count: Nat) : List _
Repeat x Nat.zero          = ?</code></pre>
<p>When running the <em>Type Check</em>, the terminal returns:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: (List _) 

   • Context: 
   •   x : _ 

   Repeat x Nat.zero = ?
                       ┬
                       └Here!
</code></pre>
<p>For the case where the count is zero, which is our stopping point, we need to return a list of undefined type.</p>
<p>As we did when our type was defined, we are creating a list that does not repeat the term at all, we return a <code>List.nil</code>, then we check for the case of a list that will repeat the value count times, for this we will use recursion through <code>Nat.succ pred</code>, that is, our count is equal to the successor of its predecessor.</p>
<pre><code class="language-rust ignore">Repeat x (Nat.succ count) = ?</code></pre>
<p>And the <em>Type Check</em> returns:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: (List _) 

   • Context: 
   •   x     : _ 
   •   count : Nat 

   Repeat x (Nat.succ count) = ?
                               ┬
                               └Here!
</code></pre>
<p>Now we just need to construct the list with the value and call the function for the predecessor of count, thus building the list until it reaches zero.</p>
<pre><code class="language-rust ignore">Repeat (x: _) (count: Nat) : List _
Repeat x Nat.zero          = List.nil
Repeat x (Nat.succ count)  = List.cons x (Repeat x count)</code></pre>
<p>We can see that, even though we didn't define the type of <code>x</code>, the <strong>Kind</strong> is powerful enough to discover the type that our x is when we use the <code>_</code> <em>hole</em>. Although it is possible and may even facilitate building an entire application using this notation, it is not a good practice since, depending on the case, a different type than the desired one may be inferred. It is interesting to always define the type of our element, even if it is a polymorphic type.</p>
<p>In the first case, when we define the type <code>a</code>, we already encompass all possible types, so it is not necessary to use the hole and that is the magic of polymorphism, it allows us to use the same function for different types.</p>
<p>To use a polymorphic function, we need to pass one or more types in addition to the other arguments. For example, in the case of repeat, we pass the type <code>&lt;a: Type&gt;</code> and that each element of our list is of that type. We did the same with the <em>Pair</em> type, which received two types <code>a</code> and <code>b</code> as arguments.</p>
<p>Now it is much easier to understand the examples we used in the previous chapter, when we presented functions like length and append:</p>
<pre><code class="language-rust ignore">Length &lt;a&gt; (xs: List a) : Nat
Length (List.nil t)            = Nat.zero
Length (List.cons t head tail) = (Nat.succ (Length tail))

Concat &lt;a: Type&gt; (xs: List a) (ys: List a) : List a
Concat (List.nil)                     ys = ys
Concat (List.cons head tail)          ys = List.cons head (Concat tail ys)
</code></pre>
<p>Note that there are two notations, one where we only use <code>&lt;a&gt;</code> and another where we use <code>&lt;a: Type&gt;</code>, we can use either one, the <strong>Kind</strong> is capable of understanding both forms, it will be up to the developer to choose which one to use and the complexity of what will be developed, since in very complex code, it may be interesting to make explicit to other programmers what each thing is.</p>
<p>Now it's time to implement our functions with implicit typing, using <code>hole</code> and <code>sugar syntax</code>:</p>
<pre><code class="language-rust ignore">Concat_implicito (xs: List _) (ys: List _) : List _
Concat_implicito []                     ys = ys
Concat_implicito (List.cons head tail)  ys = List.cons head (Concat_implicito tail ys)</code></pre>
<p>Here we learned one more thing, the <code>sugar syntax</code> for an empty list is just <code>[]</code>, but this is wrong, since the <code>sugar syntax</code> for kind doesn't work on the left side of the function scope, only on the right side. Using the wrong <code>sugar syntax</code> results in an error shown by <strong>Kind</strong>:</p>
<pre><code class="language-diff">- ERROR  Unexpected token '['.
    Concat_implicito []  ys = ys
                  ┬
                  └Here!
</code></pre>
<p>Therefore, it is always important to know exactly what is being done, especially when using <em>sugar syntax</em>. It is meant to make our lives easier but can cause problems when used incorrectly. This also applies to <code>hole</code> and polymorphic types help us write a safer program that can be used for countless cases.</p>
<p>We can also rewrite the <code>reverse</code> function:</p>
<pre><code class="language-rust ignore">Rev &lt;a&gt; (xs: List a) : List a
Rev List.nil              = [] // sugar syntax de List.nil
Rev (List.cons head tail) = Concat (Rev tail) [head] // sugar syntax de (List.cons head List.nil)

Length &lt;a&gt; (xs: List a) : Nat
Length List.nil              = 0n // sugar syntax de Nat.zero
Length (List.cons head tail) = Nat.succ (Length tail)</code></pre>
<p>After that, we just need to prove that our functions are correct:</p>
<pre><code class="language-rust ignore">Test_rev1 : Equal (Rev [1,2,3]) [3,2,1]
Test_rev1 = Equal.refl

Test_rev2 : Equal (Rev [Bool.true]) [Bool.true]
Test_rev2 = Equal.refl

Test_length1 : Equal (Length [1,2,3]) 3n
Test_length1 = Equal.refl</code></pre>
<h4 id="polymorphic-exercises"><a class="header" href="#polymorphic-exercises">Polymorphic Exercises</a></h4>
<p>Here are some simple exercises, similar to the ones in the Lists section, to practice polymorphism. Complete the proofs below.</p>
<pre><code class="language-rust ignore">Concat_nil_r &lt;a&gt; (xs: List a) : Equal (Concat xs List.nil) xs
Concat_nil_r xs = ?

Concat_assoc &lt;a&gt; (xs: List a) (ys: List a) (zs: List a) : Equal (Concat xs (Concat ys zs)) (Concat (Concat xs ys) zs)
Concat_assoc xs ys zs = ?

Concat_length &lt;a&gt; (xs: List a) (ys: List a) : Equal (Length (Concat xs ys)) (Plus (Length xs) (Length ys))
Concat_length xs ys = ?</code></pre>
<h4 id="more-polymorphic-exercises"><a class="header" href="#more-polymorphic-exercises">More Polymorphic Exercises</a></h4>
<p>Here are some slightly more interesting exercises...</p>
<pre><code class="language-rust ignore">Rev_app_distr &lt;a&gt; (xs: List a) (ys: List a) : Equal (Rev (Concat xs ys)) (Concat (Rev ys) (Rev xs))
Rev_app_distr xs ys = ?

Rev_involutive &lt;a&gt; (xs: List a) : Equal (Rev (Rev xs)) xs
Rev_involutive xs = ?</code></pre>
<h2 id="polymorphic-pairs"><a class="header" href="#polymorphic-pairs">Polymorphic Pairs</a></h2>
<p>Following the same pattern, the type definition for pairs of numbers that we gave in the last chapter can be generalized for polymorphic pairs:</p>
<pre><code class="language-rust ignore">record Pair (a) (b) {
  fst : a
  snd : b
} </code></pre>
<p>This is exactly the first definition of pairs that we saw in the previous chapter, and now we can understand perfectly what the <code>a</code> and <code>b</code> types are in the <strong>Pair</strong> type definition.</p>
<p>We can rewrite the <em>Pairs</em> functions, but now for polymorphic types:</p>
<pre><code class="language-rust ignore">Fst &lt;a&gt; &lt;b&gt; (pair: Pair a b) : a
Fst (Pair.new fst snd) = fst

Snd &lt;a&gt; &lt;b&gt; (pair: Pair a b) : b
Snd (Pair.new fst snd) = snd</code></pre>
<p>The following function takes two lists and combines them into a list of pairs. In functional languages, this is commonly called <strong>Zip</strong>.</p>
<pre><code class="language-rust ignore">Zip &lt;a&gt; &lt;b&gt; (xs: List a) (ys: List b) : (List (Pair a b))
Zip [] ys = []
Zip xs [] = []
Zip (List.cons xs.h xs.t) (List.cons ys.h ys.t) = List.cons (Pair.new xs.h xs.t) (Zip xs.t ys.t)</code></pre>
<h4 id="check"><a class="header" href="#check">Check</a></h4>
<p>Without running the program, try to answer the following question:</p>
<ul>
<li>What will the combination of <code>[1, 2]</code> and <code>[Bool.true, Bool.false, Bool.false, Bool.true]</code> return?</li>
</ul>
<p>Now run the code and see if you got it right.</p>
<h4 id="split"><a class="header" href="#split">Split</a></h4>
<p>The <strong>Split</strong> function is the inverse of <strong>Zip</strong>. It takes a list of pairs and returns a pair of lists. In many functional languages, it is called <strong>Unzip</strong>.</p>
<p>Fill in the definition of the splitting function below. Make sure it passes the unit test provided.</p>
<pre><code class="language-rust ignore">Split &lt;a&gt; &lt;b&gt; (xs: List (Pair a b)) : Pair (List a) (List b)
Split xs = ?

Test_split : Equal (Split [(Pair.new 1 Bool.false), (Pair.new 2 Bool.false)]) (Pair.new ([1, 2]) ([Bool.false, Bool.false]))
Test_split = ?</code></pre>
<h4 id="polymorphism-with-maybe"><a class="header" href="#polymorphism-with-maybe">Polymorphism with Maybe</a></h4>
<p>In the previous chapter, we also saw the Maybe type, but only for natural types. However, as we have seen in this chapter, our data structures can be polymorphic, which means that the Maybe type is also polymorphic, and that is what we will see now.</p>
<pre><code class="language-rust ignore">type Maybe (t) {
  none 
  some (value: t)
}</code></pre>
<p>This way, we can write the function of the nth error to be used with all types of lists:</p>
<pre><code class="language-rust ignore">Nth_error &lt;a&gt; (n: Nat) (xs: List a) : Maybe a
Nth_error a n List.nil              = Maybe.none
Nth_error a n (List.cons head tail) =
  let ind = Nth_error (Pred n) tail
  Bool.if (Eql n 0n) (Maybe.some head) (ind)


Test_nth_error1 : Equal (Nth_error 0n [4n,5n,5n,7n]) (Maybe.some 4n)
Test_nth_error1 = Equal.refl

Test_nth_error2 : Equal (Nth_error 2n [Bool.true]) Maybe.none
Test_nth_error2 = Equal.refl

Test_nth_error3 : Equal (Nth_error 1n [[1n],[2n]]) (Maybe.some [2n])
Test_nth_error3 = Equal.refl
</code></pre>
<h4 id="hd_error"><a class="header" href="#hd_error">Hd_error</a></h4>
<p>Complete the definition of a polymorphic version of the Hd_error function from the last chapter. Make sure it passes the unit tests below.</p>
<pre><code class="language-rust ignore">Hd_error &lt;a&gt; (xs: Lista a) : Maybe a
Hd_error xs = ?

Test_hd_error1 : Equal (Hd_error [1, 2]) (Maybe.some 1)
Test_hd_error1 = ?

Test_hd_error2 : Equal (Hd_error [[1], [2]]) (Maybe.some [1])
Test_hd_error2 = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="functions-as-data"><a class="header" href="#functions-as-data">Functions as data</a></h2>
<p>Functions as data
Like many other modern programming languages -- including all functional languages (ML, Haskell, Scheme, Scala, Clojure, etc.) -- Kind treats functions as first-class citizens, allowing them to be passed as arguments to other functions, returned as results, stored in data structures, etc.</p>
<h3 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher-Order Functions</a></h3>
<p>Functions that manipulate other functions are often called higher-order functions (or &quot;higher-order&quot; for short). Here is a simple example:</p>
<pre><code class="language-rust ignore">Doit3times &lt;x&gt; (f: x -&gt; x) (n: x) : x
Doit3times f x = (f (f (f x)))

Test_doit3times1 : Equal (Doit3times (x =&gt; MinusTwo x) 9n) 3n
Test_doit3times1 = Equal.refl

Test_doit3times2 : Equal (Doit3times (x =&gt; Notb x) Bool.true) (Bool.false)
Test_doit3times2 = Equal.refl</code></pre>
<h3 id="filter"><a class="header" href="#filter">Filter</a></h3>
<p>Here is a more useful higher-order function, taking a list of xs and a predicate on x (a function from x to Bool) and &quot;filtering&quot; the list, returning a new list containing only those elements for which the predicate returns Bool.true.</p>
<pre><code class="language-rust ignore">Filter &lt;x&gt; (test: x -&gt; Bool) (xs: List x) : List x
Filter test List.nil                      = []
Filter test (List.cons head tail)         =
   Bool.if (test head) (List.cons head (Filter test tail)) (Filter test tail)</code></pre>
<p>For example, if we apply the &quot;is even&quot; filter to a list of numbers, it will return another list with only the even numbers.</p>
<pre><code class="language-rust ignore">Test_filter1 : Equal (Filter (x =&gt; Evenb x) [1,2,3,4,5])  [2,4]  
Test_filter1 = Equal.refl

Length_is_one &lt;x&gt; (xs: List x) : Bool
Length_is_one xs               = Eql (Length xs) 1n

Test_filter2 : Equal (Filter (x =&gt; Length_is_one x) ([[1],[1,2],[3],[1,2,3],[21]])) ([[1],[3],[21]])
Test_filter2 = Equal.refl</code></pre>
<p>We can use filter to provide a concise version of the Countoddmembers function from the Lists chapter.</p>
<pre><code class="language-rust ignore">CountOddMembers (xs: List Nat) : Nat
CountOddMembers xs             = Length (Filter (x =&gt; Oddb x) xs)

Test_CountOddMembers1 : Equal (CountOddMembers  [1n,0n,3n,1n,4n,5n]) 4n
Test_CountOddMembers1 = Equal.refl

Test_CountOddMembers2 : Equal (CountOddMembers  [0n 2n,4n]) 0n
Test_CountOddMembers2 = Equal.refl

Test_CountOddMembers3 : Equal (CountOddMembers []) 0n
Test_CountOddMembers3 = Equal.refl</code></pre>
<h3 id="anonymous-functions"><a class="header" href="#anonymous-functions">Anonymous Functions</a></h3>
<p>It is arguably a bit sad, in the example above, to be forced to define the function <strong>Length_is_one</strong> and give it a name just to be able to pass it as an argument to filter, since we will probably never use it again.</p>
<p>Furthermore, this is not an isolated example: when using higher-order functions, we often want to pass &quot;unique&quot; functions as arguments that we will never use again; having to name each of these functions would be tedious.</p>
<p>Fortunately, there is a better way. We can build a function &quot;on the fly&quot; without declaring it at the top level or giving it a name.</p>
<pre><code class="language-rust ignore">Test_anon_fun : Equal (Doit3times (x =&gt; (Mult x x)) 2n) 256n
Test_anon_fun = Equal.refl</code></pre>
<p>The expression <code>x =&gt; (Mult x x)</code> can be read as &quot;the function takes a number <code>n</code> and returns <code>n * n</code>&quot;.</p>
<p>Here is the example of <strong>Filter</strong> rewritten to use an anonymous function:</p>
<pre><code class="language-rust ignore">Test_filter2 : Equal (Filter (x =&gt; (Length_is_one x)) [[1],[1,2],[2],[1,2,3],[21]]) [[1],[2],[21]]
Test_filter2 = Equal.refl
</code></pre>
<h4 id="filter_even_gt7"><a class="header" href="#filter_even_gt7">Filter_even_gt7</a></h4>
<p>Use Filter with anonymous functions (instead of function definitions) to write a function Filter_even_gt7 that takes a list of natural numbers as input and returns a list only of those that are even and greater than 7.</p>
<pre><code class="language-rust ignore">Filter_even_gt7 (xs: List Nat) : List Nat
Filter_even_gt7 xs = ?

Test_filter_even_gt7a: Equal (Filter_even_gt7 [1n,2n,3n,4n,5n,7n,8n,9n,10n,11n,12n]) [8n,10n,12n]
Test_filter_even_gt7a = ?

Test_filter_even_gt7b : Equal (Filter_even_gt7 [5n, 2n, 6n, 19n, 129n]) []
Test_filter_even_gt7b = ?</code></pre>
<p>A small observation, the attentive reader may have noticed that we used a new notation, the n after the numbers. This is a sugar syntax that Kind has. We can write natural numbers by simply adding an n to the number. However, this is a syntax that can end up weighing down Kind. Imagine that the user only wants to add the number <code>1</code> to <code>1000000</code>, it's a simple calculation that Kind can easily handle, but it becomes a bit heavier when using the sugar syntax for natural numbers. The sum will be <code>Plus 1n 1000000n</code>, but Kind will need to check each <code>Nat.succ</code> up to one million and one, in other words, one million and one &quot;<em>Nat.succ</em>&quot; will be computed unnecessarily. This syntax is very useful, but we should use it with care. Ideally, for large numbers, U60.to_nat should be used, which is much lighter for Kind.</p>
<h4 id="partition"><a class="header" href="#partition">Partition</a></h4>
<p>Use Filter to write a Partition function in Kind.</p>
<pre><code class="language-rust ignore">Partition &lt;x&gt; (test: x -&gt; Bool) (xs: List x) : Pair (List x) (List x)
Partition test xs = ?</code></pre>
<p>Given a set x, a test function of type <code>x -&gt; Bool</code>, and a List x, the Partition function should return a pair of lists. The first member of the pair is the sublist of the original list containing the elements that satisfy the test, and the second is the sublist containing those that fail the test. The order of the elements in the two sublists should be the same as the original list.</p>
<pre><code class="language-rust ignore">Test_partition1 : Equal (Partition (x =&gt; Oddb x) [1n,2n,3n,4n,5n]) (Pair.new [1n,3n,5n] [2n,4n])
Test_partition1 = ?

Test_partition2 : Equal (Partition (x =&gt; Bool.false) [5n, 9n, 0n]) (Pair.new [] [5n, 9n, 0n])
</code></pre>
<h3 id="map"><a class="header" href="#map">Map</a></h3>
<p>Another very useful higher-order function is Map.</p>
<pre><code class="language-rust ignore">Map &lt;x&gt; &lt;y&gt; (f: x -&gt; y) (xs: List x)  : List y
Map f List.nil                        = List.nil
Map f (List.cons head tail)           = List.cons (f head) (Map f tail)</code></pre>
<p>It takes a function <code>f</code> and a list <code>xs = [n1, n2, n3, ...]</code> and returns the list <code>[f n1, f n2, f n3, ...]</code>, where <code>f</code> is applied to each element of <code>xs</code>. For example:</p>
<pre><code class="language-rust ignore">Test_map1 : Equal (Map (x =&gt; Plus 3n x) [2n, 0n, 2n]) [5n, 3n, 5n]
Test_map1 = Equal.refl</code></pre>
<p>The types of the elements in the input and output list do not need to be the same, as Map accepts two type arguments, <code>x</code> and <code>y</code>; thus a function of numbers to booleans can be applied to produce a list of booleans:</p>
<pre><code class="language-rust ignore">
Test_map2 : Equal (Map (x =&gt; Nat.is_odd x) [2n, 1n, 2n, 5n]) [Bool.false, Bool.true, Bool.false, Bool.true]
Test_map2 = Equal.refl</code></pre>
<p>It can even be applied to a list of numbers and a function that returns a list of boolean lists:</p>
<pre><code class="language-rust ignore">Test_map3 = Equal (Map (x =&gt; [(Nat.is_even x), (Nat.is_odd x)]) [2n, 1n, 2n, 5n]) [[Bool.true, Bool.false], [Bool.false, Bool.true], [Bool.true, Bool.false], [Bool.false, Bool.true]]
Test_map3 = Equal.refl</code></pre>
<h4 id="map_rev"><a class="header" href="#map_rev">Map_rev</a></h4>
<p>Let's make things a little more difficult. Show the commutativity of Rev and Map; you may need an auxiliary function:</p>
<pre><code class="language-rust ignore">Map_rev &lt;x&gt; &lt;y&gt; (f: x -&gt; y) (xs: List x) : Equal (Map f (Rev xs)) (Rev (Map f xs))
Map_rev f xs = ?</code></pre>
<h4 id="flat_equal"><a class="header" href="#flat_equal">Flat_equal</a></h4>
<p>The Map function maps a <code>List x</code> to a <code>List y</code> using a function of type <code>x -&gt; y</code>. We can define a similar function, Flat_map, that maps a List x to a List y using a function f of type <code>x -&gt; List y</code>. Its definition should work by &quot;flattening&quot; the results of f, like so:</p>
<pre><code class="language-rust ignore">Flat_equal : Equal (Flat_map ( x =&gt; ([x , (Plus x 1n), (Plus x 2n)])) [1n, 5n, 10n]) [1n, 2n, 3n, 5n, 6n, 7n, 10n, 11n, 12n]
Flat_equal = Equal.refl

Flat_map &lt;x&gt; &lt;y&gt; (f: x -&gt; List y) (xs: List x) : List y
Flat_map f xs = ?

Test_flat_map1 : Equal (Flat_map (x =&gt; [x, x, x]) [1n, 5n, 4n]) [1n, 1n, 1n, 5n, 5n, 5n, 4n, 4n, 4n]
Test_flat_map1 = ?</code></pre>
<p>Lists are not the only inductive type for which we can write a Map function. Here's the definition of map for the Maybe type:</p>
<pre><code class="language-rust ignore">Maybe_map &lt;x&gt; &lt;y&gt; (f: x -&gt; y) (a: Maybe x)  : Maybe y
Maybe_map f Maybe.none                      = Maybe.none
Maybe_map f (Maybe.some x)                  = Maybe.some (f x)</code></pre>
<h3 id="fold"><a class="header" href="#fold">Fold</a></h3>
<p>An even more powerful higher-order function is called Fold. This function is the inspiration for the &quot;reduce&quot; operation that is at the heart of Google's map/reduce distributed programming framework.</p>
<pre><code class="language-rust ignore">Fold &lt;x&gt; &lt;y&gt; (f: x -&gt; y -&gt; y) (xs: List x) (a: y)   : y
Fold f List.nil a                                   = a
Fold f (List.cons head tail) a                      = f head (Fold f tail a)

Test_fold1 : Equal (Fold (x =&gt; y =&gt; (Bool.and x y)) [Bool.true, Bool.true, Bool.false] Bool.false) Bool.false
Test_fold1 = ?

Test_fold2 : Equal (Fold (x =&gt; y =&gt; (* x y)) [1, 2, 3, 4] 1) 24
Test_fold2 = ?

Test_fold3 : Equal (Fold (x =&gt; y =&gt; (Concat x y)) [[1], [], [2, 3], [], [4]] [5, 6, 7]) [1, 2, 3, 4, 5, 6, 7]
Test_fold3 = ?</code></pre>
<h4 id="fold_types_different"><a class="header" href="#fold_types_different">Fold_types_different</a></h4>
<p>Note that the type Fold is parameterized by two type variables, x and y, and the parameter f is a binary operator that takes an x and a y and returns a y. Can you think of a situation where it would be useful for x and y to be different?</p>
<h3 id="functions-that-build-functions"><a class="header" href="#functions-that-build-functions">Functions that build functions</a></h3>
<p>Most of the higher-order functions we've talked about so far use functions as arguments. Let's look at some examples that involve returning functions as results of other functions. To start, here's a function that takes a value x (extracted from some type x) and returns a Nat to x function that returns x every time it's called, ignoring its Nat argument.</p>
<pre><code class="language-rust ignore">Constfun &lt;y&gt; (x: y) : Nat -&gt; y
Constfun x = y =&gt; x</code></pre>
<pre><code class="language-rust ignore">Ftrue : Nat -&gt; Bool
Ftrue = Constfun Bool.true</code></pre>
<pre><code class="language-rust ignore">Constfun_example1 : Equal ((Ftrue) 0n) Bool.true
Constfun_example1 = Equal.refl</code></pre>
<pre><code class="language-rust ignore">Constfun_example2 : Equal ((Constfun 5n) 99n) 5n
Constfun_example2 = Equal.refl</code></pre>
<!-- Na verdade, as funções de múltiplos argumentos que já vimos também são exemplos de passagem de funções como dados. Para ver por que, lembre-se do tipo de adição -->
<!-- [>  <] -->
<!-- [> # TODO: <] -->
<!-- [>  <] -->
<!-- ```rust,ignore -->
<!-- Plus Nat -> Nat : Nat -->
<!-- ``` -->
<!-- [> Cada "->" nesta expressão é, na verdade, um operador binário em tipos. Este operador é associativo à direita, então o tipo de Plus é realmente uma abreviação para (Nat -> Nat) -> Nat – ou seja, pode ser lido como dizendo que “Plus é uma função de um argumento que pega um Nat e retorna uma função de um argumento que pega outro Nat e retorna um Nat.” Nos exemplos acima, sempre aplicamos mais a ambos os argumentos ao mesmo tempo, <] -->
<!-- [> mas se quisermos, podemos fornecer apenas o primeiro. Isso é chamado de aplicação parcial <] -->
<!-- [>  <] -->
<!-- [> # fim to todo <] -->
<!--  -->
<pre><code class="language-rust ignore">Plus3 : Nat -&gt; Nat
Plus3 = n =&gt; Plus 3n n</code></pre>
<pre><code class="language-rust ignore">Test_plus3_1 : Equal ((Plus3) 4n) 7n
Test_plus3_1 = Equal.refl</code></pre>
<pre><code class="language-rust ignore">Test_plus3_2 : Equal (Doit3times (Plus3) 0n) 9n
Test_plus3_2 = Equal.refl</code></pre>
<pre><code class="language-rust ignore">Test_plus3_3 : Equal (Doit3times (x =&gt; Plus 3n x) 0n) 9n
Test_plus3_3 = Equal.refl</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="additional-exercises"><a class="header" href="#additional-exercises">Additional Exercises</a></h2>
<p>Many common functions on lists can be implemented in terms of <strong>Fold</strong>. For example, here's an alternative definition of length:</p>
<pre><code class="language-rust ignore">Fold_length &lt;x&gt; (xs: List x) : Nat
Fold_length xs = Fold (x =&gt; y Nat.succ y) xs 0n</code></pre>
<pre><code class="language-rust ignore">Test_fold_length1 : Equal (Fold_length [4, 7, 0]) 3n
Test_fold_length1 = Equal.refl</code></pre>
<p>Prove the validity of <strong>Fold_length</strong>:</p>
<pre><code class="language-rust ignore">Fold_length_correct &lt;x&gt; (xs: List x) : Equal (Fold_length xs) (List.length xs)
Fold_length_correct xs = ?</code></pre>
<p>We can also define <strong>Map</strong> in terms of <strong>Fold</strong>. Complete the function:</p>
<pre><code class="language-rust ignore">Fold_map &lt;x&gt; &lt;y&gt; (f: x -&gt; y) (xs: List x) : List y
Fold_map f xs = ?</code></pre>
<p>Write a theorem <code>fold_map_correct</code> in Kind stating that <strong>Fold_map</strong> is correct and prove it:</p>
<pre><code class="language-rust ignore">Fold_map_correct : ?</code></pre>
<p>In Kind, a function <code>f: a -&gt; b -&gt; c</code> actually has type <code>a -&gt; (b -&gt; c)</code>. That is, if you give f a value of type <code>a</code>, it will provide the function <code>g: b -&gt; c</code>. If you give <code>g</code> a value of type <code>b</code>, it will return a value of type <code>c</code>. This allows for partial application, as in <code>Plus3</code>. Processing a list of arguments with functions that return functions is called currying, in honor of the logician Haskell Curry.</p>
<p>On the other hand, we can reinterpret the function <code>f: a -&gt; b -&gt; c</code> as <code>(Pair a b) -&gt; c</code>. This is called uncurrying. With a binary uncurry function, both arguments must be provided at the same time as a pair; there is no partial application.</p>
<p>We can define curry as follows:</p>
<pre><code class="language-rust ignore">Pair_curry &lt;x&gt; &lt;y&gt; &lt;z&gt; (f: (Pair x y) -&gt; z) (x_val: x) (y_val: y) : z 
Pair_curry f x_val y_val = ?</code></pre>
<p>As an exercise, define its inverse, <strong>Pair_uncurry</strong>. Then prove the theorems below to show that the two are inverses.</p>
<pre><code class="language-rust ignore">Pair_uncurry &lt;x&gt; &lt;y&gt; &lt;z&gt; (f: x -&gt; y -&gt; z) (p: Pair x y) : z
Pair_uncurry f p = ?</code></pre>
<p>As a (trivial) example of the usefulness of curry, we can use it to shorten one of the examples we saw above:</p>
<pre><code class="language-rust ignore">Test_map2 : Equal (Map (x =&gt; Plus 3n x) [2n,0n,2n]) [5n,3n,5n]
Test_map2 = Equal.refl</code></pre>
<p>Reflection exercise: before executing the following commands, can you calculate the types of <strong>Pair_curry</strong> and <strong>Pair_uncurry</strong>?</p>
<pre><code class="language-rust ignore">Uncurry_curry &lt;x&gt; &lt;y&gt; &lt;z&gt; (f: x -&gt; y -&gt; z) (x_val: x) (y_val: y) : 
   Equal z (Pair_curry (p =&gt; Pair_uncurry f p) x_val y_val) (f x_val y_val)
Uncurry_curry f x_val y_val = ?</code></pre>
<pre><code class="language-rust ignore">Curry_uncurry &lt;x&gt; &lt;y&gt; &lt;z&gt; (f:(Pair x y) -&gt; z) (p: Pair x y) : 
   Equal z (Pair_uncurry (x =&gt; y =&gt; Pair_curry f x y) p) (f p)
Curry_uncurry f p = ?</code></pre>
<p>Remember the definition of the function <strong>Nth_error</strong>(Nth_error_informal):</p>
<pre><code class="language-rust ignore">Nth_error_informal &lt;x&gt; (l: List x) (n: Nat) : Maybe x
Nth_error_informal List.nil n = Maybe.none 
Nth_error_informal (List.cons head tail) Nat.zero = Maybe.some head 
Nth_error_informal (List.cons head tail) (Nat.succ n) = Nth_error tail n</code></pre>
<p>Write an informal proof of the following theorem:</p>
<pre><code class="language-rust ignore">Nat -&gt; List -&gt; (Equal (Length List) Nat) : Equal (Nth_error_informal List Nat) Maybe.none</code></pre>
<p>We can explore an alternative way of defining natural numbers, using <em>Church numerals</em>, named after the mathematician Alonzo Church. We can represent a natural number n as a function that takes a function <code>s</code> as a parameter and returns <code>s</code> iterated n times.</p>
<pre><code class="language-rust ignore">Num &lt;x&gt; : Type
Num x = (x -&gt; x) -&gt; x -&gt; x</code></pre>
<p>Let's see how to write some numbers with this notation. Iterating a function once should be the same as just applying it. In this way:</p>
<pre><code class="language-rust ignore">One : Num
One = s =&gt; z =&gt; s z 
</code></pre>
<p>Note that the function applies an <code>s</code> to a <code>z</code>, if we read the <code>s</code> as <em>successor</em> and the <code>z</code> as <em>zero</em>, we have that <em>One</em> is equal to the <em>successor of zero</em>.</p>
<p>Similarly, <strong>Two</strong> applies the function <code>s</code> twice to <code>z</code>:</p>
<pre><code class="language-rust ignore">Two : Num
Two = s =&gt; z =&gt; s (s z)</code></pre>
<p>Defining zero is a bit more complicated: how can we &quot;apply a function zero times&quot;? The answer is actually simple: just return the argument untouched.</p>
<pre><code class="language-rust ignore">Zero : Num
Zero = s =&gt; z =&gt; z</code></pre>
<p>More generally, a number n can be written as <code>s =&gt; z =&gt; s (s ... (s z) ...)</code>, with n occurrences of <code>s</code>. Note in particular how the function doit3times that we defined earlier is actually just the Church representation of 3.</p>
<pre><code class="language-rust ignore">Three : Num
Three = s =&gt; z =&gt; Doit3times s z</code></pre>
<p>Complete the definitions of the following functions. Make sure the corresponding unit tests pass, proving them with <strong>Equal.refl</strong>.</p>
<h4 id="successor"><a class="header" href="#successor">Successor</a></h4>
<p>Successor of a natural number:</p>
<pre><code class="language-rust ignore">Succ (n: Num) : Num
Succ n = ?

Succ_1 : Equal (Succ Zero) (One)
Succ_1 = ?

Succ_2 : Equal (Succ One) (Two)
Succ_2 = ?

Succ_3 : Equal (Succ Two) (Three)
Succ_3 = ?</code></pre>
<h4 id="addition"><a class="header" href="#addition">Addition</a></h4>
<p>Addition of two natural numbers:</p>
<pre><code class="language-rust ignore">Plus (n: Num) (n: Num) : Num
Plus n m = ?

Plus_1 : Equal (Plus One Zero) (One)
Plus_1 = ?

Plus_2 : Equal (Plus Two One) (Plus One Two)
Plus_2 = ?

Plus_3 : Equal (Plus (Plus Two Two) Three) (Plus One (Plus Three Three))
Plus_3 = ?</code></pre>
<h4 id="multiplication"><a class="header" href="#multiplication">Multiplication</a></h4>
<pre><code class="language-rust ignore">Mult (n: Num) (m: Num) : Num
Mult n m = ?

Mult_1 : Equal (Mult One One) One
Mult_1 = ?

Mult_2 : Equal (Mult Zero (Plus Three Three)) Zero
Mult_2 = ?

Mult_3 : Equal (Mult Two Three) (Plus Three Three)
Mult_3 = ?</code></pre>
<h4 id="exponentiation"><a class="header" href="#exponentiation">Exponentiation</a></h4>
<p>It is not possible to make it work with <code>Exp (n: Num) (m: Num) : Num</code>. Polymorphism plays a crucial role here. However, choosing the right type to iterate over can be tricky. If you encounter an &quot;inconsistency&quot; error, try iterating over a different type: Num itself is usually problematic.</p>
<pre><code class="language-rust ignore">Exp (n: Num) (m: Num -&gt; Num) : Num
Exp n m = ?

Exp_1 : Equal (Exp Two Two) (Plus Two Two)
Exp_1 = ?

Exp_2 : Equal (Exp Three Two) (Plus (Mult Two (Mult Two Two)) One)
Exp_2 = ?

Exp_3 : Equal (Exp Three Zero) One
Exp_3 = ?</code></pre>
<h4 id="predecessor"><a class="header" href="#predecessor">Predecessor</a></h4>
<pre><code class="language-rust ignore">Pred (n: Num -&gt; Num) : Num
Pred n = ?

Pred_1 : Equal (Pred Zero) (Zero)
Pred_1 = ?

Pred_2 : Equal (Pred Two) (One)
Pred_2 = ?

Pred_3 : Equal (Pred Three) (Two)
Pred_3 = ?</code></pre>
<h4 id="subtraction"><a class="header" href="#subtraction">Subtraction</a></h4>
<pre><code class="language-rust ignore">Sub (n: Num) (m: Num) : Num
Sub n m = ?

Sub_1 : Equal (Sub One Zero) (One)
Sub_1 = ?

Sub_2 : Equal (Sub Two Two) (Sub One One)
Sub_2 = ?

Sub_3 : Equal (Sub Three One) Two
Sub_3 = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logic-in-kind"><a class="header" href="#logic-in-kind">Logic in Kind</a></h1>
<p>In the previous chapters, we saw many examples of factual statements (propositions) and ways to present evidence of their truth (proofs). In particular, we extensively worked with equality propositions in the form <em>e1 = e2</em>, implications <em>(p -&gt; q)</em>, and quantified propositions <em>(x -&gt; P(x))</em>. In this chapter, we will see how Kind can be used to perform other familiar forms of logical reasoning.</p>
<p>Before diving into the details, let's talk a little about the status of mathematical statements in Kind. Remember that Kind is a typed language, which means that every meaningful expression in its world has an associated type. Logical statements are no exception: any statement we try to prove in Kind has a type, namely Type, the type of propositions. We can see this with the type <em>Boolean</em>:</p>
<pre><code class="language-rust ignore">Bool: Type
Bool.true  : Bool
Bool.false : Bool</code></pre>
<p>In the <em>Bool</em> type we have <code>Bool.true</code> and <code>Bool.false</code>. To create the Bool type, we declare that it is a type (Type) and then that <code>Bool.true</code> and <code>Bool.false</code> are of type Bool. Seeing how it is done, it becomes much simpler. We are often intimidated by the &quot;<em>functional</em>&quot; name, but Kind is a very friendly language, we will see more about this later on.</p>
<p>Another possible example is <em>Nat</em>, the natural numbers. Natural numbers are all non-negative integers. That is, they start with the number zero and go to infinity, but do not have decimal values. Therefore, <code>3</code> is a natural number, but <code>3.14</code> is not, just as <code>-3</code> is not. So we know that the natural number is made up of <em>zero</em> and its <em>successors</em>. Let's see how this is in Kind:</p>
<pre><code class="language-rust ignore">Nat: Type
Nat.zero             : Nat
Nat.succ (pred: Nat) : Nat</code></pre>
<p>We notice that the construction is similar to Booleans, but there is an extra element in <code>Nat.succ</code>, which is &quot;<em>(pred: Nat)</em>&quot;, and this is because, while in the other we had only two return options (<em>True</em> or <em>False</em>), now we have an infinity of numbers that the code needs to understand, and there must be a way for the code to stop running (we will see more about this throughout this study), since code that never stops running is code that will never give us the result.</p>
<p>However, in any case, we notice that the structure of <em>Nat</em> is basically the same as <em>Bool</em>, which shows us that we can create any type, as long as we follow the same structure. Let's create the juice type:</p>
<pre><code class="language-rust ignore">Juice : Type
Juice.laranja : Juice
Juice.caju    : Juice</code></pre>
<p>Orange juice has two constructors, <em>Juice.laranja</em> and <em>Juice.caju</em>. This type is fictitious, it did not exist until now, but now we can use it as a type and this shows us that, thanks to Kind's design, we can create an infinity of types, since every type is a function.</p>
<p>Understanding the construction of <em>types</em> will prevent some syntax errors from occurring.</p>
<p>to review, our element <em>Juice</em> is of type Type and <em>Juice.orange</em> is of type <em>Juice</em>. Thus, in layman's terms, the element is to the right of the colon and the type is to the left:</p>
<pre><code class="language-rust ignore">element : Type</code></pre>
<p>As previously mentioned, even types are functions, so we can have a function as a type. For example:</p>
<pre><code class="language-rust ignore">Problem : Equal Bool Bool.true Bool.true</code></pre>
<p>We can see that we have an element called &quot;<em>Problem</em>&quot; and it is of type &quot;<em>(Equal Bool Bool.true Bool.true)</em>&quot;. We have seen this structure several times in the past chapters, and it is now easy to understand that this function is a type and, just as <strong>we don't write</strong> it, we <strong>cannot</strong> simply copy the function to the constructors of this type.</p>
<pre><code class="language-rust ignore">Suco: Type
Suco.laranja : Type</code></pre>
<p><em>Juice</em> is of type <em>Type</em>, but <em>Juice.orange</em> is not of type <em>Type</em>, it is of type <em>Juice</em>.</p>
<p>But be aware that all syntactically well-formed propositions have type Type in Kind, regardless of whether they are true or not. Simply being a proposition is one thing; being demonstrable is another thing!</p>
<p>In fact, propositions do not just have types: they are first-class objects that can be manipulated in the same way as other entities in the world of Kind. So far, we have seen a primary location where propositions can appear: in the type signatures of functions.</p>
<pre><code class="language-rust ignore">Plus_2_2_is_4 : Equal (Plus 2n 2n) 4n
Plus_2_2_is_4 = Equal.refl</code></pre>
<p>But propositions can be used in many other ways. For example, we can give a name to a proposition as a value in its own right, just as we gave names to expressions of other types.</p>
<pre><code class="language-rust ignore">Plus_fact : Type
Plus_fact = Equal (Plus 2n 2n) 4n</code></pre>
<p>Later, we can use this name in any situation where a proposition is expected - for example, in a function declaration.</p>
<pre><code class="language-rust ignore">Plus_fact_is_true : Plus_fact
Plus_fact_is_true = Equal.refl</code></pre>
<p>We can also write parameterized propositions - that is, functions that take arguments of some type and return a proposition. For example, the following function takes a number and returns a proposition asserting that this number is equal to three:</p>
<pre><code class="language-rust ignore">Is_three (n: Nat) : Type
Is_three n = Equal Nat n 3n</code></pre>
<p>In Kind, functions that return propositions are said to define properties of their arguments.
For example, here is a (polymorphic) property that defines the familiar notion of an injective function:</p>
<pre><code class="language-rust ignore">Injective &lt;a&gt; &lt;b&gt; (f: a -&gt; b) : Type
Injective a b f = (x: a) -&gt; (y: a) -&gt; (e: Equal b (f x) (f y)) -&gt; (Equal a x y)</code></pre>
<p>We can instantiate a rule of injectivity with</p>
<pre><code class="language-rust ignore">Nat.succ_injective : Injective ((x: Nat) =&gt; Nat.succ x)
Nat.succ_injective =
  (a: Nat) =&gt;
  (b: Nat) =&gt;
  (e: Equal Nat (Nat.succ a) (Nat.succ b)) =&gt;
  Equal.apply (x =&gt; Nat.pred x) e</code></pre>
<!-- e criar tipos que precisam de injetividade com

```rust,ignore
type Injective <a: Type> <b: Type> (f: a -> b) {
  new (p: Nat.succ_injective f)
}

InjectiveNat : Injective (n => Nat.succ n)
InjectiveNat = Injective.new Nat.succ_injective
``` -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="logical-connectives"><a class="header" href="#logical-connectives">Logical Connectives</a></h2>
<h3 id="conjunction"><a class="header" href="#conjunction">Conjunction</a></h3>
<p>The conjunction (logical &quot;<em>and</em>&quot;) in kind takes two propositions <em>a</em> and <em>b</em>, which should return a <em>Boolean</em> value <code>true</code> or <code>false</code>.</p>
<pre><code class="language-rust ignore">Bool.and (a: Bool) (b: Bool) : Bool
Bool.and Bool.true  b = b
Bool.and Bool.false b = Bool.false</code></pre>
<p>If <em>a</em> is true, it is sufficient to return the value of <em>b</em>. However, if <em>a</em> is false, there is no need to verify the value of the second element.</p>
<p>Because it is a limited case (there are only two options), it is possible to verify with a simple proof:</p>
<pre><code class="language-rust ignore">ConjuntiveBool : Equal Bool (Bool.and Bool.true Bool.false) Bool.false
ConjuntiveBool = Equal.refl</code></pre>
<h4 id="and_exercise"><a class="header" href="#and_exercise">And_exercise</a></h4>
<pre><code class="language-rust ignore">And_exercise : Pair (Equal (Plus 3n 4n) 7n) (Equal (Mult 2n 2n) 4n)
And_exercise = ?</code></pre>
<p>Both for proving conjunctive statements. To go in the other direction – that is, to use a conjunctive hypothesis to help prove something else – we employ pattern matching.</p>
<p>If the proof context contains a hypothesis h of the form (a,b), the case division will replace it with a pattern of pairs (a,b).</p>
<pre><code class="language-rust ignore">And_example2 (n: Nat) (m: Nat) (e: Pair (Equal n 0n) (Equal m 0n)) : Equal (Plus n m ) 0n
And_example2 Nat.zero Nat.zero e        = Equal.refl
And_example2 Nat.zero (Nat.succ m ) e   = 
    let p = (Equal.rewrite
    (Pair.snd e)
    (x =&gt; match Nat x {
        zero =&gt; Empty
        succ =&gt; Unit
    })
    (Unit.new))
    Empty.absurd p
And_example2 (Nat.succ n) m e           =
    let p = (Equal.rewrite
    (Pair.fst e)
    (x =&gt; match Nat x {
        zero =&gt; Empty
        succ =&gt; Unit 
    })
    (Unit.new))
    Empty.absurd p</code></pre>
<p>You may wonder why we bother to group the two hypotheses <em>n = 0</em> and <em>m = 0</em> into a single conjunction, since we could also have declared the theorem with two separate premises:</p>
<pre><code class="language-rust ignore">And_example2a (n: Nat) (m: Nat) (e1: Equal n 0n) (e2: Equal m 0n) : Equal (Plus n m) 0n
And_example2a Nat.zero Nat.zero e1 e2        = Equal.refl
And_example2a Nat.zero (Nat.succ m ) e1 e2   = 
    let p = (Equal.rewrite
    (e2)
    (x =&gt; match Nat x {
        zero =&gt; Empty
        succ =&gt; Unit
    })
    (Unit.new))
    Empty.absurd p
And_example2a (Nat.succ n) m e1 e2           =
    let p = (Equal.rewrite
    (e1)
    (x =&gt; match Nat x {
        zero =&gt; Empty
        succ =&gt; Unit 
    })
    (Unit.new))
    Empty.absurd p
</code></pre>
<p>For this theorem, both formulations are adequate. But it is important to understand how to work with conjunctive hypotheses because conjunctions often arise from intermediate steps in proofs, especially in larger developments. Here is a simple example:</p>
<pre><code class="language-rust ignore">And_example3 (n: Nat) (m: Nat) (e: Equal (Plus n m) 0n) : Equal (Mult n m) 0n
And_example3 Nat.zero m e =  Equal.refl
And_example3 (Nat.succ n) m e =
    let p = (Equal.rewrite 
        (e)
        (x =&gt; match Nat x {
            zero =&gt; Empty 
            succ =&gt; Unit                      
        })
        (Unit.new))
    Empty.absurd p</code></pre>
<p>Another common situation with conjunctions is that we know (a,b), but in some context we need only a (or only b). The following theorems are useful in such cases:</p>
<pre><code class="language-rust ignore">Proj1 &lt;p&gt; &lt;q&gt; (a: Pair p q) : p
Proj1 (Pair.new fst snd)    = fst</code></pre>
<h4 id="proj2"><a class="header" href="#proj2">Proj2</a></h4>
<pre><code class="language-rust ignore">Proj2 &lt;p&gt; &lt;q&gt; (b: Pair p q) : q
Proj2 (Pair.new fst snd)    = ?</code></pre>
<p>Finally, sometimes we need to rearrange the order of the conjunctions and/or group the conjunctions of multiple paths. The following commutativity and associativity theorems are useful in such cases.</p>
<pre><code class="language-rust ignore">And_commut &lt;p&gt; &lt;q&gt; (c: Pair p q) : Pair q p
And_commut (Pair.new fst snd)    = Pair.new snd fst</code></pre>
<h4 id="and_assoc"><a class="header" href="#and_assoc">And_assoc</a></h4>
<pre><code class="language-rust ignore">And_assoc &lt;p&gt; &lt;q&gt; &lt;r&gt; (a: Pair p (Pair q r))  : Pair (Pair p q) r
And_assoc (Pair.new p (Pair q r) fst (Pair.new snd trd)) = ?</code></pre>
<h3 id="disjunção"><a class="header" href="#disjunção">Disjunção</a></h3>
<p>Another important connective is the disjunction, or logical &quot;<em>or</em>&quot;, of two propositions:</p>
<p><code>Either a b</code> is true when either <em>a</em> or <em>b</em> is <em>true</em>. The first case was marked with <em>left</em>, and the second with <em>right</em>.</p>
<p>To use a disjunctive hypothesis in a proof, we proceed by case analysis, which, as for Nat or other data types, can be done with pattern matching. Here is an example:</p>
<pre><code class="language-rust ignore">Or_example (n: Nat) (m: Nat) (e: (Either (Equal n 0n) (Equal m 0n))) : Equal (Mult n m) 0n
Or_example Nat.zero m e     = Equal.refl
Or_example n Nat.zero e     = Mult_0_r n
Or_example (Nat.succ n) m (Either.left l r val) = 
    let p = (Equal.rewrite
        (val)
        ( x =&gt; match Nat x {
            zero =&gt; Empty 
            succ =&gt; Unit            
        })
        (Unit.new))
    Empty.absurd p
Or_example (Nat.succ n) (Nat.succ m) (Either.right l r val) = 
    let p = (Equal.rewrite 
        (val)
        ( x =&gt; match Nat x {
            zero =&gt; Empty
            succ =&gt; Unit                   
        })
        (Unit.new))
Empty.absurd p</code></pre>
<p>Conversely, to show that a disjunction is valid, we need to show that one of its sides is valid. This can be done through the Left and Right constructors mentioned above. Here is a trivial use...</p>
<pre><code class="language-rust ignore"><span class="boring">axiom
</span>Or_intro_left &lt;a&gt; &lt;b&gt; (t: a) : Either a b
Or_intro_left t = Either.left t

<span class="boring">axiom
</span>Or_intro_right &lt;a&gt; &lt;b&gt; (t: b) : Either a b
Or_intro_right t = Either.right t</code></pre>
<p>... and a slightly more interesting example requiring both.</p>
<pre><code class="language-rust ignore">Zero_or_succ (n: Nat)     : Either (Equal n 0n) (Equal n (Nat.succ (Nat.pred n)))
Zero_or_succ Nat.zero     = Either.left  Equal.refl
Zero_or_succ (Nat.succ n) = Either.right Equal.refl</code></pre>
<h4 id="mult_eq_0"><a class="header" href="#mult_eq_0">Mult_eq_0</a></h4>
<pre><code class="language-rust ignore"><span class="boring">axiom
</span>Mult_eq_0 (n: Nat) (m: Nat) (e: Equal (Mult n m) 0n) : Either (Equal n 0n) (Equal m 0n)
Mult_eq_0 n m e = ?</code></pre>
<h4 id="or_commut"><a class="header" href="#or_commut">Or_commut</a></h4>
<pre><code class="language-rust ignore">Or_commut &lt;p&gt; &lt;q&gt; (e: Either p q) : Either q p
Or_commut e: ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="falsehood-and-negation"><a class="header" href="#falsehood-and-negation">Falsehood and Negation</a></h2>
<p>Up until now, we have mainly been concerned with proving that certain things are true - addition is commutative, list concatenation is associative, etc. Of course, we may also be interested in negative results, showing that certain propositions are not true. In Kind, such negative statements are expressed with the negation type-level function <code>Not</code>.</p>
<p>To see how negation works, recall the discussion of the principle of explosion from the previous chapter; it states that if we assume a contradiction, then any other proposition can be derived. Following this intuition, we could define <code>Not p</code> as <code>q -&gt; (p -&gt; q)</code>. Kind actually makes a slightly different choice, defining <code>Not</code> as <code>p -&gt; Empty</code>, where Empty is a specific contradictory proposition defined in the standard library as a data type with no constructors.</p>
<pre><code class="language-rust ignore">Empty: Type

Not &lt;p: Type&gt;: Type
Not p = p -&gt; Empty</code></pre>
<p>Since <em>Empty</em> is a contradictory proposition, the principle of explosion also applies to it. If we obtain <em>Empty</em> in the proof context, we can call it <em>Empty</em> or absurd to complete any goal:</p>
<pre><code class="language-rust ignore">Ex_falso_quodlibet &lt;p&gt; : Empty -&gt; p
Ex_falso_quodlibet p   = e =&gt; Empty.absurd e</code></pre>
<p>The <em>Latin phrase ex falso quodlibet</em> literally means &quot;from falsehood, anything follows&quot;; this is another common name for the principle of explosion.</p>
<h4 id="not_implies_our_not"><a class="header" href="#not_implies_our_not">Not_implies_our_not</a></h4>
<p>Show that the definition of negation in Kind implies the intuitive one mentioned above:</p>
<pre><code class="language-rust ignore">Not_implies_our_not &lt;p&gt; &lt;q&gt; (e: Not p) : q -&gt; (p -&gt; q)
Not_implies_our_not p q e = ?</code></pre>
<p>This is how we use Not to assert that 0 and 1 are different elements of Nat:</p>
<pre><code class="language-rust ignore">Zero_not_one : Not (Equal Nat.zero (Nat.succ Nat.zero))
Zero_not_one = 
  (emp =&gt; 
    let app = Equal.apply (x =&gt; Nat.is_zero x) emp
    Equal.rewrite app (e =&gt; if e {Nat} else {Empty}) Nat.zero)</code></pre>
<p>It takes a bit of practice to get used to working with negation in Kind. Even if you can see perfectly well why a statement involving negation is true, it can be a bit tricky at first to get things set up in the right way so that Kind can understand! Here are proofs of some familiar facts to warm you up:</p>
<pre><code class="language-rust ignore">Not_false : Not Empty
Not_false = e =&gt; Empty.absurd e

Contradiction_implies_anythig &lt;p&gt; &lt;q&gt; (a: Pair p (Not p)) : q
Contradiction_implies_anythig p q (Pair.new fst snd) =
  let app = snd fst
  Empty.absurd app
</code></pre>
<h4 id="double_neg_inf"><a class="header" href="#double_neg_inf">Double_neg_inf</a></h4>
<p>Write an informal proof of Double_neg:</p>
<p>Theorem: If p, then (not (not p)), for any proposition p.</p>
<h4 id="contrapositive"><a class="header" href="#contrapositive">Contrapositive</a></h4>
<pre><code class="language-rust ignore">Contrapositive &lt;p&gt; &lt;q&gt; (f: p -&gt; q) : (Not q -&gt; Not p)
Contrapositive p q f = ?</code></pre>
<h4 id="not_both_true_and_false"><a class="header" href="#not_both_true_and_false">Not_both_true_and_false</a></h4>
<pre><code class="language-rust ignore">Not_both_true_and_false &lt;p&gt; : Not (Pair p (Not p))
Not_both_true_and_false p = ?</code></pre>
<p>Similarly, since inequality involves negation, it takes a bit of practice to work with it fluently. Here's a useful trick. If you're trying to prove a goal that is absurd (e.g., the final state is Bool.false = Bool.true), apply Empty.absurd to change the goal to Empty. This makes it easier to use assumptions of the form (Not p) that may be available in the context - in particular, assumptions of the form Not (x = y).</p>
<pre><code class="language-rust ignore">Not_true_is_false (b: Bool) (e: Not (Equal Bool b Bool.true)) : Equal Bool b Bool.false
Not_true_is_false Bool.false e = Equal.refl
Not_true_is_false Bool.true e = Empty.absurd (e Equal.refl)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="truth"><a class="header" href="#truth">Truth</a></h2>
<p>In addition to <em>Empty</em>, the standard library of Kind also defines Unit, a proposition that is trivially true. To prove this, we use the constant:</p>
<pre><code class="language-rust ignore">True_is_true : Unit
True_is_true = Unit.new</code></pre>
<p>Unlike <em>Empty</em>, which is widely used, <code>Unit</code> is rarely used in proofs since it is trivial (and therefore uninteresting) to prove as a goal and carries no useful information as a hypothesis. However, it can be quite useful when defining complex proofs using conditionals or as a parameter for higher-order proofs. We will see examples of this use of <code>Unit</code> later.</p>
<h2 id="logical-equivalence"><a class="header" href="#logical-equivalence">Logical Equivalence</a></h2>
<p>Logical Equivalence. The useful connective &quot;if and only if&quot;, which asserts that two propositions have the same truth value, is just the conjunction of two implications.</p>
<pre><code class="language-rust ignore">record Equivalence (p: Type) (q: Type) {
 lft: p -&gt; q 
 rgt: q -&gt; p
}</code></pre>
<pre><code class="language-rust ignore">Equivalence.lft &lt;p&gt; &lt;q&gt; (e: Equivalence p q) : p 
Equivalence.lft (Equivalence.new l r)        = r (Equivalence.rgt (Equivalence.new l r))

Equivalence.rgt &lt;p&gt; &lt;q&gt; (e: Equivalence p q) : q 
Equivalence.rgt (Equivalence.new l r)        = l (Equivalence.lft (Equivalence.new l r))</code></pre>
<pre><code class="language-rust ignore">Not_true_iff_false (b: Bool) : Equivalence (Not (Equal Bool b Bool.true)) (Equal Bool b Bool.false)
Not_true_iff_false  b = Equivalence.new (x =&gt; Not_true_is_false b x) (y =&gt; Not_true_and_false b y)</code></pre>
<pre><code class="language-rust ignore">Not_true_and_false (b : Bool) (e: Equal Bool b Bool.false) : Not (Equal Bool b Bool.true)
Not_true_and_false Bool.false Equal.refl = 
 emp =&gt; 
 let p = Equal.rewrite emp
   (x =&gt; match Bool x {
    true =&gt; Empty
    false =&gt; Unit
    }) 
    (Unit.new)
 Empty.absurd p
Not_true_and_false Bool.true e = 
 let p = Equal.rewrite e 
  (x =&gt; if x 
  {Unit} 
  else 
  {Empty}) 
 (Unit.new)
 Empty.absurd p</code></pre>
<h3 id="symmetry"><a class="header" href="#symmetry">Symmetry</a></h3>
<p>A relation is symmetric if, for all elements p and q in its domain, if p is equivalent to q, then q is equivalent to p. This can be proved with the following rule:</p>
<pre><code class="language-rust ignore">Equivalence.mirror &lt;p&gt; &lt;q&gt; (e: Equivalence p q) : Equivalence q p
Equivalence.mirror p q (Equivalence.new lft rgt) = (Equivalence.new rgt lft)</code></pre>
<h3 id="reflexivity"><a class="header" href="#reflexivity">Reflexivity</a></h3>
<p>A relation is reflexive if, for every element p in its domain, p is equivalent to itself. This can be proved with the following rule:</p>
<pre><code class="language-rust ignore">Equivalence.refl &lt;p&gt; : Equivalence p p
Equivalence.refl p = ?</code></pre>
<h3 id="transitivity"><a class="header" href="#transitivity">Transitivity</a></h3>
<p>A relation is transitive if, for all elements p, q, and r in its domain, if p is equivalent to q and q is equivalent to r, then p is equivalent to r. This can be proved with the following rule:</p>
<pre><code class="language-rust ignore">Equivalence.chain &lt;p&gt; &lt;q&gt; &lt;r&gt; (e0: Equivalence p q) (e1: Equivalence q r) : Equivalence p r
Equivalence.chain p q r e0 e1 = ?</code></pre>
<h4 id="or_distributes_over_and"><a class="header" href="#or_distributes_over_and">Or_distributes_over_and</a></h4>
<pre><code class="language-rust ignore">Or_distributes_over_and &lt;p&gt; &lt;q&gt; &lt;r&gt; : Equivalence (Either p (Pair q r)) (Pair (Either p q) (Either p r))
Or_distributes_over_and p q r = ?</code></pre>
<p>A special form of equivalence, avoiding the need for some low-level proof state manipulation. In particular, rewrite and reflexivity can be used with iff assertions, not just equalities.
Here's a simple example demonstrating how these tactics work with iff. First, let's prove some basic iff equivalences:</p>
<pre><code class="language-rust ignore">Mult_0 (n: Nat) (m: Nat) : Equivalence (Equal Nat (Mult n m) 0n) (Either (Equal Nat n 0n) (Equal Nat m 0n))
Mult_0 n m = Equivalence.new (x =&gt; To_mult_0 n m x) (y =&gt; Or_example n m y)

To_mult_0 (n: Nat) (m: Nat) (e: Equal Nat (Mult n m) 0n) : (Either (Equal Nat n 0n) (Equal Nat m 0n))
To_mult_0 Nat.zero Nat.zero Equal.refl = Either.right Equal.refl
To_mult_0 Nat.zero (Nat.succ m) Equal.refl = Either.left Equal.refl
To_mult_0 (Nat.succ n) Nat.zero e = Either.right Equal.refl
To_mult_0 (Nat.succ n) (Nat.succ m) e = 
  let a = Plus_comm (Mult n (Nat.succ m)) (Nat.succ m)
  let b = Equal.chain (Equal.mirror e) a
  let c = (Equal.rewrite b
   (x =&gt; match Nat x {
    zero =&gt; Unit
    succ =&gt; Empty
    })
    (Unit.new)) 
  Empty.absurd c</code></pre>
<pre><code class="language-rust ignore">Or_assoc &lt;p&gt; &lt;q&gt; &lt;r&gt; : Equivalence (Either p (Either q r)) (Either (Either p q) r)
Or_assoc = Equivalence.new (x =&gt; To_or_assoc x) (y =&gt; Fro_or_assoc y)

To_or_assoc &lt;p&gt; &lt;q&gt; &lt;r&gt; (e: Either p (Either q r)) : Either (Either p q) r
To_or_assoc (Either.left e) = Either.left (Either.left e)
To_or_assoc (Either.right p (Either q r) (Either.left e)) = Either.left (Either.right e)
To_or_assoc (Either.right p (Either q r) (Either.right e)) = Either.right e

Fro_or_assoc &lt;p&gt; &lt;q&gt; &lt;r&gt; (e: Either (Either p q) r) : Either p (Either q r)
Fro_or_assoc (Either.left (Either p q) r (Either.left e)) = Either.left e
Fro_or_assoc (Either.left (Either p q) r (Either.right e)) = Either.right (Either.left e)
Fro_or_assoc (Either.right (Either p q) r e) = Either.right (Either.right e)</code></pre>
<p>Now we can use these facts with Equal.rewrite and Equal.refl to provide smooth proofs of assertions involving equivalences. Here's a ternary version of the previous result of Mult_0:</p>
<pre><code class="language-rust ignore">Mult_0_3 (n: Nat) (m: Nat) (p: Nat) : Equivalence (Equal Nat (Mult n (Mult m p)) 0n) (Either (Equal Nat n 0n) (Either (Equal Nat m 0n) (Equal Nat p 0n)))
Mult_0_3 n m p = Equivalence.new (x =&gt; To_mult_0_3 n m p x) (y =&gt; Fro_mult_0_3 n m p y)

To_mult_0_3 (n: Nat) (m: Nat) (p: Nat) (e: (Equal Nat (Nat.mul n (Nat.mul m p)) 0n)) : (Either (Equal Nat n 0n) (Either (Equal Nat m 0n) (Equal Nat p 0n)))
To_mult_0_3 n m p e = Either.swap (Equivalence.rgt (Or_assoc (Equal m 0n) (Equal p 0n) (Equal n 0n)))

Fro_mult_0_3 (n: Nat) (m: Nat) (p: Nat) (e: Either (Equal Nat n 0n) (Either (Equal Nat m 0n) (Equal Nat p 0n))) : (Equal Nat (Mult n (Mult m p)) 0n)
Fro_mult_0_3 (n: Nat) (m: Nat) (p: Nat) (e: Either (Equal Nat n 0n) (Either (Equal Nat m 0n) (Equal Nat p 0n))) : (Equal Nat (Nat.mul n (Nat.mul m p)) 0n)
Fro_mult_0_3 Nat.zero m p (Either.left Equal.refl) = Equal.refl
Fro_mult_0_3 n Nat.zero p (Either.right a (Either b c) (Either.left Equal.refl)) = Mult_comm 0n n
Fro_mult_0_3 n m Nat.zero (Either.right a (Either b c) (Either.right Equal.refl)) = Equal.chain (Mult_assoc n m 0n) (Mult_0_r (Nat.mul n m))
Fro_mult_0_3 (Nat.succ n) m p (Either.left e) = 
 let p = (Equal.rewrite 
   e
   (x =&gt; match Nat x {
    zero =&gt; Empty
    succ =&gt; Unit
    }) 
    (Unit.new)) 
  Empty.absurd p
Fro_mult_0_3 n (Nat.succ m) p (Either.right a (Either b c) (Either.left e)) = 
 let p = (Equal.rewrite 
   e
   (x =&gt; match Nat x {
    zero =&gt; Empty
    succ =&gt; Unit
    }) 
    (Unit.new)) 
  Empty.absurd p
Fro_mult_0_3 n m (Nat.succ p) (Either.right a (Either b c) (Either.right e)) = 
 let p = (Equal.rewrite 
   e
   (x =&gt; match Nat x {
    zero =&gt; Empty
    succ =&gt; Unit
    }) 
    (Unit.new)) 
  Empty.absurd p</code></pre>
<p>The apply tactic can also be used with equivalence. When given an equivalence as its argument, apply tries to guess which side of the equivalence to use.</p>
<pre><code class="language-rust ignore">Apply_iff_example (n: Nat) (m: Nat) (e: Equal Nat (Mult n m) 0n) : Either (Equal Nat n 0n) (Equal Nat m 0n) 
Apply_iff_example n m e = Equivalence.rgt (Mult_0 n m)
</code></pre>
<h2 id="existential-quantification"><a class="header" href="#existential-quantification">Existential Quantification</a></h2>
<p>Another important logical connective is existential quantification. To say that there is some x of type Type such that some property p is true for x, we write <code>(Sigma x p)</code>.</p>
<pre><code class="language-rust ignore">record Sigma (x: Type) (p: x -&gt; Type) {
  fst : x
  snd : (p fst)
}</code></pre>
<ul>
<li><em>Currently, the Kind-lang has a compiler bug that is affecting the lambda application of Sigma.</em></li>
</ul>
<p>To prove a statement of the form (Sigma x p), we must show that p is true for some specific choice of value for x, known as the existential witness. This is done in two steps: First, we explicitly inform Kind of the witness x we have in mind by writing it in the first parameter. Then, we prove that p is true after all occurrences of x are replaced with Type.</p>
<pre><code class="language-rust ignore">Four_is_even : Sigma Nat (n =&gt; (Equal Nat 4n (Nat.add n n)))
Four_is_even = $ 2n Equal.refl</code></pre>
<p>On the other hand, if we have an existential hypothesis (Sigma x p) in the context, we can pattern match on it to obtain a witness x and a hypothesis asserting that p is true for x.</p>
<pre><code class="language-rust ignore">Exists_example_2 (n: Nat) (m: Sigma Nat (m =&gt; (Equal Nat n (Nat.add 4n m)))) : Sigma Nat (o =&gt; (Equal Nat n (Nat.add 2n o)))
Exists_example_2 n (Sigma.new Nat s fst snd) = Sigma.new fst ?</code></pre>
<h4 id="dist_not_exists"><a class="header" href="#dist_not_exists">Dist_not_exists</a></h4>
<p>Prove that &quot;p is true for all x&quot; implies &quot;there is no x for which p is not true&quot;</p>
<pre><code class="language-rust ignore">Dist_not_exists &lt;a&gt; &lt;p: a -&gt; Type&gt; (f: (x: a) -&gt; (p x)) : Not (Sigma a (x =&gt; ( Not (p x))))
Dist_not_exists a p f = ?</code></pre>
<h4 id="dist_exists_or"><a class="header" href="#dist_exists_or">Dist_exists_or</a></h4>
<p>Prove that existential quantification distributes over disjunction.</p>
<pre><code class="language-rust ignore">Dist_exists_or &lt;a&gt; &lt;p: a -&gt; Type&gt; &lt;q: a -&gt; Type&gt; : Equivalence (Sigma a (x =&gt; (Either (p x) (q x)))) (Either (Sigma a (x =&gt; (p x))) (Sigma a (x =&gt; (q x))))
Dist_exists_or a p q = ?dist_exists_or_rhs</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="propositional-programming"><a class="header" href="#propositional-programming">Propositional programming</a></h1>
<p>The logical connectives we have seen provide a rich vocabulary for defining complex propositions from simpler ones. To illustrate, let's see how to express the statement that an element x occurs in a List l. Note that this property has a simple recursive structure:</p>
<ul>
<li>If l is the empty list, then x cannot occur in it, so the property &quot;x appears in l&quot; is simply false.</li>
<li>Otherwise, l has the form <em>List.cons head tail</em>. In this case, x occurs in l if it is equal to head or if it occurs in tail.</li>
</ul>
<p>We can translate this directly into a simple recursive function that takes an element and a List and returns a proposition:</p>
<pre><code class="language-rust  ignore">In &lt;a&gt; (x: a) (l: List a)    : Type
In a x List.nil              = Empty
In a x (List.cons head tail) = Either (Equal a x head) (In a x tail) </code></pre>
<p>When In is applied to a concrete list, it expands into a concrete sequence of nested disjunctions.</p>
<pre><code class="language-rust  ignore">In_example_1 : In 4n [1n, 2n, 3n, 4n, 5n]
In_example_1 = (Either.right (Either.right (Either.right (Either.left Equal.refl))))

In_example_2 (n: Nat) (i: In n [2n, 4n]) : Sigma Nat (m =&gt; Equal Nat n (Nat.mul 2n m))
In_example_2 n (Either.left e)                                  = $ 1n e
In_example_2 n (Either.right l (Either rl rr) (Either.left e))  = $ 2n e
In_example_2 n (Either.right l (Either rl rr) (Either.right e)) = Empty.absurd e</code></pre>
<p>We can also prove more generic and higher-level lemmas about In. Note, in the next example, how In starts being applied to a variable and is only expanded when we do case analysis on that variable:</p>
<pre><code class="language-rust  ignore">In_map &lt;a&gt; &lt;b&gt; (f: a -&gt; b) (l: List a) (x: a) (i: In x l) : In (f x) (List.map l f) 
In_map a b f (List.nil) x i = Empty.absurd i
In_map a b f (List.cons head tail) x (Either.right e) = Either.right (In_map f tail x e)
In_map a b f (List.cons head tail) x (Either.left e)  = 
    (Equal.rewrite e 
    (y =&gt; (Either (Equal (f x) (f y)) (In (f x) (List.map tail f)))) 
    (Either.left Equal.refl))</code></pre>
<p>This way of defining propositions recursively, while convenient in some cases, also has some disadvantages. In particular, it is subject to the usual Kind restrictions on the definition of recursive functions, for example, the requirement that they be &quot;obviously terminating&quot;. In the next chapter, we will see how to define propositions inductively, a different technique with its own set of strengths and limitations.</p>
<h4 id="in_map_equiv"><a class="header" href="#in_map_equiv">In_map_equiv</a></h4>
<pre><code class="language-rust  ignore">In_map_equiv &lt;a&gt; &lt;b&gt; (f: a -&gt; b) (l: List a) (y: b) :
   Equivalence (In y (List.map l f)) (Sigma a (x =&gt; (Pair (Equal (f x) y) (In x l))))
In_map_equiv a b f l y = ?</code></pre>
<h4 id="in_app_equiv"><a class="header" href="#in_app_equiv">In_app_equiv</a></h4>
<pre><code class="language-rust  ignore">In_app_equiv &lt;a&gt; (x: a) (l1: List a) (l2: List a) :
  (Equivalence (In x (List.concat l1 l2)) (Either (In x l1) (In x l2)))
In_app_equiv a x l1 l2 = ?</code></pre>
<h4 id="all"><a class="header" href="#all">All</a></h4>
<p>Remember that functions that return propositions can be seen as properties of their arguments. For example, if <em>p</em> has type <code>Nat -&gt; Type</code>, then <code>p n</code> asserts that the property <code>p</code> is true for <code>n</code>.</p>
<p>Inspired by <em>In</em>, write a recursive function <em>All</em> asserting that some property <em>p</em> is true for all elements of a <em>List l</em>. To ensure that your definition is correct, prove the lemma <em>All_In</em> below. (Of course, your definition should not just repeat the left-hand side of <em>All_In</em>.)</p>
<pre><code class="language-rust  ignore">All &lt;t&gt; (p: t -&gt; Type) (l: List t)  : Type
All t p l = ?

All_in &lt;t&gt; (p: t -&gt; Type) (l: List t) : Equivalence ((x: t) -&gt; (i: In x l) -&gt; p x) (All p l)
All_in t p l = ?</code></pre>
<h4 id="combine_odd_even"><a class="header" href="#combine_odd_even">Combine_odd_even</a></h4>
<p>Complete the definition of the function combine_odd_even below. It takes as arguments two properties of numbers, podd and peven, and should return a property p such that p n is equivalent to podd n when n is odd and equivalent to peven n otherwise</p>
<pre><code class="language-rust  ignore">Combine_odd_even (podd: Nat -&gt; Type) (peven: Nat -&gt; Type) : Nat -&gt; Type
Combine_odd_even podd peven = ?</code></pre>
<p>To test your definition, prove the following theorems:</p>
<pre><code class="language-rust  ignore">Combine_odd_even_intro
  (n: Nat)
  (podd:  Nat -&gt; Type)
  (peven: Nat -&gt; Type)
  (p1: (Equal (Nat.is_odd n) Bool.true)  -&gt; podd  n)
  (p2: (Equal (Nat.is_odd n) Bool.false) -&gt; peven n) : (Combine_odd_even (podd) (peven)) n
Combine_odd_even_intro n podd peven p1 p2 = ?

Combine_odd_even_elim_odd
  (n: Nat)
  (podd:  Nat -&gt; Type)
  (peven: Nat -&gt; Type)
  (p: (Combine_odd_even podd peven) n)
  (e: Equal (Nat.is_odd n) Bool.true) : podd n
Combine_odd_even_elim_odd n podd peven p e = ?

Combine_odd_elim_even
  (n: Nat)
  (podd: Nat -&gt; Type)
  (peven: Nat -&gt; Type)
  (p: (Combine_odd_even podd peven) n)
  (e: Equal (Nat.is_odd n) Bool.false) : peven n
Combine_odd_elim_even n podd peven p e = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="applying-theorems-to-arguments"><a class="header" href="#applying-theorems-to-arguments">Applying Theorems to Arguments</a></h1>
<p>A characteristic of Kind that distinguishes it from many other proof assistants is that it treats proofs as first-class objects.</p>
<p>There is much to be said about this, but it is not necessary to understand in detail to use Kind. This section offers only a sample, while a deeper exploration can be found in the <em>ProofObjects</em> chapter.</p>
<p>We saw that we can use the <em>check</em> command to ask Kind to print the type of an expression. We can also use check to ask which theorem a particular identifier refers to.</p>
<pre><code class="language-rust  ignore">PlusCommutative (m: Nat) (n: Nat) : Equal (Nat.add n m) (Nat.add m n)
PlusCommutative m n = ?</code></pre>
<p>Kind prints the statement of the plusCommutative theorem in the same way it prints the type of any term we ask it to check. Why?</p>
<p>The reason is that the identifier plusCommutative actually refers to a proof object - a data structure that represents a logical derivation establishing the truth of the statement <em>(n: Nat) (m: Nat) : n + m = m + n</em>. The type of this object is the statement of the theorem of which it is a proof.
Intuitively, this makes sense because the statement of a theorem tells us what we can use it for, just as the type of a computational object tells us what we can do with that object - for example, if we have a term of type <em>Nat -&gt; Nat -&gt; Nat</em>, we can give it two Nats as arguments and get a Nat back. Similarly, if we have an object of type <em>n = m -&gt; n + n = m + m</em> and provide it with an &quot;argument&quot; of type <em>n = m</em>, we can derive <em>n + n = m + m</em>.
Operationally, this analogy goes even further: by applying a theorem, as if it were a function, to hypotheses with corresponding types, we can specialize its result without having to resort to intermediate assertions. For example, suppose we wanted to prove the following result:</p>
<pre><code class="language-rust  ignore">Plus_comm3a: (n: Nat) (m: Nat) (p: Nat) : Equal (Nat.add n (Nat.add m p)) (Nat.add (Nat.add p m) n)</code></pre>
<p>At first glance, it seems like we should be able to prove this by case analysis, for the zero and succ _ cases, but that would give us unnecessary work. Let's see an example:</p>
<pre><code class="language-rust  ignore">Plus_comm3a Nat.zero n p = ?</code></pre>
<p>In this case, our goal is to prove:</p>
<pre><code class="language-bash  ignore">(Equal _ (Nat.add n p) (Nat.add (Nat.add p 0n) n)) 
</code></pre>
<p>But notice, for this we need another proof, that of</p>
<pre><code class="language-bash  ignore">Equal Nat (Nat.add p 0n) p
</code></pre>
<p>To prove this, we would take the following steps:</p>
<pre><code class="language-rust  ignore">Add_n_z (n: Nat)       : (Equal (Nat.add n Nat.zero) n)
Add_n_z Nat.zero       = Equal.refl
Add_n_z (Nat.succ n)   =
     let ind = Add_n_z n
     let app = (Equal.apply (x =&gt; (Nat.succ x)) ind)
     app</code></pre>
<p>Now let's prove:</p>
<pre><code class="language-rust  ignore">Plus_comm3a (n: Nat) (m: Nat) (p: Nat) : Equal (Nat.add n (Nat.add m p)) (Nat.add (Nat.add p m) n)
Plus_comm3a Nat.zero n p = 
  let pzr = Add_z_r p
  let com = Plus_comm n p
  let rwt = Equal.rewrite (Equal.mirror pzr) (x =&gt;(Equal _ (Nat.add n p) (Nat.add (x) n))) com
  rwt</code></pre>
<p>Now we only need to prove it for the case of <em>Nat.succ n</em></p>
<pre><code class="language-rust  ignore">Plus_comm3a (Nat.succ m) n p = ?</code></pre>
<p>and our goal is <code>(Equal _ (Nat.succ (Nat.add m (Nat.add n p))) (Nat.add (Nat.add p n) (Nat.succ m)))</code> and for that we would need other proofs, such as the one that</p>
<pre><code class="language-rust  ignore">Plus_n_sm (n: Nat) (m: Nat) : (Equal Nat (Nat.succ (Nat.add n m))(Nat.add n (Nat.succ m)))
Plus_n_sm Nat.zero m        = Equal.refl
Plus_n_sm (Nat.succ n) m    = (Equal.apply (x =&gt; (Nat.succ x)) (Plus_n_sm n m))</code></pre>
<p>And rewrite in the proof of the commutativity of addition between <em>n</em> and <em>p</em> and then use the proof of commutativity for all of this, a tiring and, I can say, unnecessary job.</p>
<p>Instead of doing case analysis, let's work with them as pure variables, almost without value</p>
<pre><code class="language-rust  ignore">Plus_comm3 (m: Nat) (n: Nat) (p: Nat) : Equal (Nat.add n (Nat.add m p)) (Nat.add (Nat.add p m) n)
Plus_comm3 m n p = ?</code></pre>
<p>Our goal remains <code>(Equal _ (Nat.add n (Nat.add m p)) (Nat.add (Nat.add p m) n))</code> and to understand this, let's analyze our problem and the next steps will be too trivial:</p>
<ul>
<li><em>n + (m + p) = (p + m) + n</em></li>
</ul>
<p>This is exactly the commutativity of addition, so we just need to rewrite our <em>Plus_comm</em> proof twice, one inside the other</p>
<pre><code class="language-rust  ignore">let a = Equal.rewrite (Plus_comm p m) (x =&gt; (Equal (Nat.add n (Nat.add m p)) (Nat.add (x) n))) (Plus_comm3 m n p)</code></pre>
<p>and see what our variable <em>a</em> returns</p>
<pre><code class="language-bash  ignore">(Equal Nat (Nat.add n (Nat.add m p)) (Nat.add (Nat.add m p) n))
</code></pre>
<p>We're almost there, we just need to rewrite the second <em>Plus_comm</em> in the innermost addition on the right-hand side</p>
<pre><code class="language-rust  ignore">let b = Equal.rewrite (Plus_comm m p) (x =&gt; (Equal Nat (Nat.add n (Nat.add m p)) (Nat.add (x) n))) a</code></pre>
<p>and our <em>b</em> is exactly equal to our goal</p>
<pre><code class="language-bash  ignore">(Equal Nat (Nat.add n (Nat.add m p)) (Nat.add (Nat.add p m) n)) 
</code></pre>
<p>The complete proof is:</p>
<pre><code class="language-rust ignore">Plus_comm3 (m: Nat) (n: Nat) (p: Nat) : Equal (Nat.add n (Nat.add m p)) (Nat.add (Nat.add p m) n)
Plus_comm3 m n p = 
  let a = Equal.rewrite (Plus_comm p m) (x =&gt; (Equal (Nat.add n (Nat.add m p)) (Nat.add (x) n))) (Plus_comm3 m n p)
  let b = Equal.rewrite (Plus_comm m p) (x =&gt; (Equal Nat (Nat.add n (Nat.add m p)) (Nat.add (x) n))) a
  b</code></pre>
<p>Much simpler and more elegant, it didn't require so much work, a brief reading of the problem practically gave us the solution. Notice that this was no different from everything we have done so far, it is even a repetition of the previous steps, it is similar to the application of a polymorphic function to an argument of type.</p>
<p>You can &quot;use theorems as functions&quot; in this way with almost all tactics that receive a theorem name as an argument. Note also that theorem application uses the same inference mechanisms as function application; therefore, it is possible, for example, to provide wildcards as arguments to be inferred, or declare some hypotheses of a theorem as implicit by default. These features are illustrated in the proof below.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kind-vs-set-theory"><a class="header" href="#kind-vs-set-theory">Kind vs Set Theory</a></h2>
<p>The logical core of Coq, the Calculus of Inductive Constructions, differs in some important ways from other formal systems used by mathematicians to write precise and rigorous proofs. For example, in the most popular foundation for mathematics in conventional pen-and-paper, Zermelo-Fraenkel set theory (ZFC), a mathematical object can potentially be a member of many different sets; a term in Kind's logic, on the other hand, is a member of at most one type. This difference often leads to slightly different ways of capturing informal mathematical concepts, but these are largely quite natural and easy to work with. For example, instead of saying that a natural number n belongs to the set of even numbers, we would say in Kind that ev n is true, where ev: <code>Nat -&gt; Type</code> is a property that describes even numbers.</p>
<p>However, there are some cases where translating standard mathematical reasoning to Kind can be both laborious and sometimes even impossible, unless we enrich the core logic with additional axioms. We conclude this chapter with a brief discussion of some of the most significant differences between the two worlds.</p>
<h3 id="functional-extensionality"><a class="header" href="#functional-extensionality">Functional Extensionality</a></h3>
<p>The equality statements we have seen so far mainly concern elements of inductive types (Nat, Bool, etc.). But since Kind's equality operator is polymorphic, these are not the only possibilities -- in particular, we can write propositions that assert that two functions are equal to each other:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Function_equality_ex1 : Equal (Nat.succ 3n) (Nat.succ (Nat.pred 4n))
Function_equality_ex1 = Equal.refl
<span class="boring">}</span></code></pre></pre>
<p>In common mathematical practice, two functions f and g are considered equal if they produce the same outputs:</p>
<p>(∀𝑥, 𝑓(𝑥) = 𝑔(𝑥)) → 𝑓 = 𝑔</p>
<p>This is known as the principle of functional extensionality.</p>
<p>Informally, an &quot;extensional property&quot; is one that concerns the observable behavior of an object. Thus, functional extensionality simply means that the identity of a function is completely determined by what we can observe from it -- that is, in terms of Kind, the results we obtain after applying it.</p>
<p>Functional extensionality is not part of Kind's basic axioms. This means that some &quot;reasonable&quot; propositions are not provable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Function_equality_ex2 : Equal ((x: Nat) =&gt; Nat.add x 1n) ((x: Nat) =&gt; Nat.add 1n x)
Function_equality_ex2 = ?
<span class="boring">}</span></code></pre></pre>
<p>However, we can state a theorem and skip its proof or use a hole.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Functional_extensionality &lt;a&gt;&lt;b&gt; (f: a -&gt; b) (g: a -&gt; b) (e: (x: a) -&gt; Equal (f x) (g x)) : Equal f g
<span class="boring">}</span></code></pre></pre>
<p>Now we can invoke functional extensionality in proofs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Function_equality_ex2 : Equal ((x: Nat) =&gt; Nat.add x 1n) ((x: Nat) =&gt; Nat.add 1n x)
Function_equality_ex2 =
  Functional_extensionality ((x: Nat) =&gt; Nat.add x 1n) ((x: Nat) =&gt; Nat.add 1n x) (x =&gt; Plus_comm x 1n)
<span class="boring">}</span></code></pre></pre>
<p>Of course, we should be careful when adding new axioms to Kind's logic, as they may make it inconsistent -- that is, they may make it possible to prove all propositions, including Empty!</p>
<p>Unfortunately, there is no simple way to tell whether an axiom is safe to add: it usually takes hard work to establish the consistency of any particular combination of axioms.</p>
<p>However, it is known that adding functional extensionality, in particular, is consistent.</p>
<h4 id="tr_rev"><a class="header" href="#tr_rev">Tr_rev</a></h4>
<p>A problem with the definition of the list reversal function &quot;rev&quot; we have is that it performs a call to &quot;++&quot; at each step. Executing &quot;++&quot; takes asymptotically linear time in the size of the list, which means that &quot;rev&quot; has quadratic running time.
We can improve this with the following definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Rev_append &lt;x&gt; (l1: List x) (l2: List x)  : List x
Rev_append x List.nil l2                  = l2
Rev_append x (List.cons xs.h xs.t) l2     = Rev_append xs.t (List.cons xs.h l2)

Tr_rev &lt;x&gt; (l: List x) : List x
Tr_rev x l = Rev_append x l List.nil1
<span class="boring">}</span></code></pre></pre>
<p>This version is said to be tail-recursive, because the recursive call to the function is the last operation that needs to be performed (i.e., we don't need to execute ++ after the recursive call); a decent compiler will generate very efficient code in this case. Prove that the two definitions are actually equivalent.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Tr_rev_correct &lt;a&gt; (xs: List a) : Equal (Tr_rev xs) (Rev xs)
Tr_rev_correct a xs = ?
<span class="boring">}</span></code></pre></pre>
<h3 id="propositions-and-booleans"><a class="header" href="#propositions-and-booleans">Propositions and Booleans</a></h3>
<p>We have seen two different ways of encoding logical facts in Kind: with booleans (of type Bool) and with propositions (of type Type).</p>
<p>For example, to assert that a number n is even, we can say that
• (1) evenb n returns True, or
• (2) there exists a k such that <em>n = double k</em>. In fact, these two notions of parity are equivalent, as can be easily shown with a pair of auxiliary lemmas.</p>
<p>We often say that the boolean <em>evenb n</em> reflects the proposition <em>(n =&gt; Equal n (double k))</em>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Evenb_double (k: Nat)     : Equal (Nat.is_even (Nat.double k)) Bool.true
Evenb_double Nat.zero     = Equal.refl
Evenb_double (Nat.succ k) = Evenb_double k
<span class="boring">}</span></code></pre></pre>
<h4 id="evenb_double_conv"><a class="header" href="#evenb_double_conv">Evenb_double_conv</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Evenb_double_conv (n: Nat):
  Sigma Nat (k =&gt; (Equal n (Bool.if (Evenb n) (Nat.double k) (Nat.succ (Nat.double k)))))
Evenb_double_conv n = ?
<span class="boring">}</span></code></pre></pre>
<!-- TODO: terminar `even_bool_prop` -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Even_bool_prop (n: Nat): 
  Equivalence (Equal (Evenb n) Bool.true) (Sigma Nat (k =&gt; Equal n (Nat.double k)))
<span class="boring">}</span></code></pre></pre>
<p>Similarly, to assert that two numbers <em>n</em> and <em>m</em> are equal, we can say (1) that <code>n == m</code> returns <code>Bool.true</code> or (2) that <code>n = m</code>. These two notions are equivalent.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Beq_nat_true_equiv (n1: Nat) (n2: Nat) : Equivalence (Equal (Nat.equal n1 n2) Bool.true) (Equal n1 n2)
Beq_nat_true_equiv n1 n2 = Equivalence.new (x =&gt; To_beq_nat_true n1 n2 x) (y =&gt; Fro_beq_nat_true n1 n2 y)

To_beq_nat_true (n1: Nat) (n2: Nat) (e: Equal (Nat.equal n1 n2) Bool.true) : Equal n1 n2  
To_beq_nat_true Nat.zero Nat.zero Equal.refl = Equal.refl
To_beq_nat_true Nat.zero (Nat.succ n2) e = 
  let emp = (Equal.rewrite e 
    (x =&gt; match Bool x {
      true  =&gt; Empty
      false =&gt; Unit
    })
    (Unit.new))
  Empty.absurd emp
To_beq_nat_true (Nat.succ n1) Nat.zero e = 
  let emp = (Equal.rewrite e 
    (x =&gt; match Bool x {
      true  =&gt; Empty
      false =&gt; Unit
    })
    (Unit.new))
  Empty.absurd emp
To_beq_nat_true (Nat.succ n1) (Nat.succ n2) e = Equal.apply (x =&gt; Nat.succ x) (Extract_equal n1 n2 e)

Fro_beq_nat_true (n1: Nat) (n2: Nat) (e: Equal  n1 n2) : Equal (Nat.equal n1 n2) Bool.true
Fro_beq_nat_true Nat.zero Nat.zero Equal.refl = Equal.refl
Fro_beq_nat_true Nat.zero (Nat.succ n2) e = 
  let emp = (Equal.rewrite e 
    (x =&gt; match Nat x {
      zero =&gt; Unit
      succ =&gt; Empty
    })
    (Unit.new))
  Empty.absurd emp
Fro_beq_nat_true (Nat.succ n1) Nat.zero e = 
  let emp = (Equal.rewrite e 
    (x =&gt; match Nat x {
      zero =&gt; Empty
      succ =&gt; Unit
    })
    (Unit.new))
  Empty.absurd emp
Fro_beq_nat_true (Nat.succ n1) (Nat.succ n2) e =
  let e2  = Succ_n1_n2 n1 n2 e
  let ind = Fro_beq_nat_true n1 n2 e2
  ind

  Succ_n1_n2 (n1: Nat) (n2: Nat) (e : (Equal Nat (Nat.succ n1) (Nat.succ n2))) : Equal Nat n1 n2
Succ_n1_n2 Nat.zero Nat.zero e            = Equal.refl
Succ_n1_n2 (Nat.succ n1) Nat.zero e       = Equal.apply (x =&gt; Nat.pred x) e
Succ_n1_n2 Nat.zero (Nat.succ n2) e       = Equal.apply (x =&gt; Nat.pred x) e
Succ_n1_n2 (Nat.succ n1) (Nat.succ n2) e  = Equal.apply (x =&gt; Nat.pred x) e

Extract_equal (n1: Nat) (n2: Nat) (e: Equal (Nat.equal n1 n2) Bool.true) : Equal n1 n2
Extract_equal Nat.zero Nat.zero (Equal.refl) = Equal.refl
Extract_equal Nat.zero (Nat.succ n2) (e) = 
  let emp = (Equal.rewrite e 
    (x =&gt; match Bool x {
      true  =&gt; Empty
      false =&gt; Unit
    })
    (Unit.new))
  Empty.absurd emp
Extract_equal (Nat.succ n1) Nat.zero (e) = 
  let emp = (Equal.rewrite e 
    (x =&gt; match Bool x {
      true  =&gt; Empty
      false =&gt; Unit
    })
    (Unit.new))
  Empty.absurd emp
Extract_equal (Nat.succ n1) (Nat.succ n2) e = Equal.apply (x =&gt; Nat.succ x) (Extract_equal n1 n2 e)
<span class="boring">}</span></code></pre></pre>
<p>However, while the boolean and propositional formulations of a statement are equivalent from a purely logical point of view, they need not be operationally equivalent. Equality provides an extreme example: knowing that <em>n = m = True</em> is usually of little direct help in the middle of a proof involving n and m; however, if we convert the statement to the equivalent form <em>n = m</em>, we can rewrite it.</p>
<p>The case of even numbers is also interesting. Recall that, when proving the inverse direction of even_bool_prop (i.e., evenb_double, going from the propositional assertion to the boolean one), we used a simple induction on k. On the other hand, the converse (the evenb_double_conv exercise) required some clever generalization, since we cannot directly prove <code>(k =&gt; Equal n (Nat.double k)) = Bool.true</code></p>
<p>For these examples, the propositional assertions are more useful than their boolean counterparts, but this is not always the case. For example, we cannot test whether a general proposition is true or not in a function definition; as a consequence, the following code snippet is rejected:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Is_even_prime : Nat -&gt; Bool
Is_even_prime = (n: Nat) =&gt; Bool.if (Equal n 2n) Bool.true Bool.false
<span class="boring">}</span></code></pre></pre>
<p>Kind complains that <code>n = 2</code> has type Type, while it expects an element of Bool (or some other inductive type with two elements). The reason for this error message has to do with the computational nature of the core language of Kind, which is designed such that every function it can express is computable and total. One reason for this is to allow for the extraction of executable programs from Kind developments. As a consequence, in Kind, Type does not have a universal case analysis operation that says whether a given proposition is true or false, since such an operation would allow for the writing of non-computable functions.</p>
<p>Although non-computable general properties cannot be formulated as boolean computations, it is worth noting that many computable properties are easier to express using Type than Bool, since recursive function definitions are subject to significant restrictions in Kind. For example, the next chapter shows how to define the property that a regular expression matches a given string using Type. Doing the same with Bool would be equivalent to writing a regular expression checker, which would be more complicated, harder to understand, and harder to reason about.</p>
<p>On the other hand, an important additional benefit of stating facts using booleans is enabling some proof automation through computation with terms in Kind, a technique known as reflection proof. Consider the following statement:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Even_1000 : Sigma Nat (k =&gt; Equal 1000n (Nat.double k))
<span class="boring">}</span></code></pre></pre>
<p>&quot;<strong>The most straightforward proof of this fact is to provide the value of k explicitly.</strong>&quot;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Even_1000 = $ 500n Equal.refl
<span class="boring">}</span></code></pre></pre>
<p>On the other hand, the proof of the corresponding boolean statement is even simpler:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Even_1000a : Equal (Evenb 1000n) Bool.true
Even_1000a = Equal.refl
<span class="boring">}</span></code></pre></pre>
<p>&quot;Interestingly, as the two notions are equivalent, we can use the boolean formulation to prove the other without explicitly mentioning the value 500.&quot;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Even_1000b : Sigma Nat (k =&gt; Equal 1000n (Nat.double k))
Even_1000b = Sigma.new 500n Equal.refl
<span class="boring">}</span></code></pre></pre>
<p>Although we haven't gained much in terms of proof size in this case, larger proofs can be considerably simplified by using reflection. As an extreme example, the proof of the four-color theorem in Coq uses reflection to reduce the analysis of hundreds of different cases to a boolean computation. We won't delve into reflection in great detail, but it serves as a good example that shows the complementary strengths of booleans and general propositions.</p>
<h4 id="logical_connectives"><a class="header" href="#logical_connectives">Logical_connectives</a></h4>
<p>The following lemmas relate the propositional connectives studied in this chapter to their corresponding boolean operations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Andb_true_equiv 
  (b1: Bool) 
  (b2: Bool) : Equivalence (Equal (Bool.and b1 b2) Bool.true) (Pair (Equal b1 Bool.true) (Equal b2 Bool.true))
Andb_true_equiv b1 b2 = ?


Orb_true_equiv 
  (b1: Bool) 
  (b2: Bool): Equivalence (Equal (Bool.or b1 b2) Bool.true) (Either (Equal b1 Bool.true) (Equal b2 Bool.true))
Orb_true_equiv b1 b2 = ?
<span class="boring">}</span></code></pre></pre>
<h4 id="beq_nat_false_equiv"><a class="header" href="#beq_nat_false_equiv">Beq_nat_false_equiv</a></h4>
<p>The following theorem is an alternative &quot;negative&quot; formulation of beq_nat_true_equiv that is more convenient in certain situations (we will see examples in later chapters).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Beq_nat_false_equiv (n1: Nat) (n2: Nat) : Equivalence (Equal (Nat.equal n1 n2) Bool.false) (Not (Equal n1 n2))
Beq_nat_false_equiv n1 n2 = ?
<span class="boring">}</span></code></pre></pre>
<h4 id="beq_list"><a class="header" href="#beq_list">Beq_list</a></h4>
<p>Given a boolean operator beq to test the equality of elements of some type a, we can define a function beq_list beq to test the equality of lists with elements in a. Complete the definition of the function beq_list below. To ensure that your definition is correct, prove the theorem beq_list_true_equiv.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Beq_list &lt;a&gt; (beq: a -&gt; a -&gt; Bool) (xs: List a) (ys: List a) : Bool
Beq_list a beq  xs ys = ?

Beq_list_true_equiv &lt;a&gt; 
  (beq: a -&gt; a -&gt; Bool) 
  (a1: a) 
  (a2: a) 
  (e: Equivalence (Equal (beq a1 a2) Bool.true) (Equal a1 a2))
  (xs: List a)
  (ys: List a): Equivalence (Equal (Beq_list beq xs ys) Bool.true) (Equal xs ys)
Beq_list_true_equiv a beq a1 a2 e xs ys = ?
<span class="boring">}</span></code></pre></pre>
<h4 id="all_forallb"><a class="header" href="#all_forallb">All_forallb</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Forallb &lt;x&gt; (t: x -&gt; Bool) (xs: List x) : Bool
Forallb x t List.nil = Bool.true
Forallb x t (List.cons xs.h xs.t) = Bool.and (t xs.h) (Forallb t xs.t)

<span class="boring">}</span></code></pre></pre>
<p>Prove the theorem below, which relates forallb to the property All from the above exercise.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Forallb_true_equiv &lt;x&gt; 
  (t: x -&gt; Bool) 
  (xs: List x) : 
  Equivalence (Equal (Forallb t xs) Bool.true) ((All ((k: x) =&gt; Equal (t k) Bool.true) xs))
Forallb_true_equiv x t xs = ?
<span class="boring">}</span></code></pre></pre>
<p>Are there any important properties of the function forallb that are not captured by this specification?</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="classical-vs-constructive-logic"><a class="header" href="#classical-vs-constructive-logic">Classical vs. Constructive Logic</a></h3>
<p>We have seen that it is not possible to test whether a proposition p is true or not by defining a Kind function. You may be surprised to find out that a similar restriction applies to proofs! In other words, the following principle of intuitive reasoning is not derivable in Kind:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Excluded_middle &lt;p&gt;: Either p (Not p)
<span class="boring">}</span></code></pre></pre>
<p>To understand operationally why this is the case, recall that to prove a statement of the form <code>Either p q</code>, we use the pattern matches <em>Left</em> and <em>Right</em>, which require knowing which side of the disjunction is true. But the universally quantified proposition p in Excluded_middle is an arbitrary proposition about which we know nothing. We do not have enough information to choose which of <em>Left</em> or <em>Right</em> to apply, just as Kind does not have enough information to mechanically decide whether p is true or not within a function.</p>
<p>However, if we know that <em>p</em> is reflected in some Boolean term <em>b</em>, determining whether it is true or not is trivial: we just check the value of <em>b</em>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Restricted_excluded_middle &lt;p&gt; &lt;q&gt; (b: Bool)(e: Equivalence p (Equal b Bool.true)) : Either p (Not p) 
Restricted_excluded_middle p q Bool.true  (Equivalence.new pb bp) = Either.left (bp Equal.refl)
Restricted_excluded_middle p q Bool.false (Equivalence.new pb bp) = Either.right (Empty.absurd (Not_implies_our_not pb))
<span class="boring">}</span></code></pre></pre>
<p>In particular, the third excluded is valid for equations <em>n = m</em>, between natural numbers <em>n</em> and <em>m</em>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Restricted_excluded_middle_eq (n: Nat) (m: Nat) : Either (Equal n m) (Not (Equal n m))
Restricted_excluded_middle_eq n m = ?

To_reme (n: Nat) (m: Nat) (e: Equal n m) : Equal (Nat.equal n m) Bool.true
To_reme Nat.zero Nat.zero e         = Equal.refl
To_reme Nat.zero (Nat.succ m) e     = Empty.absurd (Not_implies_our_not e)
To_reme (Nat.succ n) Nat.zero e     = Empty.absurd (Not_implies_our_not e)
To_reme (Nat.succ n) (Nat.succ m) e = To_reme n m (Succ_injective n m e)

From_reme (n: Nat) (m: Nat) (e: Equal (Nat.equal n m) Bool.true) : Equal n m
From_reme Nat.zero Nat.zero e         = Equal.refl
From_reme Nat.zero (Nat.succ m) e     = Empty.absurd (Not_implies_our_not e)
From_reme (Nat.succ n) Nat.zero e     = Empty.absurd (Not_implies_our_not e)
From_reme (Nat.succ n) (Nat.succ m) e = Equal.apply (x =&gt; Nat.succ x) (From_reme n m e)
<span class="boring">}</span></code></pre></pre>
<p>It may seem strange that the principle of the excluded middle is not available by default in Kind; after all, any assertion must be true or false. However, there is an advantage in not assuming the principle of the excluded middle: statements in Kind can make stronger claims than the analogous statements in standard mathematics. Notably, if there is a proof in Kind of <code>(Sigma a (x =&gt; (p x)))</code>, we can explicitly exhibit a value of x for which we can prove p x — in other words, every proof of existence is necessarily constructive. Logics like Kind, which do not assume the principle of the excluded middle, are referred to as constructive logics. More conventional logical systems, such as ZFC, in which the principle of the excluded middle is valid for arbitrary propositions, are referred to as classical.</p>
<p>The following example illustrates why assuming the principle of the excluded middle can lead to non-constructive proofs:</p>
<p>Statement: There are irrational numbers <em>a</em> and <em>b</em>, such that <code>a^b</code> is rational.</p>
<p>Proof: It is not difficult to show that the square root of 2 is irrational. If <code>square root of 2 ^ square root of 2</code> is rational, we can simply take <code>a = b = square root of 2</code>, and we are done .Otherwise, if <code>square root of 2 ^ square root of 2</code> is irrational, we can take <code>a = square root of 2 ^ square root of 2</code> and <code>b = square root of 2</code>, since <code>a ^ b = square root of 2 ^ (square root of 2 * square root of 2) = square root of 2 ^ 2 = 2</code>.</p>
<p>Did you notice what happened here? We used the principle of the excluded middle to separately consider the cases where <code>square root of 2 ^ square root of 2</code> is rational and where it is not, without knowing which one is true! Because of this, we know that such a and b exist, but we cannot determine their actual values (at least, using this line of argument).</p>
<p>As useful as constructive logic is, it has its limitations: there are many statements that can be easily proven in classical logic but have much more complicated constructive proofs, and there are some for which no constructive proof is known! Fortunately, just like the functional extensionality, the principle of the excluded middle is known to be compatible with Kind logic, allowing us to safely add it as an axiom. However, we will not need to do this in this book: the results we cover can be developed entirely within constructive logic at a negligible extra cost.</p>
<p>It takes some practice to understand which proof techniques should be avoided in constructive reasoning, but arguments by contradiction, in particular, are infamous for leading to non-constructive proofs. Here's a typical example: suppose we want to show that there exists an x with some property p, i.e., such that p x. We start by assuming that our conclusion is false; that is <code>Not (Sigma a (x =&gt; (p x)))</code>. From this premise, it is not difficult to deduce <code>(x: a) -&gt; Not (p x)</code>. If we can show that this intermediate fact leads to a contradiction, we arrive at a proof of existence without ever exhibiting a value of x for which p x is true!</p>
<p>The technical failure here, from a constructive standpoint, is that we claim to prove <code>Sigma a (x =&gt; (p x))</code> using a proof o <code>Not (Not (Sigma a (x =&gt;(p x))))</code>. Allowing us to remove double negations from arbitrary statements is equivalent to assuming the excluded middle, as shown in one of the exercises below. Thus, this line of reasoning cannot be encoded in Kind without assuming additional axioms.</p>
<h4 id="excluded_middle_irrefutable"><a class="header" href="#excluded_middle_irrefutable">Excluded_middle_irrefutable</a></h4>
<p>The consistency of Kind with the general axiom of the excluded middle requires complicated reasoning that cannot be carried out within Kind itself. However, the following theorem implies that it is always safe to assume a decidability axiom (i.e., an instance of the excluded middle) for any specific type p. Why? Because we cannot prove the negation of such an axiom; if we could, we would have both <code>Not (Either p (Not p))</code> and <code>Not (Not (Either p (Not p)))</code>, which is a contradiction.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Excluded_middle_irrefutable &lt;p&gt; : Not (Not (Either p (Not p)))
Excluded_middle_irrefutable p = ?
<span class="boring">}</span></code></pre></pre>
<h4 id="not_exists_dist"><a class="header" href="#not_exists_dist">Not_exists_dist</a></h4>
<p>It is a theorem of classical logic that the following two statements are equivalent:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Not (Sigma a (k =&gt; Not (p k))))
(x : a) -&gt; p x
<span class="boring">}</span></code></pre></pre>
<p>The <em>dist_not_exists</em> theorem above proves one side of this equivalence. Interestingly, the other direction cannot be proven in constructive logic. Your task is to show that it is implied by the excluded middle.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Not_exists_dist &lt;a&gt; (p: a -&gt; Type) (s: Not (Sigma a (k =&gt; Not (p k)))) : (x: a) -&gt; p x
Not_exists_dist a p s = ?
<span class="boring">}</span></code></pre></pre>
<p>where</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Excluded_middle &lt;p&gt;: Either p (Not p)
// Excluded_middle p = Confia 
<span class="boring">}</span></code></pre></pre>
<h4 id="classical_axioms"><a class="header" href="#classical_axioms">Classical_axioms</a></h4>
<p>For those who like a challenge, here's an exercise taken from the book Coq'Art by Bertot and Casteran (p. 123). Each of the following four statements, together with excluded_middle, can be regarded as characterizing classical logic. We cannot prove any of them in Kind, but we can consistently add any one of them as an axiom if we want to work in classical logic.</p>
<p>Prove that all five propositions (these four plus excluded_middle) are equivalent.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Peirce &lt;p&gt; &lt;q&gt;(pq: (p -&gt; q) -&gt; p) : p

Double_negation_elimination &lt;p&gt; (np: Not (Not p)) : p

De_morgan_not_not &lt;p&gt; &lt;q&gt; (np: Pair (Not p) (Not q)) : Either p q

Implies_to_or &lt;p&gt; &lt;q&gt; (pq: p -&gt; q) : Either (Not p) q
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inductively-defined-propositions"><a class="header" href="#inductively-defined-propositions">Inductively Defined Propositions</a></h1>
<p>In the Logic chapter, we examined various ways of writing propositions, including conjunction, disjunction, and quantifiers. In this chapter, we add a new tool to the mix: inductive definitions.</p>
<p>Remember that we saw two ways to state that a number <em>n</em> is even: we can say (1) <code>Evenb n = Bool.true</code> or (2) <code>(k =&gt; Equal n (Nat.double k))</code>. Another possibility is to say that n is even if we can establish its parity based on the following rules:</p>
<ul>
<li><em>Ev_0</em> Rule: The number <code>0</code> is even.</li>
<li><em>Ev_SS</em> Rule: If <code>n</code> is even, then <code>Nat.succ (Nat.succ n)</code> is even.</li>
</ul>
<p>To illustrate how this definition of parity works, let's imagine using it to show that 4 is even. By the <em>Ev_SS</em> rule, it suffices to show that 2 is even. This, in turn, is guaranteed again by the <em>Ev_SS</em> rule, provided we can show that 0 is even. But this last fact follows directly from the <em>Ev_0</em> rule.</p>
<p>We will see many definitions like this throughout the rest of the course. For informal discussions, it is helpful to have a lightweight notation that makes reading and writing easier. Inference rules are one such notation:</p>
<br>
<p>$$
\frac{  }{Ev\ \ 0} \ \ ev_0
$$</p>
<br>
<p>$$
\frac{\ \ \ \  ev\ \  \ \ \  }{Ev\ \ (Nat.succ \ (Nat.succ \ n))} \ \ ev_SS
$$</p>
<br>
<p>Each of the textual rules above is reformatted here as an inference rule; the intended reading is that if the premises above the line are all valid, then the conclusion below the line follows. For example, the <em>ev_SS</em> rule says that if <em>n</em> satisfies <em>ev</em>, then <code>Nat.succ (Nat.succ n)</code> also satisfies it. If a rule has no premises above the line, then its conclusion is valid unconditionally.</p>
<p>We can represent a proof using these rules by combining the applications of rules into a proof tree. Here is how we could transcribe the above proof that 4 is even:</p>
<p>$$
\frac{  }{Ev\ \ 0} \ \ ev_0 \
\ \ \ \frac{  }{Ev\ \ 2} \ \ ev_SS \
\ \ \ \frac{  }{Ev\ \ 4} \ \ ev_SS \
\ \ \ \frac{  }{Ev\ \ 6} \ \ ev_SS \
$$</p>
<br>
Why call this a "tree" (instead of a "stack," for example)? Because, in general, inference rules can have multiple premises. We will see examples of this below.
<br>
Putting it all together, we can translate the definition of parity into a formal definition in Kind using a data declaration, where each constructor corresponds to an inference rule:
<pre><code class="language-rust ignore">type Ev ~ (n: Nat){
  ev_0 : Ev Nat.zero
  ev_ss &lt;n : Nat&gt; (pred: Ev n) : Ev (Nat.succ (Nat.succ n))
}</code></pre>
<p>This definition differs in a crucial aspect from previous uses of data: its result is not a Type but rather a function from Nat to Type – that is, a property of numbers. Note that we have seen other inductive definitions that result in functions, such as List, whose type is <code>Type -&gt; Type</code>. What is new here is that, since the Nat argument of Ev is unnamed and appears to the right of the colon, it is allowed to take different values in the types of different constructors: <code>Nat.zero</code> in the type of <em>ev_z</em> and <code>Nat.succ (Nat.succ n)</code> in the type of <em>ev_ss</em>.</p>
<p>On the other hand, the definition of List globally names the parameter x, forcing the result of Nil and Cons to be the same <code>(List x)</code>. If we had tried to omit the type <code>n: Nat</code> when defining <em>ev_ss</em>, we would have seen an error</p>
<pre><code class="language-rust ignore">type Wrong_ev ~ (n: Nat){
  wrong_ev_0 : Ev Nat.zero
  wrong_ev_ss (pred: Ev n) : Ev (Nat.succ (Nat.succ n))
}</code></pre>
<p>Com o seguinte retorno:</p>
<pre><code class="language-diff ignore">   - ERROR  Cannot find the definition 'n'.

      ┌──[ev.kind2:9:25]
      │
    8 │      wrong_ev_z : Ev Nat.zero
    9 │      wrong_ev_ss (pred: Ev n) : Ev (Nat.succ (Nat.succ n))
      │                            ┬                           ┬
      │                            │                           └Here!
      │                            └Here!
   10 │    

</code></pre>
<p>(&quot;Parameter&quot; here is jargon from Kind for an argument to the left of the colon in an inductive definition; &quot;index&quot; is used to refer to arguments to the right of the colon.)</p>
<p>We can think of the definition of Ev as defining a property of the Kind <code>Ev: Nat -&gt; Type</code>, along with the theorems <code>ev_z: Ev 0 and ev_ss &lt;n : Nat&gt; (pred: Ev n) : Ev (Nat.succ (Nat.succ n))</code>. Such &quot;constructor theorems&quot; have the same status as proven theorems. In particular, we can apply rule names as functions to each other to prove Ev for specific numbers...</p>
<pre><code class="language-rust ignore">Ev_4 : Ev 4n
Ev_4 = Ev.ev_ss 2n (Ev.ev_ss 0n Ev.ev_z)</code></pre>
<p>We can also prove theorems that have hypotheses involving Ev.</p>
<pre><code class="language-rust ignore">Ev_plus5 (n: Nat) : Ev n -&gt; Ev (Nat.add 4n n)
Ev_plus5 n = x =&gt; Ev.ev_ss (Ev.ev_ss x)</code></pre>
<p>More generally, we can show that any number multiplied by 2 is even.</p>
<h4 id="ev_double"><a class="header" href="#ev_double">Ev_double</a></h4>
<pre><code class="language-rust ignore">Ev_double (n: Nat) : Ev (Nat.double n)
Ev_double n = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="using-evidence-in-proofs"><a class="header" href="#using-evidence-in-proofs">Using Evidence in Proofs</a></h2>
<p>In addition to constructing evidence that numbers are even, we can also reason about such evidence. Introducing Ev with a data statement tells <em>Kind</em> not only that the constructors <code>ev_z</code> and <code>ev_ss</code> are valid ways to construct evidence that a number is even, but also that these two constructors are the only ways to construct evidence that numbers are even (in the sense of <em>Ev</em>).</p>
<p>In other words, if someone gives us evidence and claims it to be of the form <code>Ev n</code>, then we know that e must have one of two forms:</p>
<ul>
<li><code>e</code> is <code>ev_z</code> (and <em>n</em> is <em>Nat.zero</em>), or</li>
<li><code>e</code> is <code>ev_ss</code> applied to induction with <code>n</code> and it is equal to the successor of the successor of <code>n</code>*.</li>
</ul>
<h6 id="weve-already-used-this-strategy-before-remember-the-problemst3-exercise-from-the-induction-chapter-here-the-difference-is-that-theres-only-one-more-natsucc-in-our-induction"><a class="header" href="#weve-already-used-this-strategy-before-remember-the-problemst3-exercise-from-the-induction-chapter-here-the-difference-is-that-theres-only-one-more-natsucc-in-our-induction"><em>We've already used this strategy before, remember the Problems.t3 exercise from the induction chapter, here the difference is that there's only one more &quot;Nat.succ&quot; in our induction</em></a></h6>
<p>This suggests that it should be possible to analyze a hypothesis of the form <code>Ev n</code> in the same way we do with data structures defined inductively; in particular, it should be possible to argue by <em>induction</em> and <em>case analysis</em> on this evidence. Let's see some examples to understand what this means in practice.</p>
<h3 id="pattern-matching-on-evidence"><a class="header" href="#pattern-matching-on-evidence">Pattern Matching on Evidence</a></h3>
<p>Suppose we are proving some fact involving a number n and we are given the hypothesis <code>Ev n</code>. We already know how to perform <em>case analysis</em> on <code>n</code> using the inversion tactic, generating separate subgoals for the case where <code>n = Nat.zero</code> and the case where <code>n = Nat.succ n</code> for some <code>n</code>. But for some proofs, we may want to directly analyze the evidence that <code>Ev n</code> is true.</p>
<p>By the definition of Ev, there are two cases to consider:</p>
<ul>
<li>If the evidence is of the form <code>ev_z</code>,  we know that <code>n = Nat.zero</code>.</li>
<li>Otherwise, the evidence must have the form <code>ev_ss n e</code>, where <code>n = Nat.succ (Nat.succ n)</code> and <code>e</code> is the evidence for <code>Ev n</code>.</li>
</ul>
<p>We can reason about this kind of pattern matching in Kind, again using <em>pattern matching</em>. In addition to allowing us to reason about equalities involving constructors, inversion provides a principle of case analysis for propositions defined inductively. <!-- Quando usada dessa forma, sua sintaxe é semelhante à da função destruct: passamos a ela uma lista de identificadores separados por caracteres | para nomear os argumentos de cada um dos possíveis construtores.--></p>
<pre><code class="language-rust ignore">Ev_minus2 (n: Nat) (e: Ev n) : Ev (Nat.pred (Nat.pred n))
Ev_minus2 Nat.zero e = e
Ev_minus2 (Nat.succ Nat.zero) e = Ev.ev_z
Ev_minus2 (Nat.succ (Nat.succ n)) (Ev.ev_ss e) = e</code></pre>
<p>In words, here is how the pattern matching reasoning works in this proof:</p>
<ul>
<li>If the evidence is of the form <code>ev_z</code>, we know that <code>n = Nat.zero</code>. Therefore, it is sufficient to show that <code>Ev (Nat.pred (Nat.pred Nat.zero))</code> is valid. By the definition of <code>Nat.pred</code>, this is equivalent to showing that <code>Ev Z</code> is valid, which follows directly from <code>ev_0</code>.</li>
<li>Otherwise, the evidence must have the form  <code>ev_ss n e</code>, where <code>n = Nat.succ (Nat.succ n)</code> and <code>e</code> is the evidence for <code>Ev n</code>. We must then show that <code>Ev (Nat.pred (Nat.pred (Nat.succ (Nat.succ n))))</code> is valid, which, after simplification, follows directly from <code>e</code>.</li>
</ul>
<pre><code class="language-rust ignore">Evss_ev (n: Nat) (e: Ev (Nat.succ (Nat.succ n))) : Ev n</code></pre>
<p>Intuitively, we know that the evidence for the hypothesis cannot consist solely of the constructor <code>ev_z</code>, since <code>Nat.zero</code> and <code>Nat.succ</code> are different constructors of the type Nat; therefore, <code>ev_ss</code> is the only applicable case. Unfortunately, <em>pattern matching</em> is not smart enough to realize this and still generates two subgoals. Even worse, by doing so, it leaves the final goal unchanged, failing to provide any useful information to complete the proof.</p>
<p>The inversion tactic, on the other hand, can detect (1) that the first case does not apply and (2) that the n appearing in the Ev_SS case must be the same as n. This allows us to conclude the proof.</p>
<pre><code class="language-rust  ignore">Evss_ev n (Ev.ev_ss e) = e </code></pre>
<p>Using dependent pattern matching, we can also apply the principle of explosion to &quot;obviously contradictory&quot; hypotheses involving inductive properties. For example:</p>
<pre><code class="language-rust  ignore">One_not_even : Not (Ev 1n)
</code></pre>
<h3 id="inversion_practice"><a class="header" href="#inversion_practice">Inversion_practice</a></h3>
<p>Prove the following results using pattern matching.</p>
<pre><code class="language-rust  ignore">Ssssev__even (n: Data.Nat) (e: Ev (Data.Nat.succ (Data.Nat.succ (Data.Nat.succ (Data.Nat.succ n))))) : Ev n
Ssssev__even n e = ?

Even5_nonsense (e: Ev 5n) : Prop.Equal (Data.Nat.add 2n 2n) 9n
Even5_nonsense e = ?</code></pre>
<p>The way we use inversion here may seem a bit mysterious at first. So far, we have only used inversion on equality propositions to make use of the injectivity of constructors or to discriminate between different constructors. But we see here that inversion can also be applied to analyze evidence of inductively defined propositions.</p>
<p>Here is how inversion works in general. Suppose the name <strong>I</strong> refers to an assumption <strong>P</strong> in the current context, where <strong>P</strong> was defined by an Inductive statement. Then, for each of the constructors of <strong>P</strong>, inversion of <strong>I</strong> generates a subgoal in which <strong>I</strong> has been replaced by the exact and specific conditions under which this constructor could have been used to prove <strong>P</strong>. Some of these subgoals will be self-contradictory; inversion discards those. The ones that are left represent the cases that must be proven to establish the original goal. For these, inversion adds all the equations to the proof context that must hold true for the arguments supplied to <strong>P</strong> (e.g., <code>Nat.succ (Nat.succ k) = n</code> in the proof of evSS_ev).</p>
<p>The exercise ev_double above shows that our new notion of evenness is implied by the two previous ones (since, by even_bool_prop in the Logic chapter, we already know they are equivalent to each other). To show that the three coincide, we just need the following lemma:</p>
<pre><code class="language-rust  ignore">Ev_even
  (n: Nat)
  (e: Ev n) :
  (Sigma Nat (k =&gt; Prop.Equal n (Nat.double k)))
Ev_even n e = ?</code></pre>
<p>We proceed by case analysis on Ev n. The first case can be resolved trivially.</p>
<pre><code class="language-rust  ignore">Ev_even Nat.zero e = Sigma.new 0n Equal.refl</code></pre>
<p>Unfortunately, the second case is more challenging. We need to show <code>[k: Nat] -&gt; (Equal (Nat.succ (Nat.succ n')) (Nat.double k))</code>, but the only assumption available is <code>e'</code>, which states that <code>Ev n'</code> is true. Since this is not directly useful, it seems like we are stuck and that the case analysis on <code>Ev n</code> was a waste of time.</p>
<pre><code class="language-rust  ignore">Ev_even (Nat.succ Nat.zero) e = Empty.absurd _ //todo</code></pre>
<p>If we take a closer look at our second goal, however, we can see that something interesting happened: by performing case analysis on <code>Ev n</code>, we were able to reduce the original result to a similar one that involves a different evidence for <code>Ev n: e'</code>. More formally, we can conclude our proof by showing that</p>
<pre><code class="language-rust  ignore">Ev_even (Nat.succ (Nat.succ n)) (Ev.ev_ss e) = Ev_even_ss n (Ev_even n e)</code></pre>
<p>which is the same as the original statement, but with <code>n'</code> instead of <code>n</code>. In fact, it is not difficult to convince Kind that this intermediate result is sufficient.</p>
<pre><code class="language-rust  ignore">Ev_even (Nat.succ (Nat.succ n)) (Ev.ev_ss e) = Ev_even_ss n (Ev_even n e)</code></pre>
<h3 id="induction-on-evidence"><a class="header" href="#induction-on-evidence">Induction on Evidence</a></h3>
<p>If this seems familiar, it's no coincidence: we encountered similar problems in the Induction chapter when trying to use case analysis to prove results that required induction. And once again, the solution is... induction!</p>
<!--TL:DR O comportamento da indução sobre evidências é o mesmo que o seu comportamento sobre dados: 
ela faz com que o Kind gere uma submeta para cada construtor que poderia ter sido usado para construir aquela evidência, ao mesmo tempo em que fornece uma hipótese de indução para cada ocorrência recursiva da propriedade em questão. -->
<p>Let's try our current lemma again:</p>
<pre><code class="language-rust  ignore">Ev_even
  (n: Nat)
  (e: Ev n) :
  (Sigma Nat(k =&gt; Equal n ( Nat.double k)))
Ev_even Nat.zero e = Sigma.new 0n Equal.refl
Ev_even (Nat.succ Nat.zero) e = Empty.absurd _
Ev_even (Nat.succ (Nat.succ n)) (Ev.ev_ss e) = Ev_even_ss n (Ev_even n e)
// Ev_even (Nat.succ (Nat.succ n)) Ev.ev_z = Caso impossível</code></pre>
<!--TL:DR
Aqui, podemos ver que o Kind produziu uma HI que corresponde a E', a única ocorrência recursiva de ev em sua própria definição. Como E' menciona n', a hipótese de indução fala sobre n', em oposição a n ou algum outro número. -->
<p>The equivalence between the second and third definitions of evenness now follows.</p>
<pre><code class="language-rust ignore">
Ev_even_equiv (n: Nat)  : Equivalence (Ev n) (Sigma Nat (k =&gt; Equal n (Nat.double k)))
Ev_even_equiv n         = Equivalence.new (x =&gt; Ev_even n x) (y =&gt; From_eee n y)

From_eee (n: Nat) (s: Sigma Nat (k =&gt; Equal n (Nat.double k))) : Ev n
From_eee n (Sigma.new a b fst snd) =
  Equal.rewrite (Equal.mirror (specialize b into #0 in snd)) (x =&gt;(Ev x)) (Ev_double fst)

Ev_double (n: Nat)      : Ev (Nat.double n)
Ev_double Nat.zero      = Ev.ev_z
Ev_double (Nat.succ n)  = Ev.ev_ss (Ev_double n)
</code></pre>
<p>As we will see in the upcoming chapters, induction on evidence is a recurring technique in various areas, especially in the formalization of programming language semantics, where many properties of interest are defined inductively.</p>
<p>The following exercises provide simple examples of this technique to help you become familiar with it.</p>
<h4 id="ev_sum"><a class="header" href="#ev_sum">Ev_sum</a></h4>
<pre><code class="language-rust ignore">Ev_sum (n: Nat) (m: Nat) (e1: Ev n) (e2: Ev m) : Ev (Nat.add n m)
Ev_sum n m e1 e2 = ?
</code></pre>
<h4 id="ev_alternate"><a class="header" href="#ev_alternate">Ev_alternate</a></h4>
<p>In general, there can be multiple ways to define a property inductively. For example, here is an alternative (somewhat forced) definition for Ev:</p>
<pre><code class="language-rust ignore">type Evn ~ (n: Nat){
  z : Evn Nat.zero
  d : Evn (Nat.succ (Nat.succ Nat.zero))
  sum &lt;n : Nat&gt; &lt;m: Nat&gt; (evn: Evn n) (evm: Evn m) : Evn (Nat.add n m)
} </code></pre>
<p>Prove that this definition is logically equivalent to the old one. (You may want to refer to the previous theorem when you reach the induction step.)</p>
<pre><code class="language-rust ignore">Ev_evn (n: Nat): Equivalence (Ev n) (Evn n)
Ev_evn n = ?
</code></pre>
<h4 id="ev_ev__ev"><a class="header" href="#ev_ev__ev">Ev_ev__ev</a></h4>
<p>Finding the appropriate thing to induct on is a bit tricky here:</p>
<pre><code class="language-rust ignore">
Ev_ev_ev (n: Nat) (m: Nat) (e: Ev (Nat.add n m)) (en: Ev n) : Ev m
Ev_ev_ev Nat.zero m e en = ?</code></pre>
<h4 id="ev_plus_plus"><a class="header" href="#ev_plus_plus">Ev_plus_plus</a></h4>
<p>This exercise only requires the application of existing lemmas. No induction or even case analysis is needed, although some of the rewrites may be tedious.</p>
<pre><code class="language-rust ignore">Ev_pp 
  &lt;n: Nat&gt; 
  &lt;m: Nat&gt; 
  &lt;p: Nat&gt; 
  (e1: Ev (Nat.add n m))
  (e2: Ev (Nat.add n p))
  : Ev (Nat.add m p)
Ev_pp Nat.zero m p e1 e2 =
``</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="inductive-relations"><a class="header" href="#inductive-relations">Inductive Relations</a></h2>
<p>A proposition parameterized by a number (like Ev) can be considered as a property, meaning it defines a subset of Nat, specifically those numbers for which the proposition holds. Similarly, a proposition with two arguments can be considered as a relation, meaning it defines a set of pairs for which the proposition holds.</p>
<p>A useful example is the &quot;less than or equal&quot; relation between numbers. The following definition should be quite intuitive. It states that there are two ways to provide evidence that a number is less than or equal to another: observe that they are the same number or provide evidence that the first is less than or equal to the predecessor of the second.</p>
<pre><code class="language-rust ignore">type Le (n: Nat) ~ (m: Nat) {
  n : Le n n
  S &lt;m: Nat&gt; (pred: (Le n m)) : (Le n (Nat.succ m)) 
}</code></pre>
<p>Proofs of facts about <code>Le</code> using the constructors <code>n</code> and <code>S</code> follow the same patterns as proofs about properties, like Ev above. We can apply the constructors to prove goals about Le (e.g., show that <code>Le 3n 3n</code> or <code>Le 3n 6n</code>) and we can use pattern matching to extract information from <code>Le</code> hypotheses in the context (e.g., prove that <code>(Le 2n 1n) -&gt; (Equal (Plus 2n 2n) 5n)</code>).</p>
<p>Here are some sanity checks about the definition. (Note that while they are of the same type as &quot;simple tests&quot; we gave for the test functions we wrote in the early lectures, we must construct their proofs explicitly - Refl doesn't do the job because the proofs are not just a matter of simplifying computations.)</p>
<pre><code class="language-rust ignore">Test_le1 : Le 3n 3n
Test_le1 = Le.n 3n

Test_le2 : Le 3n 6n
Test_le2 = Le.S (Le.S (Le.S Le.n))

Test_le3 (l: Le 2n 1n) : Equal (Nat.add 2n 2n) 5n
Test_le3 Le.n = Empty.absurd // TODO
Test_le3 (Le.S Le.n) = Empty.absurd // TODO
Test_le3 (Le.S (Le.S len)) = Empty.absurd // TODO</code></pre>
<p>The &quot;strictly less than&quot; relation <code>n &lt; m</code> can now be defined in terms of <code>Le</code>.</p>
<pre><code class="language-rs ignore">Lt (n: Nat) (m: Nat) : Type
Lt n m = Le (Nat.succ n) m
</code></pre>
<p>Here are some other simple relationships about numbers</p>
<pre><code class="language-rs ignore">type Square_of ~ (n: Nat) (m: Nat) {
  sq &lt;n: Nat&gt; : Square_of n (Mult n n)
}
</code></pre>
<pre><code class="language-rs ignore">type Next_Nat ~ (n: Nat) (m: Nat) {
  Nn &lt;n: Nat&gt; : Next_Nat n (Nat.succ n)
}
</code></pre>
<pre><code class="language-rs ignore">type Next_even ~ (n: Nat) (m: Nat) {
  1 &lt;n: Nat&gt; (pred: Ev (Nat.succ n)) : Next_even n (Nat.succ n)
  2 &lt;n: Nat&gt; (pred: Ev (Nat.succ (Nat.succ n))) : Next_even n (Nat.succ (Nat.succ n))
}
</code></pre>
<h4 id="total_relation-opcional"><a class="header" href="#total_relation-opcional">Total_relation (Opcional)</a></h4>
<p>Define an inductive binary relation Total_relation that holds for all pairs of natural numbers.</p>
<pre><code class="language-rs ignore">// TODO
</code></pre>
<h4 id="empty_relation-opcional"><a class="header" href="#empty_relation-opcional">Empty_relation (Opcional)</a></h4>
<p>Define an inductive binary relation Empty_relation (about numbers) that never holds.</p>
<pre><code class="language-rs ignore">// TODO
</code></pre>
<h4 id="le_exercises-opcional"><a class="header" href="#le_exercises-opcional">Le_exercises (Opcional)</a></h4>
<p>Here are some facts about the relations <code>Le</code> and <code>Lt</code> that we will need later in the course. The proofs are good practice exercises.</p>
<pre><code class="language-rust ignore">Le.trans (n: Nat) (m: Nat) (o: Nat) (x: Le m n) (y: Le n o) : Le m o 
Le.trans n m o x y = ?

O_le_n (n: Nat) : Le Nat.zero n
O_le_n n = ?

N_le_m_sn_le_sm (n: Nat) (m: Nat) (l: Le n m) : Le (Nat.succ n) (Nat.succ m)
N_le_m_sn_le_sm n m l = ?

Sn_le_Sm_n_le_m (n: Nat) (m: Nat) (l: Le (Nat.succ n) (Nat.succ m)) : Le n m
Sn_le_Sm_n_le_m n m l = ?

Le_plus_l (a: Nat) (b: Nat) : Le a (Nat.add a b)
Le_plus_l a b = ?

Plus_lt (n1: Nat) (n2: Nat) (m: Nat) (lt: Lt (Nat.add n1 n2) m) : Pair (Lt n1 m) (Lt n2 m)
Plus_lt n1 n2 m lt = ?

Lt_S (n: Nat) (m: Nat) (l: Lt n m) : (Lt n (Nat.succ m))
Lt_S n m l = ?

Lte_complete (n: Nat) (m: Nat) (e: Equal (Nat.lte n m) Bool.true) :  (Le n m)
Lte_complete n m e = ? </code></pre>
<p>Hint: The next one may be easier to prove by induction on m.</p>
<pre><code class="language-rust ignore">Lte_correct (n: Nat) (m: Nat) (le: Le n m) : Equal Bool (Nat.lte n m) Bool.true
Lte_correct n m le = ?</code></pre>
<p>Hint: This theorem can be easily proved without using induction.</p>
<pre><code class="language-rust ignore">Lte_true_trans (n: Nat) (m: Nat) (o: Nat) 
  (l: Equal (Nat.lte n m) Bool.true) 
  (k: Equal (Nat.lte m o) Bool.true) 
  : Equal (Nat.lte n o) Bool.true
Lte_true_trans n m o l k = ?</code></pre>
<h4 id="lte_iff"><a class="header" href="#lte_iff">lte_iff</a></h4>
<pre><code class="language-rust  ignore">Lte_iff (n: Nat) (m: Nat) : Iff (Equal (Nat.lte n m) Bool.true) (Le n m)
Lte_iff n m = ?</code></pre>
<h4 id="r_provability"><a class="header" href="#r_provability">R_provability</a></h4>
<p>We can define threeplace relations, four-place relations, etc., in just the same way as binary relations.</p>
<p>For example, consider the following three-place relation on numbers:</p>
<pre><code class="language-rust ignore">type R ~ (a: Nat) (b: Nat) (c: Nat) {
  C1 : R 0n 0n 0n
  C2 &lt;m: Nat&gt; &lt;n: Nat&gt; &lt;o: Nat&gt;
    (r: R m n o) 
  : R (Nat.succ m) n (Nat.succ o)
  C3 &lt;m: Nat&gt; &lt;n: Nat&gt; &lt;o: Nat&gt;
    (r: R m n o) 
  : R m (Nat.succ n) (Nat.succ o)
  C4 &lt;m: Nat&gt; &lt;n: Nat&gt; &lt;o: Nat&gt;
    (r: R (Nat.succ m) (Nat.succ n) (Nat.succ (Nat.succ o))) 
  C5 &lt;m: Nat&gt; &lt;n: Nat&gt; &lt;o: Nat&gt; 
   (r: R m n o) 
}</code></pre>
<p>Which of the following propositions are provable?</p>
<ul>
<li>R 1n 1n 2n</li>
</ul>
<pre><code class="language-rs ignore">// TODO
</code></pre>
<ul>
<li>R 2n 2n 6n</li>
</ul>
<pre><code class="language-rs ignore">// TODO
</code></pre>
<ul>
<li>If we dropped constructor C5 from the definition of R, would the set of provable propositions change? Briefly (1 sentence) explain your answer.</li>
</ul>
<pre><code class="language-rs ignore">// TODO
</code></pre>
<ul>
<li>If we dropped constructor C4 from the definition of R, would the set of provable propositions change? Briefly (1 sentence) explain your answer.</li>
</ul>
<pre><code class="language-rs ignore">// TODO
</code></pre>
<h4 id="r_fact-optional"><a class="header" href="#r_fact-optional">R_fact (Optional)</a></h4>
<p>The relation R above actually encodes a familiar function. Figure out which function; then state and prove this equivalence in Kind</p>
<pre><code class="language-rust ignore">F_R (m: Nat) (n: Nat) : Nat
F_R m n = ?

R_equiv_fR (m: Nat) (n: Nat) (o: Nat) : Iff (R m n o) (Equal (F_R m n) o)
R_equiv_fR m n o = ?</code></pre>
<h4 id="subseq"><a class="header" href="#subseq">Subseq</a></h4>
<p>A list is a subsequence of another list if all the elements of the first list occur in the same order in the second list, possibly with some extra elements between them. For example, [1n,2n,3n] is a subsequence of each of the lists [1n,2n,3n], [1n,1n,1n,2n,2n,3n], [1n,2n,7n,3n], [5n,6n,1n,9n,9n,2n,7n,3n,8n], but it is not a subsequence of any of the lists [1n,2n], [1n,3n], [5n,6n,2n,1n,7n,3n,8n].</p>
<p>Define an inductive type <code>Subseq</code> in List Nat that captures the meaning of being a subsequence. <em>(Hint: You will need three cases.)</em></p>
<ul>
<li>Prove subseq_refl, that subsequence is reflexive, meaning any list is a subsequence of itself.</li>
<li>Prove subseq_app, that for any lists l1, l2, and l3, if l1 is a subsequence of l2, then l1 is also a subsequence of (App l2 l3).</li>
<li>(Optional, more challenging) Prove subseq_trans, that subsequence is transitive - meaning if l1 is a subsequence of l2 and l2 is a subsequence of l3, then l1 is a subsequence of l3. Hint: <em>Choose your induction carefully!</em></li>
</ul>
<h4 id="r_provability2-opcional"><a class="header" href="#r_provability2-opcional">R_provability2 (Opcional)</a></h4>
<p>Assuming we have given the following definition to Kind:</p>
<pre><code class="language-rust  ignore">type Rp ~ (n: Nat) (l: List Nat) {
  C1 
  : Rp 0n []
  C2 &lt;n: Nat&gt; &lt;l: List Nat&gt; 
  (r: Rp n l) 
  : Rp (Nat.succ n) (List.cons n l)
  C3 &lt;n: Nat&gt; &lt;l: List Nat&gt; 
  (r: Rp (Nat.succ n) l)
}</code></pre>
<ul>
<li>Rp 2n [1n,0n]</li>
<li>Rp 1n [1n,2n,1n,0n]</li>
<li>Rp 6n [3n,2n,1n,0n]</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="case-study-regular-expressions"><a class="header" href="#case-study-regular-expressions">Case Study: Regular Expressions</a></h2>
<p>The property Ev provides a simple example to illustrate inductive definitions and the basic techniques for reasoning about them, but it's not very exciting - after all, it's equivalent to the two non-inductive definitions of parity we've already seen, and it doesn't seem to offer any concrete benefits over them. To give a better sense of the power of inductive definitions, let's show how to use them to model a classic concept from computer science: regular expressions.</p>
<p>Regular expressions are a simple language for describing strings, defined as follows:</p>
<pre><code class="language-rust ignore">type Regexp (t: Type) {
    emptyset                              
    emptystr                              
    chr   (h: t)                          
    app   (st1: Regexp t) (st2: Regexp t) 
    union (st1: Regexp t) (st2: Regexp t)
    star  (st1: Regexp t)                 
  }</code></pre>
<p>Note that this definition is polymorphic: regular expressions in <code>Reg_exp t</code> describe strings with characters drawn from <code>t</code> - that is, lists of elements of <code>t</code>.</p>
<p>(We deviate slightly from standard practice by not requiring the type t to be finite. This results in a slightly different theory of regular expressions, but the difference is not significant for our purposes.)</p>
<p>We connect regular expressions and strings through the following rules, which define when a regular expression matches a given string:</p>
<p>• The EmptySet expression does not match any string.
• The EmptyStr expression matches the empty string [].
• The Chr x expression matches the single-character string [x].
• If re1 matches s1 and re2 matches s2, then (App re1 re2) matches (App s1 s2).
• If at least one of the expressions re1 and re2 matches s, then Union re1 re2 matches s.
• Finally, if we can write a string s as the concatenation of a sequence of strings s = (App s_1 (App... s_k...)), and the expression re matches each of the strings s_i, then Star re matches s.</p>
<p>As a special case, the sequence of strings may be empty, so <code>Star re</code> always matches the empty string [] regardless of what <code>re</code> is.</p>
<p>We can easily translate this informal definition into a data definition as follows:</p>
<pre><code class="language-rust ignore">type Expmatch &lt;t&gt; ~(xs: Data.List t) (r: Regexp t) {
mempty              : Expmatch t []   Regexp.emptystr 
mchar (x: t)        : Expmatch t [x] (Regexp.chr x)
mapp 
  &lt;s1: Data.List t&gt;
  &lt;s2: Data.List t&gt;
  &lt;re1: Regexp t&gt;
  &lt;re2: Regexp t&gt;
  (e1: Expmatch t s1 re1)
  (e2: Expmatch t s2 re2)
  : Expmatch t (Data.List.concat t s1 s2) (Regexp.app re1 re2)
munionl &lt;s1: Data.List t&gt; (re1: Regexp t) (re2: Regexp t)
  (e1: Expmatch t s1 re1)
  : Expmatch t s1 (Regexp.union re1 re2)
munionr (re1: Regexp t) &lt;s2: Data.List t&gt; (re2: Regexp t)
  (e1: Expmatch t s2 re2)
  : Expmatch t s2 (Regexp.union re1 re2)
mstarz (r: Regexp t) : Expmatch t [] (Regexp.star r)  
mstarapp 
  &lt;s1: Data.List t&gt; 
  &lt;s2: Data.List t&gt;
  &lt;r1: Regexp t&gt;
  (e1: Expmatch s1 r1)
  (e2: Expmatch s2 (Regexp.star r1))
  : Expmatch t (Data.List.concat t s1 s2) (Regexp.star r1)
}</code></pre>
<!-- Novamente, para legibilidade, também podemos exibir essa definição usando notação de regras de inferência. Ao mesmo tempo, vamos introduzir uma notação de infixa mais legível.

-----------Latex

Observe que essas regras não são exatamente as mesmas das informais que demos no início da seção. Primeiro, não precisamos incluir uma regra que declare explicitamente que nenhuma string corresponde a EmptySet; simplesmente não incluímos nenhuma regra que teria o efeito de alguma string corresponder a EmptySet. (De fato, a sintaxe das definições indutivas nem mesmo nos permite fornecer tal "regra negativa".) -->
<!-- TL;DR Em segundo lugar, as regras informais para Union e Star correspondem a dois construtores cada: MUnionL / MUnionR e MStar0 / MStarApp. O resultado é logicamente equivalente às regras originais, 
mas mais conveniente de usar no Kind, uma vez que as ocorrências recursivas de Exp_match são fornecidas como argumentos diretos para os construtores, facilitando a indução com base nas evidências. (Os exercícios exp_match_ex1 e exp_match_ex2 abaixo pedem para provar que os construtores dados na declaração indutiva e os que surgiriam de uma transcrição mais literal das regras informais são de fato equivalentes.) -->
<p>Let's illustrate these rules with some examples.</p>
<pre><code class="language-rust ignore">Regexp_ex1 : Expmatch [1] (Regexp.chr 1)
Regexp_ex1 = Expmatch.mchar 1 

Regexp_ex2 : Expmatch [1, 2] (Regexp.app (Regexp.chr 1) (Regexp.chr 2))
Regexp_ex2 = Expmatch.mapp [1] (Regexp.chr 1) (Expmatch.mchar 1) [2] (Regexp.chr 2) (Expmatch.mchar 2)
</code></pre>
<p>Using pattern matching, we can also show that certain strings do not match a regular expression:</p>
<pre><code class="language-rust ignore">Regexp_ex3 : Not (Expmatch [1, 2] (Regexp.chr 1))
Regexp_ex3 = Empty.absurd _</code></pre>
<p>We can define auxiliary functions to help write regular expressions. The reg_exp_of_list function constructs a regular expression that matches exactly the list it receives as an argument:</p>
<pre><code class="language-rust ignore">Regexp_of_list &lt;t&gt; (xs: List t)        : Regexp t
Regexp_of_list t List.nil              = Regexp.emptystr
Regexp_of_list t (List.cons xs.h xs.t) = Regexp.app (Regexp.chr xs.h) (Regexp_of_list t xs.t)

Regexp_ex4 : Expmatch [1, 2, 3] (Regexp_of_list [1, 2, 3])
Regexp_ex4 = 
  (Expmatch.mapp 
    [1] 
    (Regexp.chr 1) 
    (Expmatch.mchar 1) 
    [2, 3] 
    (Regexp_of_list [2, 3])
    (Expmatch.mapp
      [2]
      (Regexp.chr 2)
      (Expmatch.mchar 2) 
      [3]
      (Regexp_of_list [3])
      (Expmatch.mapp
        [3]
        (Regexp.chr 3)
        (Expmatch.mchar 3)
        []
        (Regexp_of_list [])
        (Expmatch.mempty)
      )
    )
  )

</code></pre>
<p>We can also prove general facts about Exp_match. For example, the following lemma shows that every string <code>s</code> that matches <code>re</code> also matches <code>Star re</code>.</p>
<pre><code class="language-rust ignore">Mstar1 &lt;t&gt; &lt;s: List t&gt; &lt;re: Regexp t&gt; (e: Expmatch s re) : Expmatch s (Regexp.star re)  
Mstar1 t s re e = 
  let msz = Expmatch.mstarz re
  let mss = Expmatch.mstarapp s [] re e msz
  let lst = List_concat s
  let rwt = Equal.rewrite lst (x =&gt; (Expmatch t x (Regexp.star re))) mss
  rwt

</code></pre>
<p>(Note the use of appendNilRightNeutral*** to change the goal of the theorem to exactly the same form expected by MStarApp.)</p>
<h4 id="exp_match_ex1"><a class="header" href="#exp_match_ex1">Exp_match_ex1</a></h4>
<p>The following lemmas show that the informal matching rules provided at the beginning of the chapter can be derived from the formal inductive definition.</p>
<pre><code class="language-rust ignore">  Munion 
  &lt;t&gt; 
  &lt;s: List t&gt; 
  &lt;re1:  Regexp t&gt; 
  &lt;re2:  Regexp t&gt; 
  (p: Pair (Expmatch s re1) (Expmatch s re2))
  : Expmatch s (Regexp.union re1 re2)
Munion t s re1 re2 (Pair.new fst snd) = 
  Expmatch.munionl t s [] re1 re2</code></pre>
<p>The next lemma is stated in terms of the fold function from the Poly chapter: <code>If ss: List (List t)</code> represents a sequence of strings s1, ..., sn, then <code>fold (++) ss []</code> is the result of concatenating all of them.</p>
<pre><code class="language-rust ignore">Fold &lt;x&gt; &lt;y&gt; (f: x -&gt; y -&gt; y) (l: Data.List x) (b: y) : y
Fold x y f Data.List.nil b = b
Fold x y f (Data.List.cons xs.h xs.t) b = f xs.h (Fold f xs.t b) 

MStar_ &lt;t&gt;
  (ss : Data.List (Data.List t))
  (re : Regexp t)
  (construct_match : (s : Data.List t) -&gt; (i : In s ss) -&gt; Expmatch s re)
  : Expmatch (Concats ss) (Regexp.star re)
MStar_ ss re construct_match = ?</code></pre>
<h4 id="reg_exp_of_list"><a class="header" href="#reg_exp_of_list">Reg_exp_of_list</a></h4>
<p>Prove that reg_exp_of_list satisfies the following specification:</p>
<pre><code class="language-rust ignore">Reg_exp_of_list_spec &lt;t&gt; (s1: Data.List t) (s2: Data.List t) : Iff (Expmatch s1 (Regexp_of_list s2)) (Prop.Equal s1 s2)
Reg_exp_of_list_spec s1 s2 = ?</code></pre>
<p>Since the definition of Exp_match has a recursive structure, it is expected that proofs involving regular expressions often require induction based on evidence. For example, suppose we wanted to prove the following intuitive result: if a regular expression re matches some string s, then every element of s must occur somewhere in re. To state this theorem, we first define a function re_chars that lists all characters occurring in a regular expression:</p>
<pre><code class="language-rust ignore">Re_chars &lt;t&gt; (re: Regexp t) : Data.List t
Re_chars t Regexp.emptyset  = []
Re_chars t Regexp.emptystr  = []
Re_chars t (Regexp.chr x)   = [x]
Re_chars t (Regexp.app r0 r1) = Data.List.concat (Re_chars r0) (Re_chars r1)
Re_chars t (Regexp.union r0 r1) = Data.List.concat (Re_chars r0) (Re_chars r1)
Re_chars t (Regexp.star r0) = Re_chars r0

Re_star &lt;t&gt; (re: Regexp t) : Prop.Equal (Re_chars (Regexp.star re)) (Re_chars re)
Re_star e re = Prop.Equal.refl</code></pre>
<p>We can then formulate our theorem as follows:</p>
<pre><code class="language-rust ignore">Destruct &lt;a&gt; (x: a) (lx: Data.List a) (ly: Data.List a) (i: In x (Data.List.concat a lx ly)) : (Data.Either (In x lx) (In x ly))
Destruct a x lx ly i =  
  let Data.Pair.new fst snd = (In_app_iff x lx ly) 
  let f = (fst :: (_) -&gt; (_)) i 
  f

Construct &lt;a&gt; (x: a) (lx: Regexp a) (ly: Regexp a) (e: Data.Either (In x (Re_chars lx)) (In x (Re_chars ly))) : In x (Data.List.concat (Re_chars lx) (Re_chars ly))
Construct a x lx ly e = (Data.Pair.snd ( In_app_iff x (Re_chars lx) (Re_chars ly)) :: (_) -&gt; (_)) e

In_re_match &lt;a&gt; (x: a) (re: Regexp a) (s: Data.List a) (e: Expmatch s re) (i: In x s) : In x (Re_chars re)
In_re_match a x (Regexp.emptyset) Data.List.nil e i = i
In_re_match a x (Regexp.emptyset) (Data.List.cons head tail) e i = Data.Empty.absurd _ //todo
In_re_match a x (Regexp.emptystr) (Data.List.nil) Expmatch.mempty i = i
In_re_match a x (Regexp.chr u s)  (Data.List.cons t re (Data.List.nil _)) (Expmatch.mchar c) i = 
  let e0 = Prop.Equal.refl :: Prop.Equal c re
  let e1 = Prop.Equal.refl :: Prop.Equal s c
  let chn = Prop.Equal.chain e1 e0
  let rrt = Prop.Equal.rewrite (Prop.Equal.mirror chn) (y =&gt; (Data.Either (Prop.Equal _ x y) _)) i 
  rrt
In_re_match a x (Regexp.app t z y) (Data.List.concat u l1 l2) e i = 
  let e0 = Prop.Equal.refl :: Prop.Equal u a
  let l3 = l1 :: Data.List a
  let l4 = l2 :: Data.List a
  let e1 = Prop.Equal.refl :: Prop.Equal l1 l3
  let e2 = Prop.Equal.refl :: Prop.Equal l2 l4
  let e3 = Prop.Equal.refl :: Prop.Equal  (Data.List.concat u l1 l2) (Data.List.concat a l3 l4) 
  let i = i :: (In a x (Data.List.concat u l1 l2))
  let rrt = Prop.Equal.rewrite e3 ((k: (Data.List a))=&gt; (In a x k)) i 
  let des = Destruct x l3 l4 rrt
  des
In_re_match a x re Data.List.nil (Expmatch.mstarz z) i = Data.Empty.absurd _ //todo</code></pre>
<h4 id="re_not_empty"><a class="header" href="#re_not_empty">Re_not_empty</a></h4>
<p>Write a recursive function re_not_empty that tests whether a regular expression matches any string. Prove that your function is correct.</p>
<pre><code class="language-rust ignore">Re_not_empty &lt;t&gt; (re: Regexp t)   : Data.Bool
Re_not_empty t re = ?

Re_not_empty_correct &lt;t&gt; &lt;re: Regexp t&gt; 
: Equivalence (Data.Sigma (Data.List t) (s =&gt; Expmatch s re)) (Prop.Equal (Re_not_empty re) Data.Bool.true)
Re_not_empty_correct t re = ?
</code></pre>
<h3 id="the-remember-tactic"><a class="header" href="#the-remember-tactic">The remember Tactic</a></h3>
<p>Rewriting the section, dependent pattern matching solves all of this.</p>
<p>A potentially confusing feature of the induction tactic is that it easily allows you to attempt setting up an induction on a term that is not sufficiently general. The effect of this is to lose information (just as destruct can do) and leave you unable to conclude the proof. Here's an example:</p>
<pre><code class="language-rust ignore">Star_app  &lt;a&gt; (re: Regexp a) (s1: Data.List a) (s2: Data.List a) (exp0: Expmatch a s1 (Regexp.star re)) (exp1: Expmatch a s2 (Regexp.star re)) 
: (Expmatch (Data.List.concat s1 s2) (Regexp.star re))
Star_app a re (Data.List.nil _) s2 (Expmatch.mstarz e) exp1 = exp1
Star_app a re s1 s2 (Expmatch.mstarapp t r s r1 m ms) exp1 = 
  let e0 = Prop.Equal.refl :: Prop.Equal r1 re
  let e1 = Prop.Equal.refl :: Prop.Equal (Data.List.concat r s) s1
  let ind = Expmatch.mstarapp m (Star_app r1 s s2 ms exp1)
  let rrt = Prop.Equal.rewrite e0 (x =&gt; (Expmatch _ _ (Regexp.star _ x))) ind
  let aux = App_assoc r s s2
  let rrt = Prop.Equal.rewrite aux (x =&gt; (Expmatch _ (x) (_))) rrt
  let rrt = Prop.Equal.rewrite e1 (x =&gt; (Expmatch t (Data.List.concat _ x s2) (Regexp.star t re))) rrt
  rrt</code></pre>
<!-- TL:DR
Agora podemos prosseguir realizando a indução diretamente com base nas evidências, porque o argumento da primeira hipótese é suficientemente geral, o que significa que podemos descartar a maioria dos casos invertendo a igualdade re' = Star re no contexto. Esse padrão é tão comum que o Kind fornece uma tática para gerar automaticamente tais equações para nós, evitando assim a necessidade de alterar as declarações de nossos teoremas. -->
<h4 id="exp_match_ex2"><a class="header" href="#exp_match_ex2">Exp_match_ex2</a></h4>
<pre><code class="language-rust ignore">MStar2 &lt;t&gt; (re: Regexp t) (s: Data.List t) (ss: Data.List (Data.List t)) (exp: Expmatch s (Regexp.star re)) 
: (Data.Pair (Prop.Equal s (Fold (x =&gt; y =&gt; Data.List.concat x y ) ss [])) ((s2: Data.List t) -&gt; (In s2 ss) -&gt; (Expmatch s2 re)))</code></pre>
<p>The lemma MStar'' below (along with its inverse, the exercise MStar' above), shows that our definition of Exp_match for Star is equivalent to the one informally given earlier.</p>
<h4 id="pumping"><a class="header" href="#pumping">pumping</a></h4>
<p>One of the earliest truly interesting theorems in the theory of regular expressions is the so-called pumping lemma, which states, informally, that any sufficiently long string s matching a regular expression re can be &quot;pumped&quot; by repeating some middle section of s an arbitrary number of times to produce a new string also matching re.</p>
<p>To start, we need to define what it means to be &quot;sufficiently long&quot;. Since we are working in a constructive logic, we actually need to be able to compute, for each regular expression re, the minimum length for strings s to guarantee &quot;pumpability&quot;.</p>
<pre><code class="language-rust ignore">
pumping_constant :</code></pre>
<p>Next, it is useful to define an auxiliary function that repeats a string (appends itself) a certain number of times.</p>
<pre><code class="language-rus't ignore">napp :

</code></pre>
<p>Now, the pumping lemma itself states that if <code>s =&gt; re</code> and if the length of <code>s</code> is at leas't the pumping constant of <code>re</code>, then <code>s</code> can be divided into three substrings <code>s1 ++ s2 ++ s3</code> such that <code>s2</code> can be repeated any' number of times, and the result, when combined with <code>s1</code> and <code>s3</code>, will still match <code>re</code>. Since D is also guaranteed to be non-empty, this gives us a (constructive!) way of generating strings matching <code>re</code> that are as long as we desire.</p>
<pre><code class="language-rust ignore">
pumping :</code></pre>
<p>To speed up the proof (which you should fill in), the omega tactic, which is enabled by the Require below, is helpful in several places to automatically complete tedious low-level arguments involving equalities or inequalities over natural numbers. We will revisit the omega tactic in a later chapter, but feel free to try it now if you'd like. The first case of the induction gives an example of how it is used.</p>
<pre><code class="language-rust ignore">
pumping m le = ?pumping_rhs</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="case-study-improving-reflection"><a class="header" href="#case-study-improving-reflection">Case Study: Improving Reflection</a></h2>
<p>In the Logic chapter, we saw that we often need to relate Boolean computations to Type statements. However, performing this conversion as we did there can result in tedious proof scripts. Consider the proof of the following theorem:</p>
<pre><code class="language-rust  ignore">filter_not_empty_In : {n : Nat} -&gt; Not (filter ((==) n) l = []) -&gt; In n l //terminar</code></pre>
<p>In the second case, we explicitly apply the beq_nat_true lemma to the equation generated when doing a dependent match on <code>n == x</code>, to convert the assumption <code>n == x = Bool.true</code> into <code>n = m</code>.`</p>
<p>We can simplify this by defining an inductive proposition that provides a better case analysis principle for <code>n == m</code>. Instead of generating an equation like <code>n == m = Bool.true</code>, which is often not directly useful, this principle immediately gives us the assumption we actually need: <code>n = m</code>.</p>
<p>In fact, we will define something slightly more general, which can be used with arbitrary properties (not just equalities):</p>
<pre><code class="language-rust  ignore">type Reflect  (p: Type) (b: Bool) { //TODO: corrigir
  ReflectT    (p: Type) (b = True) : Reflect p b
  ReflectF    (p: Type) (n: Not p) (b = False) : Reflect p b
}</code></pre>
<p>The &quot;reflect&quot; property takes two arguments: a proposition p and a Boolean b. Intuitively, it states that the property p is reflected in (i.e., equivalent to) the Boolean b: p is true if and only if <code>b = Bool.true</code>. To understand this, note that by definition, the only way to obtain evidence that &quot;Reflect p True&quot; is true is by showing that p is true and using the &quot;ReflectT&quot; constructor. If we reverse this statement, it means that it should be possible to extract evidence for p from a proof of &quot;Reflect p True&quot;. Similarly, the only way to show &quot;Reflect p False&quot; is by combining evidence of &quot;Not p&quot; with the &quot;ReflectF&quot; constructor.</p>
<p>It is easy to formalize this intuition and show that the two statements are indeed equivalent:</p>
<pre><code class="language-rust  ignore">Equiv_reflect &lt;b: Bool&gt; (e: Equiv p  (b = True)) : Reflect p b
Equiv_reflect Bool.false (pb, _) = ReflectF (uninhabited . pb) Equal.refl
Equiv_reflect Bool.true (_, bp)  = ReflectT (bp Refl) Equal.refl</code></pre>
<h4 id="reflect_equiv"><a class="header" href="#reflect_equiv">Reflect_equiv</a></h4>
<pre><code class="language-rust  ignore">Reflect_equiv (r: Reflect p b) : Equivalence p  (Bool.equal b Bool.true)
Reflect_equiv x = ?</code></pre>
<p>The advantage of &quot;Reflect&quot; over the usual &quot;if and only if&quot; connective is that when we destruct a hypothesis or lemma of the form &quot;Reflect p b&quot;, we can perform a case analysis on b while simultaneously generating appropriate hypotheses in both branches (p in the first subgoal and Not p in the second).</p>
<pre><code class="language-rust  ignore">Beq_natP &lt;n: Nat&gt; &lt;m : Nat&gt; :  Reflect (Equal n m) (Nat.equal n m)
Beq_natP {n} {m} = iff_reflect (iff_sym (beq_nat_true_iff n m))</code></pre>
<p>The new proof of filter_not_empty_In now proceeds as follows. Notice how the calls to destruct and apply are combined into a single destruct call.</p>
<p>(To see this clearly, compare the two proofs of filter_not_empty_In with Kind and observe the differences in the proof state at the beginning of the first case of destruct.)</p>
<pre><code class="language-rust  ignore">Filter_not_empty_In_ &lt;n : Nat&gt; &lt;n: Not (filter ((x =&gt; y =&gt; Nat.equal x y) n) l = []) : In n l</code></pre>
<h4 id="beq_natp_practice"><a class="header" href="#beq_natp_practice">Beq_natP_practice</a></h4>
<p>Use beq_natP, as mentioned above, to prove the following:</p>
<pre><code class="language-rust  ignore">Count (n : Nat) : (l : List Nat) : Nat
Count n List.nil = 0n
Count n (List.cons xs.h xs.t) = Nat.add (Bool.if (Nat.equal n xs.h) 1n 0n)  (Count n xs.t)

Beq_natP_practice (e: Equal (count n l) Nat.zero) : Not (In n l)
Beq_natP_practice e = ? </code></pre>
<p>Indeed, this technique provides us with only a small convenience advantage for the proofs we have seen here, but using &quot;Reflect&quot; consistently often results in noticeably shorter and clearer proof scripts as the proofs grow larger. We will see many more examples in the upcoming chapters.</p>
<p>The use of the &quot;reflect&quot; property was popularized by SSReflect, a Coq library that has been used to formalize important results in mathematics, including the Four Color Theorem and the Feit-Thompson Theorem. The name SSReflect stands for &quot;small-scale reflection,&quot; which refers to the widespread use of reflection to simplify small proof steps involving Boolean computations.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="additional-exercises-1"><a class="header" href="#additional-exercises-1">Additional Exercises</a></h2>
<h4 id="nostutter"><a class="header" href="#nostutter">Nostutter</a></h4>
<p>Formulating inductive definitions of properties is an important skill that you will need in this course. Try to solve this exercise without any help.</p>
<p>We say that a list &quot;stutters&quot; if it repeats the same element consecutively. The property &quot;Nostutter my_list&quot; means that my_list does not stutter. Formulate an inductive definition for Nostutter. (This is different from the NoDup property in the exercise below; the sequence [1,4,1] repeats but does not stutter.)</p>
<pre><code class="language-rust  ignore">type Nostutter &lt;t&gt; (l: List t) {
  RemoveMe : Nostutter []
}</code></pre>
<p>Make sure each of these tests passes, but feel free to change the suggested proof (in comments) if it does not work for you. Your definition may be different from ours and still be correct; in that case, the examples may need a different proof. (You will notice that the suggested proofs use various tactics we have not discussed to make them more robust against the different possible ways of defining Nostutter. You can probably just uncomment them and use them as is, but you can also prove each example with more basic tactics.)</p>
<pre><code class="language-rust  ignore">Test_nostutter_1 : Nostutter [3n,1n,4n,1n,5n,6n]
Test_nostutter_1 = ?
// Prova. repita o construtor; aplique beq_nat_false_iff; auto.

Test_nostutter_2 : Nostutter []
Test_nostutter_2 = ?
// Prova. repita o construtor; aplique beq_nat_false_iff; auto.

Test_nostutter_3 : Nostutter [5n]
Test_nostutter_3 = ?
// Prova. repita o construtor; aplique beq_nat_false; auto. Qed.

Test_nostutter_4 : Not (Nostutter [3n,1n,1n,4n])
Test_nostutter_4 = ?
// Prova. intro.
// repetir correspondência de metas com
// h: nostutter _ |- _ =&gt; inversão h; limpar h; subst
// end.
// contradição H1; auto.</code></pre>
<h4 id="filter_challenge"><a class="header" href="#filter_challenge">Filter_challenge</a></h4>
<p>Let's prove that our definition of filter from the Poly chapter corresponds to an abstract specification. Here is the specification, informally written in English:</p>
<p>A list l is an &quot;ordered merge&quot; of l1 and l2 if it contains all the same elements as l1 and l2, in the same order as l1 and l2, but possibly interleaved. For example,</p>
<p>[1n,4n,6n,2n,3n] is an ordered merge of [1n,6n,2n] and [4n,3n].</p>
<p>Now, suppose we have a set t, a function test: t -&gt; Bool, and a list l of type List t. Suppose further that l is an ordered merge of two lists, l1 and l2, such that every item in l1 satisfies test and no item in l2 satisfies test. Then, filter test l = l1.</p>
<p>Translate this specification into a theorem in Kind and prove it. (You will need to start by defining what it means for a list to be an ordered merge of two lists. Do this with an inductive data type, not a function.)</p>
<h4 id="filter_challenge_2"><a class="header" href="#filter_challenge_2">Filter_challenge_2</a></h4>
<p>A different way to characterize the behavior of filter is as follows: Among all the subsequences of l that have the property that test evaluates to True for all their elements, filter test l is the longest one. Formalize this statement and prove it.</p>
<h4 id="palindromes"><a class="header" href="#palindromes">Palindromes</a></h4>
<p>A palindrome is a sequence that reads the same forwards and backwards.</p>
<ul>
<li>
<p>Define an inductive proposition Pal about List t that captures what it means to be a palindrome. (Hint: You will need three cases. Your definition should be based on the structure of the list; having just a single constructor like</p>
<pre><code class="language-Rust  ignore">C &lt;t&gt; (l : List t)  (rev: Equal l (Rev l)) : Pal l
</code></pre>
<p>may seem obvious, but it won't work very well.)</p>
</li>
<li>
<p>Prove (pal_app_rev) that</p>
<pre><code class="language-rust  ignore">(l : List t) : Pal (List.concat l (Rev l))</code></pre>
</li>
<li>
<p>Prove (pal_rev) that</p>
<pre><code class="language-rust  ignore">  (l : List t) (p: Pal l) : Equal l (Rev l)</code></pre>
</li>
</ul>
<h4 id="palindrome_converse"><a class="header" href="#palindrome_converse">Palindrome_converse</a></h4>
<p>Again, the reverse direction is significantly harder, due to the lack of evidence. Using your definition of Pal from the previous exercise, prove that</p>
<pre><code class="language-rust  ignore">(l : List t) ( Equal l (Rev l)) Pal l</code></pre>
<h4 id="nodup"><a class="header" href="#nodup">NoDup</a></h4>
<p>Remember the definition of the In property from the Logic chapter, which states that a value x appears at least once in a list l:</p>
<pre><code class="language-rust  ignore">In &lt;t&gt; (x : t) (l : List t) : Type
In x List.nil = Empty
In x (List.concat xs.h xs.t) = Either (Equal x xs.h)  (In x xs)</code></pre>
<p>Your first task is to use In to define an inductive proposition <code>Disjoint &lt;t&gt; l1 l2</code>, which should be provable exactly when l1 and l2 are lists (with elements of type t) that have no elements in common.</p>
<p>Next, use In to define an inductive proposition <code>NoDup &lt;t&gt; l</code>, which should be provable exactly when <em>l</em> is a list (with elements of type t) in which every member is different from all the others. For example, <code>NoDup U60 [1,2,3,4]</code> and <code>NoDup Bool []</code> should be provable, while <code>NoDup Nat [1n,2n,1n]</code> and <code>NoDup Bool [Bool.true,Bool.true]</code> should not.</p>
<p>Finally, state and prove one or more interesting theorems that relate Disjoint, NoDup, and List.</p>
<h4 id="pigeonhole-principle"><a class="header" href="#pigeonhole-principle">Pigeonhole principle</a></h4>
<p>The pigeonhole principle states a basic fact about counting: if we distribute more than n items into n pigeonholes, some pigeonhole must contain at least two items. As often happens, this seemingly trivial fact about numbers requires nontrivial machinery to prove, but now we have enough...
First, prove an easy and useful lemma.</p>
<pre><code class="language-rust  ignore">In_split 
  &lt;t&gt; 
  &lt;x: t&gt; 
  &lt;l: List t&gt; 
  (i: In x l) 
  : ([l1] -&gt; [l2] -&gt; ((Equal l (List.concat l1  (List.cons x  l2)))))
In_split i = ?</code></pre>
<p>Now define a property Repeats in such a way that <code>Repeats &lt;t&gt; l</code> asserts that <em>l</em> contains at least one repeated element (of type t).</p>
<pre><code class="language-rust  ignore">type  Repeats &lt;t&gt; (l: List t) {
  // PREENCHA AQUI
  RemoveMe' : Repeats [] // necessário para verificação de tipo, os dados não devem estar vazios
}</code></pre>
<p>This proof is much easier if you use the <em>excluded_middle</em> hypothesis to show that In is decidable, i.e., <code>Either (In x l) (Not (In x l))</code>. However, it is also possible to do the proof without assuming that In is decidable; if you can do that, you won't need the <em>excluded_middle</em> hypothesis.</p>
<p>Here is one way to formalize the pigeonhole principle. Suppose the list l2 represents a list of pigeonhole labels, and the list l1 represents the labels assigned to a list of items. If there are more items than labels, at least two items must have the same label—i.e., the list l1 must contain repetitions.</p>
<pre><code class="language-rust  ignore">Pigeonhole_principle &lt;t&gt; (x: t) 
 (l1: Data.List t) 
 (l2: Data.List t) 
 (i1: In x l1) 
 (i2: In x l2) 
 (lt: Lt (Data.List.length l1) (Data.List.length l2)) 
 : Repeats l1
Pigeonhole_principle t x l1 l2 i2 i2 lt = ?

Excluded_middle : (p : Type) : Either p (Not p)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contribuidores"><a class="header" href="#contribuidores">Contribuidores</a></h1>
<ul>
<li><a href="https://github.com/NaoEhSavio">NaoEhSavio</a></li>
<li><a href="https://github.com/SergioBonatto">Bonatto</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
