<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="guide/Started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guide/About.html"><strong aria-hidden="true">1.1.</strong> About Kind</a></li><li class="chapter-item expanded "><a href="guide/Installation.html"><strong aria-hidden="true">1.2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="cli/World.html"><strong aria-hidden="true">1.3.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="cli/kind.html"><strong aria-hidden="true">1.4.</strong> Hello Kind!</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Book</li><li class="chapter-item expanded "><a href="Book/chapter_02/2,1.html"><strong aria-hidden="true">2.</strong> Basics: Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/chapter_02/2,2.html"><strong aria-hidden="true">2.1.</strong> Enumerated Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/chapter_02/2,2,1.html"><strong aria-hidden="true">2.1.1.</strong> Days of the Week</a></li></ol></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,3.html"><strong aria-hidden="true">2.2.</strong> Booleans</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,4.html"><strong aria-hidden="true">2.3.</strong> Function Types</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,5.html"><strong aria-hidden="true">2.4.</strong> Modules</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,6.html"><strong aria-hidden="true">2.5.</strong> Numbers</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,7.html"><strong aria-hidden="true">2.6.</strong> Proof by Simplification</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,8.html"><strong aria-hidden="true">2.7.</strong> Proof by Application</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,9.html"><strong aria-hidden="true">2.8.</strong> Proof by Case Analysis</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,10.html"><strong aria-hidden="true">2.9.</strong> Proof by Rewriting</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,11.html"><strong aria-hidden="true">2.10.</strong> Equal.chain and Equal.mirror</a></li><li class="chapter-item expanded "><a href="Book/chapter_02/2,12.html"><strong aria-hidden="true">2.11.</strong> More Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="Book/chapter_03/3.html"><strong aria-hidden="true">3.</strong> Induction: Proof by Induction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/chapter_03/3,1.html"><strong aria-hidden="true">3.1.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="Book/chapter_03/3,2.html"><strong aria-hidden="true">3.2.</strong> More Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="Book/chapter_04/4.html"><strong aria-hidden="true">4.</strong> Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/chapter_04/4,1.html"><strong aria-hidden="true">4.1.</strong> Lists of Numbers</a></li><li class="chapter-item expanded "><a href="Book/chapter_04/4,2.html"><strong aria-hidden="true">4.2.</strong> Reasoning about Lists</a></li><li class="chapter-item expanded "><a href="Book/chapter_04/4,3.html"><strong aria-hidden="true">4.3.</strong> Maybe</a></li></ol></li><li class="chapter-item expanded "><a href="Book/chapter_05/5.html"><strong aria-hidden="true">5.</strong> Polymorphism</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/chapter_05/5,1.html"><strong aria-hidden="true">5.1.</strong> Functions as Data</a></li><li class="chapter-item expanded "><a href="Book/chapter_05/5,2.html"><strong aria-hidden="true">5.2.</strong> Additional Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="Book/chapter_06/6.html"><strong aria-hidden="true">6.</strong> Logic in Kind</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Book/chapter_06/6,1.html"><strong aria-hidden="true">6.1.</strong> Logical Connectives</a></li><li class="chapter-item expanded "><a href="Book/chapter_06/6,2.html"><strong aria-hidden="true">6.2.</strong> Falsity and Negation</a></li><li class="chapter-item expanded "><a href="Book/chapter_06/6,3.html"><strong aria-hidden="true">6.3.</strong> Truth, Equivalence, and Quantification</a></li><li class="chapter-item expanded "><a href="Book/chapter_06/6,4.html"><strong aria-hidden="true">6.4.</strong> Programming with Propositions</a></li><li class="chapter-item expanded "><a href="Book/chapter_06/6,5.html"><strong aria-hidden="true">6.5.</strong> Applying Theorems to Arguments</a></li><li class="chapter-item expanded "><a href="Book/chapter_06/6,6.html"><strong aria-hidden="true">6.6.</strong> Kind vs Set Theory</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="Contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Hello, world! Welcome to the wonderful world of programming. This is an incredibly exciting and challenging field, full of possibilities and opportunities. We are eager to see what you will create and build during your learning journey.</p>
<p>When it comes to programming, it is essential to understand the importance of precision and safety in code. That's why we would like to talk about Kind, a powerful formal model checker for real-time systems. It allows you to specify desired properties for your system and automatically generates test cases to ensure that the system meets these properties. This is particularly valuable for critical projects, such as security systems, where accuracy and safety are crucial.</p>
<p>Programming is a constant journey of learning and personal development. Don't feel discouraged if you encounter difficulties along the way, these difficulties are part of the learning process and opportunities to grow and evolve. Remember that we are here to help you along the way, don't hesitate to ask for help if you need it.</p>
<p>Be prepared to work hard and face challenges, but also be prepared to celebrate your accomplishments and achievements. Remember to have fun and enjoy every moment of this incredible learning journey.</p>
<p>Good luck on your learning journey, and we look forward to seeing what you will create and build.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starting"><a class="header" href="#starting">Starting</a></h1>
<h2 id="welcome-to-kind"><a class="header" href="#welcome-to-kind">Welcome to Kind!</a></h2>
<p>Kind is an efficient, minimalist, and practical language that aims to rethink functional programming from scratch with a modern and consistent design.</p>
<p>The goal of this documentation is to be as simple as possible to learn Kind. That's why we decided to adopt a minimalist and simple design so that you can quickly find what you need.</p>
<p>Quick Navigation Index</p>
<ul>
<li>About Kind;</li>
<li>Installation guide for MacOS, Linux, and Windows;</li>
<li>Command guide;</li>
<li>Learning the basic concepts of Kind;</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-kind"><a class="header" href="#hello-kind">Hello, Kind!</a></h1>
<p>Kind is a programming language that aims to be practical and conventional. It is statically typed, which means that data types are defined beforehand and checked at compile time. These types are powerful enough to allow the proof of mathematical theorems.</p>
<p>When creating a new program in Kind, you have access to a vast universe of resources and functionalities. It's like all the tools you need are already there, ready to be used. With each new function or library you discover, it's like a new part of this universe is revealed.</p>
<p>Just like in a real universe, there is always something new to be discovered in Kind. There is a plethora of resources and tools available for you to explore and use in your programs. With such variety, it's possible to create solutions for practically any problem you can imagine.</p>
<p>If you're interested in learning more about programming and exploring the vast universe of Kind, then becoming a Kind programmer can be an exciting and rewarding adventure. There are many other Kind programmers out there to collaborate and learn with, making this journey even more exciting.</p>
<p>In summary, Kind is a modern, powerful, and versatile programming language that offers many opportunities for those who want to learn and explore the vast universe of programming. If you're interested in becoming a Kind programmer, there are many resources available to help you get started, from official documentation to active communities of users and developers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>This guide teaches you how to download and install Kind through Rust, using &quot;Cargo&quot;, a tool used to manage packages. It may be necessary to have an internet connection to proceed with this guide.</p>
<p>Firstly, install Rust using this <a href="https://www.rust-lang.org/tools/install">link</a></p>
<ul>
<li><em>Currently, Cargo is the only way to install Kind.</em></li>
<li><em>This guide was written when Kind was in beta version. Therefore, it is necessary to install the</em> <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly version</a>.</li>
</ul>
<h3 id="installing-kind-on-linux-or-macos"><a class="header" href="#installing-kind-on-linux-or-macos">Installing Kind on Linux or MacOS</a></h3>
<p>Use your package manager (Cargo) to install Kind. To do this, open the terminal and type the following code:</p>
<pre><code>cargo +nightly install kind2
</code></pre>
<h3 id="installing-kind-on-windows"><a class="header" href="#installing-kind-on-windows">Installing Kind on Windows</a></h3>
<p>For Windows users, it is possible to use Kind through CMD or WSL2. If you choose WSL, the installation method is in this <a href="https://harsimranmaan.medium.com/install-and-setup-rust-development-environment-on-wsl2-dccb4bf63700">link</a>.</p>
<p>Use your package manager (Cargo) to install Kind. To do this, open Bash(WSL2) or Terminal(CMD) and type the following command:</p>
<pre><code>cargo +nightly install kind2
</code></pre>
<h3 id="cloning-the-kind-repository---method-1"><a class="header" href="#cloning-the-kind-repository---method-1">Cloning the Kind Repository - Method 1</a></h3>
<p>Clone the Kind repository using the git command &quot;git clone&quot;, as follows:</p>
<pre><code>git clone https://github.com/HigherOrderCO/Kind
</code></pre>
<p>After the cloning step, use the following command for installation:</p>
<pre><code>cargo +nightly install --path crates/kind-cli --force
</code></pre>
<h3 id="cloning-the-kind-repository---method-2"><a class="header" href="#cloning-the-kind-repository---method-2">Cloning the Kind Repository - Method 2</a></h3>
<p>Cargo allows you to install using git, without the need to clone any repository, as follows:</p>
<pre><code>cargo +nightly install --git https://github.com/HigherOrderCO/kind.git 
</code></pre>
<p>By following the above steps, we can start using Kind.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h1>
<p>At this point, Kind should already be installed on your machine. If not, please go back to the installation and follow the instructions.</p>
<p>In this guide, we will be using command lines and text editors, so make sure your terminal is open to proceed with the steps.</p>
<h3 id="creating-the-files"><a class="header" href="#creating-the-files">Creating the Files</a></h3>
<p>First of all, create a directory to store the Kind files. It is recommended to use a dedicated directory to keep all exercises and examples, but feel free to do as you please. The three commands below will create a directory named 'KindExamples' and a file named 'hello_world.kind2' inside the project directory. Use them in order:</p>
<pre><code class="language-diff">// Linux, Mac or WSL
mkdir KindExamples
cd    KindExamples
touch hello_world.kind2
</code></pre>
<p>The .kind2 extension is what makes it a Kind file. For example, a file that ends with .exe is an executable; .js is a JavaScript file; .rs is a Rust file, etc.</p>
<p>If the commands were used correctly, the hello_world.kind2 file should be inside the KindExamples folder. So let's have some fun, CODING!</p>
<h3 id="hello-world-1"><a class="header" href="#hello-world-1">Hello World</a></h3>
<p>Open the hello_world.kind2 file in your text editor, it will be empty, but don't worry. From now on, there will be some advanced concepts. Everything will make sense in the future, and pertinent concepts will be explained in due time. It is recommended that you manually type the codes, instead of copying and pasting them into your file.</p>
<p>Let's write your first code in the hello_world.kind2 file:</p>
<pre><code class="language-Rust">Main {
  &quot;Hello, Kind!&quot;
}
</code></pre>
<h3 id="type-checking"><a class="header" href="#type-checking">Type Checking</a></h3>
<p>With the code ready, you should use Type Checking to check if everything is in order. The type checker is still unknown in this guide, but it will be explained in more detail later. For now, just understand it as a checker that verifies if the file is correctly &quot;typed&quot;.</p>
<p>To check the type of a Kind file, simply use the command <code>kind2 check nomeDoArquivo.kind2</code>. For the hello_world.kind2 file, it would be:</p>
<pre><code>kind2 check hello_world.kind2
</code></pre>
<p>The message <code>All terms check.</code> means your file is ready!</p>
<pre><code>All terms check.
</code></pre>
<p>Is the type checking correct? Then let's run the code.</p>
<h3 id="running-the-code"><a class="header" href="#running-the-code">Running the code</a></h3>
<p>To run a file in Kind, use the command <code>kind2 run nomeDoArquivo.kind2</code>. It should look like this:</p>
<pre><code>kind2 run hello_world.kind2
</code></pre>
<p>And there you go! Your terminal should print &quot;Hello, Kind!&quot; back to you.</p>
<h4 id="remember-to-do-all-the-steps-above-check-the-type-and-then-run"><a class="header" href="#remember-to-do-all-the-steps-above-check-the-type-and-then-run">Remember to do all the steps above, check the type, and then run</a></h4>
<p>Great, now that you have your first Kind program running, you can start exploring more about the language and its features. Congratulations on your progress!</p>
<p>If you have any questions or need help, don't hesitate to ask. We are always available to help!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-kind-1"><a class="header" href="#hello-kind-1">Hello Kind!</a></h1>
<p>Now that you have learned how to create and run a Kind file, let's dive deeper into the basics of Kind. In the next section, you will learn about Kind's type system, syntax, variables, and functions.</p>
<h4 id="kinds-type-system"><a class="header" href="#kinds-type-system">Kind's Type System</a></h4>
<p>Kind has a static type system, which means that the type of a variable must be known at compile-time. Kind has a rich type system that includes primitive types, algebraic data types, and type parameters.</p>
<h4 id="kind-syntax"><a class="header" href="#kind-syntax">Kind Syntax</a></h4>
<p>Kind's syntax is inspired by functional programming languages like Haskell. The syntax is concise and expressive, making it easy to read and write code. It uses indentation instead of braces to define blocks of code.</p>
<h4 id="variables"><a class="header" href="#variables">Variables</a></h4>
<p>In Kind, variables are declared using the keyword let followed by the variable name. For example:</p>
<pre><code>let x = 42
</code></pre>
<h4 id="functions"><a class="header" href="#functions">Functions</a></h4>
<p>Functions in Kind are declared using the first letter capitalized. The function may take parameters or not and returns a value. For example:</p>
<pre><code>Nat.add (a: Nat) (b: Nat) : Nat
</code></pre>
<p>This is just a brief overview of the basics of Kind. You will learn more about these concepts as you progress through the guide. Now that you have learned about Kind's basics, it's time to move on to the next section and learn about advanced concepts in Kind programming.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>The functional programming style brings programming closer to simple and everyday
mathematics: If a procedure or method has no side effects, then (ignoring efficiency)
all we need to understand about it is how to map inputs to outputs - in other words,
we can think of it as a concrete method that computes a mathematical function.
This is one sense of &quot;functional&quot; in &quot;functional programming&quot;. The direct connection
between programs and simple mathematical objects supports both the formality of
correctness proofs and informal reasoning about program behavior.</p>
<p>The other sense in which functional programming is &quot;functional&quot; is that it emphasizes
the use of functions as first-class values - that is, values that can be passed as
arguments to other functions, returned as results, included in data structures, etc.
The recognition that functions can be treated in this way as data enables a range of
useful commands.</p>
<p>Other common features of functional languages include algebraic data types and pattern
matching, which make it easy to construct and manipulate data structures, and sophisticated
polymorphic type systems, supporting abstraction and code reuse. Kind contains all of these
features.</p>
<p>The first half of this chapter introduces the most basic elements of the Kind functional
programming language. The second half introduces some basic techniques that can be used
to prove properties about programs in Kind.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="enumerated-types"><a class="header" href="#enumerated-types">Enumerated Types</a></h2>
<p>An unusual aspect of Kind, similar to other proof languages such as Idris and Coq, is that its built-in toolset is quite small. For example, instead of providing the usual range of primitive types (booleans, lists, strings, etc), Kind has only two primitive types (U60: unsigned 60-bit binary integers) and (F60: unsigned 60-bit binary floating point numbers) and offers a powerful mechanism for defining new data types from scratch, from which all these familiar types and more can be derived.</p>
<p>To demonstrate how the definition mechanism works, let's start with a simple example.</p>
<!-- TODO Esse bloco de texto será relevante quando tivermos um sistema de pacotes apropriado -->
<!-- Naturally, the Idris distribution comes with extensive standard libraries providing
definitions of booleans, numbers, and many common data structures like lists and
hash tables (see the prelude and contrib packages), as well as the means to write
type-safe effectful code (see the effects package) and pruvlioj, a toolkit for proof
automation and program construction. But there is nothing magic or primitive
about these library definitions. To illustrate this, we will explicitly recapitulate
all the definitions we need in this course, rather than just getting them implicitly
from the library. -->
<div style="break-before: page; page-break-before: always;"></div><h3 id="days-of-the-week"><a class="header" href="#days-of-the-week">Days of the Week</a></h3>
<p>The following declaration tells Kind that we are declaring a new set of data - a Type.</p>
<pre><code class="language-rust ignore">type Day {  // Day is a Type
  monday    // Monday    is a Day
  tuesday   // Tuesday   is a Day
  wednesday // Wednesday is a Day
  thursday  // Thursday  is a Day
  friday    // Friday    is a Day
  saturday  // Saturday  is a Day
  sunday    // Sunday    is a Day
}</code></pre>
<p>The type is called <code>Day</code>, and its members are <code>Monday</code>, <code>Tuesday</code>, <code>Wednesday</code>, etc. The <code>&lt;name&gt; : &lt;type&gt;</code> definition can be read as &quot;name is a type&quot;.
Above, we have both an example of creating a new <code>Day : Type</code>, and declaring an element of an existing type <code>Wednesday : Day</code>.</p>
<p>Now that we have defined what a Day is, we can write functions that operate using this type. Type the following:</p>
<pre><code class="language-rust ignore">NextWeekday (d: Day) : Day</code></pre>
<p>This declares that we have a function called NextWeekday, which takes an argument called <code>d</code>, of type <code>Day</code>, and returns a <code>Day</code>. Continue defining the function as follows:</p>
<pre><code class="language-rust ignore">NextWeekday Day.monday  = ?
NextWeekday Day.tuesday    = ?
NextWeekday Day.wednesday  = ?
NextWeekday Day.thursday = ?
NextWeekday Day.friday   = ?
NextWeekday Day.saturday  = ?
NextWeekday Day.sunday  = ?</code></pre>
<p>Here, we are doing what we call <em>pattern matching</em>. We are declaring how the function should run for each possibility of the input <code>d</code>. It won't always be necessary to do this, as will be shown in examples later on.</p>
<p>Finally, complete the functions by writing what each one should return, and use spaces to style as you prefer:</p>
<pre><code class="language-rust ignore">NextWeekday Day.monday = Day.tuesday
NextWeekday Day.tuesday   = Day.quarta
NextWeekday Day.wednesday = Day.thursday
NextWeekday Day.thursday = Day.sexta
NextWeekday Day.friday  = Day.monday
NextWeekday Day.saturday = Day.monday
NextWeekday Day.sunday = Day.monday</code></pre>
<p>With the function finished, we can check its operation with some examples. The main way to do this in Kind is to create a <code>Main</code> function in your file and run it with the command <code>kind2 run &lt;file&gt;</code>.</p>
<p>For example, if you write the following <code>Main</code> and run the file:</p>
<pre><code class="language-rust ignore">Main {
  // Two workdays after Saturday
  NextWeekday (NextWeekday Day.saturday)
}</code></pre>
<p>You should get something like:</p>
<pre><code class="language-terminal">(Day.tuesday)
</code></pre>
<p>Another way to test your code is to say what we expect the code to return, through a proof:</p>
<pre><code class="language-rust ignore">// // The third workday after a Monday is a Thursday
TestNextWeekday : Equal Day (NextWeekday (NextWeekday (NextWeekday Day.monday))) Day.thursday
TestNextWeekday = Equal.refl</code></pre>
<p>The details of how proofs work will be explained later on. For now, what needs to be understood is:</p>
<ul>
<li>We have the realization that <code>(NextWeekday (NextWeekday (NextWeekday Day.monday)))</code> is equal to <code>Day.thursday</code></li>
<li>This realization was named <code>TestNextWeekday</code></li>
<li><code>TestNextWeekday = Equal.refl</code> says that the realization can be proven using only simplification on both sides.</li>
</ul>
<p>To test that this proof (and any other proof going forward) is correct, you need to check the file using the command <code>kind2 check &lt;file&gt;</code>, which should return something like:</p>
<pre><code class="language-terminal">All terms check.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="booleans"><a class="header" href="#booleans">Booleans</a></h3>
<p>Similarly, we can declare the <code>Bool</code> type for booleans:</p>
<pre><code class="language-rust ignore">type Bool {
 true
 false
}</code></pre>
<!-- TODO mudar isso aqui caso tenhamos um gerenciador de pacotes -->
<p>We are declaring our own booleans just to demonstrate how to do everything from scratch. Kind has its own default implementation of booleans in the standard package (<a href="Book/chapter_02/github.com/Kindelia/Wikind">Wikind</a>), along with many other structures and proofs.</p>
<p>In fact, at the time of writing, you need to be working within the Wikind folder to do proofs and the theorem resolution utilities are not built-in.</p>
<p>Functions that operate on booleans are defined in the same way as seen earlier:</p>
<pre><code class="language-rust ignore">// Negação lógica
Notb (b: Bool) : Bool
Notb Bool.true  = Bool.false
Notb Bool.false = Bool.true

// E lógico
Andb (b1: Bool) (b2: Bool) : Bool
Andb Bool.true  b2 = b2
Andb Bool.false b2 = Bool.false

// OU lógico
Orb (b1: Bool) (b2: Bool) : Bool
Orb Bool.true  b2 = Bool.true
Orb Bool.false b2 = b2</code></pre>
<p>The last two functions demonstrate the syntax of Kind for multi-argument functions, and also show that it is possible to <em>pattern match</em> only on some of the variables of the function, not necessarily all.</p>
<p>The cases of the last function can be exhaustively tested (all possibilities) as shown below, creating the truth table of the logical operation.</p>
<pre><code class="language-rust ignore">TestOrb1 : Equal Bool (Orb Bool.true Bool.false) Bool.true
TestOrb1 = Equal.refl

TestOrb2 : Equal Bool (Orb Bool.false Bool.false) Bool.false
TestOrb2 = Equal.refl

TestOrb3 : Equal Bool (Orb Bool.false Bool.true) Bool.true
TestOrb3 = Equal.refl

TestOrb4 : Equal Bool (Orb Bool.true Bool.true) Bool.true
TestOrb4 = Equal.refl</code></pre>
<h4 id="nandb"><a class="header" href="#nandb">Nandb</a></h4>
<p>Replace the hole &quot;?&quot;, completing the following function;</p>
<p>then check if it is correct using the following statements (Analogous to how it was done for the <code>Orb</code> function). The function returns <code>Bool.true</code> if any of its inputs is <code>Bool.false</code>.</p>
<pre><code class="language-rust ignore">Nandb (b1: Bool) (b2: Bool) : Bool
Nandb b1 b2 = ?

Test_nandb1 : Equal Bool (Nandb Bool.true Bool.false) Bool.true
Test_nandb1 = ?

Test_nandb2 : Equal Bool (Nandb Bool.false Bool.false) Bool.true
Test_nandb2 = ?

Test_nandb3 : Equal Bool (Nandb Bool.false Bool.true) Bool.true
Test_nandb3 = ?

Test_nandb4 : Equal Bool (Nandb Bool.true Bool.true) Bool.false
Test_nandb4 = ?</code></pre>
<h4 id="and3"><a class="header" href="#and3">And3</a></h4>
<p>Do the same for the <code>Andb3</code> function below. This function should return <code>Bool.true</code> if all inputs are <code>Bool.true</code>, and <code>Bool.false</code> otherwise.</p>
<pre><code class="language-rust ignore">Andb3 (b1: Bool) (b2: Bool) (b3: Bool) : Bool
Andb3 b1 b2 b3 = ?

Test_andb3_1 Equal Bool (Andb3 Bool.true Bool.true Bool.true) Bool.true
Test_andb3_1 = ?

Test_andb3_2 Equal Bool (Andb3 Bool.false Bool.true Bool.true) Bool.false
Test_andb3_2 = ?

Test_andb3_3 Equal Bool (Andb3 Bool.true Bool.false Bool.true) Bool.false
Test_andb3_3 = ?

Test_andb3_4 Equal Bool (Andb3 Bool.true Bool.true Bool.false) Bool.false
Test_andb3_4 = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="types-of-functions"><a class="header" href="#types-of-functions">Types of functions</a></h2>
<p>All expressions in Kind have a type, describing what type of thing it computes.
For example, <code>Bool.true</code> has type <code>Bool</code>, just like <code>Notb Bool.true</code> also has type <code>Bool</code>.</p>
<p>Functions like <code>Notb</code>, before they receive arguments, also have a type, just like <code>Bool.true</code> or <code>Bool.false</code>.
Their types are called Function Types, and are denoted with arrows.</p>
<p><code>Notb</code>, for example, would be denoted as <code>Bool -&gt; Bool</code>, which can be read as
&quot;a function that takes a <code>Bool</code> as input and returns a value of type <code>Bool</code>&quot;.
Similarly, the type of the <code>Andb</code> function is <code>Bool -&gt; Bool -&gt; Bool</code>, meaning
&quot;a function that takes two arguments of type <code>Bool</code> and returns a value of type <code>Bool</code>&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<!-- TODO fill in when we have a module system -->
<p>We don't have a module system yet :pensive:. To use functions from other files,
you need to create a file within the same directory (e.g., the root folder of <a href="Book/chapter_02/github.com/Kindelia/Wikind">Wikind</a>).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="numbers"><a class="header" href="#numbers">Numbers</a></h2>
<p>The types we have defined so far are examples of enumerated types: their definitions explicitly enumerate a finite set of elements. A more interesting way to define a type is to establish a collection of inductive rules describing its elements. For example, we can define natural numbers as follows:</p>
<pre><code class="language-rust ignore">type Nat {
  zero
  succ (pred: Nat)
}</code></pre>
<p>This definition can be read as:</p>
<ul>
<li><code>Nat.zero</code> is a natural number;</li>
<li><code>Nat.succ</code> is a constructor that takes a natural number, constructing another natural number;
<ul>
<li>That is, if <code>n</code> is a natural number, then <code>(Nat.succ n)</code> will also be.</li>
</ul>
</li>
</ul>
<p>Every type defined inductively (such as <code>Nat</code>, <code>Bool</code> ou <code>Dia</code>) is a set of expressions. The definition of <code>Nat</code> says how expressions of type <code>Nat</code> can be constructed:</p>
<ul>
<li>The expression <code>Nat.zero</code> belongs to the set of <code>Nat</code>;</li>
<li>If <code>n</code> is an expression in the set of <code>Nat</code>, then <code>(Nat.succ n)</code> is also an expression in the set of <code>Nat</code>;</li>
<li>Expressions formed in these two ways are the only ones that belong to <code>Nat</code>.</li>
</ul>
<p>The same rules apply to our definitions of <code>Dia</code> and <code>Bool</code>.
The annotations we used for them are analogous to the <code>Nat.zero</code> constructor, indicating that they do not receive any arguments.</p>
<p>These three conditions demonstrate the power of inductive declarations. They imply that the expression <code>Nat.zero</code>, the expression <code>(Nat.succ Nat.zero)</code>, the expression <code>(Nat.succ (Nat.succ Nat.zero))</code> and so on, are of the <code>Nat</code> set, while other expressions such as <code>Bool.true</code>, <code>(Andb Bool.true Bool.false)</code>, and <code>(Nat.succ (Nat.succ Bool.false))</code> are not.</p>
<p>We can write simple functions using <em>pattern matching</em> on natural numbers in the same way we did above - for example, the predecessor function:</p>
<pre><code class="language-rust ignore">Pred (n: Nat) : Nat
// Since natural numbers are strictly non-negative,
// we use as a convention that anything that would be
// less than 0 returns 0
Pred  Nat.zero    = Nat.zero
Pred (Nat.succ k) = k</code></pre>
<p>The second pattern can be read as: &quot;if <code>n</code> has the form <code>(Nat.succ k)</code> for some k, return k.&quot;</p>
<pre><code class="language-rust ignore">MinusTwo (n: Nat) : Nat
MinusTwo  Nat.zero               = Nat.zero
MinusTwo (Nat.succ  Nat.zero)    = Nat.zero
MinusTwo (Nat.succ (Nat.succ k)) = k</code></pre>
<!-- TODO atualizar isso aqui pro sugar de números naturais, se vier a existir -->
<p>To avoid having to write a sequence of <code>Nat.succ</code> every time you want a <code>Nat</code>, you can use the <code>n</code> suffix at the end of any number, for example o <code>5n</code>, which takes a number written in the primitive type <code>U60</code> plus the <code>n</code> suffix and returns the corresponding <code>Nat</code>.
{...}</p>
<!-- TODO -->
<pre><code class="language-rust ignore">Test : Equal Nat 6n (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))))
Test = Equal.refl</code></pre>
<!-- TODO conferir q eu não estou delirando nesse parágrafo -->
<p>The <code>Nat.succ</code> constructor has type <code>Nat -&gt; Nat</code>, as do the functions <code>MinusTwo</code> and <code>Pred</code>. They are all things that, when applied to a <code>Nat</code>, return a <code>Nat</code>. The essential difference between <code>Nat.succ</code> and the other two, however, is that functions come with reduction rules - for example, <code>Pred (Nat.succ Nat.zero)</code> is reducible to <code>Nat.zero</code> - while <code>Nat.succ</code> does not. Although it is a function applicable to an argument, it does not compute anything.</p>
<p>For most number function definitions, <em>pattern matching</em> alone is not enough: we will also need recursion. For example, to check whether a number <code>n</code> is even, we can recursively check whether <code>n-2</code> is even.</p>
<pre><code class="language-rust ignore">Evenb (n: Nat) : Bool
Evenb  Nat.zero               = Bool.true
Evenb (Nat.succ  Nat.zero)    = Bool.false
Evenb (Nat.succ (Nat.succ k)) = Evenb k</code></pre>
<p>We can define O<code>ddb</code> (a function to check if a number is odd) with a similar recursive declaration, but we also have a simpler and somewhat easier to work with definition:</p>
<pre><code class="language-rust ignore">Oddb (n: Nat) : Bool
Oddb n = Notb (Evenb n)</code></pre>
<pre><code class="language-rust ignore">TestOddb1 : Equal Bool (Oddb 1n) Bool.true
TestOddb1 = Equal.refl

TestOddb2 : Equal Bool (Oddb 4n) Bool.false
TestOddb2 = Equal.refl</code></pre>
<p>Naturally, we can also define functions with multiple arguments by recursion.</p>
<pre><code class="language-rust ignore">Plus (n: Nat) (m: Nat) : Nat
Plus  Nat.zero    m = m
Plus (Nat.succ k) m = Nat.succ (Plus k m)</code></pre>
<p>Adding <code>3n</code> and <code>2n</code> will return 5n as expected.
The simplification that Kind performs to arrive at this value can be visualized as follows:</p>
<pre><code class="language-terminal">Plus (Nat.succ (Nat.succ (Nat.succ Nat.zero))) (Nat.succ (Nat.succ Nat.zero))

&gt; Nat.succ (Plus (Nat.succ (Nat.succ Nat.zero)) (Nat.succ (Nat.succ Nat.zero)))
by the second rule of Plus

&gt; Nat.succ (Nat.succ (Plus (Nat.succ Nat.zero)) (Nat.succ (Nat.succ Nat.zero)))
by the second rule of Plus

&gt; Nat.succ (Nat.succ (Nat.succ (Plus Nat.zero (Nat.succ (Nat.succ Nat.zero)))))
by the second rule of Plus

&gt; Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))
by the first rule of Plus
</code></pre>
<p>Multiplication can be defined using the definition of Plus, as follows:</p>
<pre><code class="language-rust ignore">Mult (n: Nat) (m: Nat) : Nat
Mult  Nat.zero    m = Nat.zero
Mult (Nat.succ k) m = Plus m (Mult k m)</code></pre>
<pre><code class="language-rust ignore">TestMult1 : Equal Nat (Mult 3n 3n) 9n
TestMult1 = Equal.refl</code></pre>
<p>You can also use <em>pattern matching</em> on two expressions at the same time:</p>
<pre><code class="language-rust ignore">Minus (n: Nat) (m: Nat) : Nat
Minus  Nat.zero     m           = Nat.zero
Minus  n            Nat.zero    = n
Minus (Nat.succ k) (Nat.succ j) = Minus k j</code></pre>
<!-- TODO conferir se wildcard no lhs já está funcionando -->
<!-- The _ in the first line is a wildcard pattern. Writing _ in a
pattern is the same as writing some variable that doesn’t get used on the
right-hand side. This avoids the need to invent a bogus variable name. -->
<p>The <code>Exp</code> function can be defined using <code>Mult</code> (analogous to how <code>Mult</code> is defined using <code>Plus</code>):</p>
<pre><code class="language-rust ignore">Exp (base: Nat) (power: Nat) : Nat
Exp base  Nat.zero    = Nat.succ Nat.zero
Exp base (Nat.succ k) = Mult base (Exp base k)</code></pre>
<h4 id="factorial"><a class="header" href="#factorial">Factorial</a></h4>
<p>Recall the basic mathematical definition of factorial:</p>
<p>\[\mathrm
Factorial(n) = \begin{cases}
\text{if $n$} = 0\,&amp; 1 \<br />
\\ \text{else} &amp; n * Factorial(n-1)
\end{cases}
\]</p>
<p>\[
f(x)=\begin{cases}x&amp;(x = 1)\\x f(x-1)&amp;(x\gt 1)\end{cases} , x\in \Bbb{N}
\]</p>
<p>Translate the factorial function into Kind2:</p>
<pre><code class="language-rust ignore">Factorial (n: Nat) : Nat
Factorial n = ?</code></pre>
<pre><code class="language-rust ignore">TestFactorial1 : Equal Nat (Factorial 3n ) 6n
TestFactorial1 = ?

TestFactorial2 : Equal Nat (Factorial 5n) 120n
TestFactorial2 = ?</code></pre>
<p>The <code>Eql</code> function tests equality between Naturals, returning a boolean.</p>
<pre><code class="language-rust ignore">Eql (n: Nat) (m: Nat) : Bool
Eql  Nat.zero     Nat.zero    = Bool.true
Eql  Nat.zero    (Nat.succ j) = Bool.false
Eql (Nat.succ k)  Nat.zero    = Bool.false
Eql (Nat.succ k) (Nat.succ j) = Eql k j</code></pre>
<p>The<code>Lte</code> function tests if the first argument is less than or equal to the second, returning a boolean.</p>
<pre><code class="language-rust ignore">Lte (n: Nat) (m: Nat) : Bool
Lte  Nat.zero     m           = Bool.true
Lte (Nat.succ k)  Nat.zero    = Bool.false
Lte (Nat.succ k) (Nat.succ j) = Lte k j</code></pre>
<pre><code class="language-rust ignore">TestLte1 : Equal Bool (Lte 2n 2n) Bool.true
TestLte1 = Equal.refl

TestLte2 : Equal Bool (Lte 2n 4n) Bool.true
TestLte2 = Equal.refl

TestLte3 : Equal Bool (Lte 4n 2n) Bool.false
TestLte3 = Equal.refl</code></pre>
<h4 id="blt_nat"><a class="header" href="#blt_nat">Blt_nat</a></h4>
<p>The <code>Blt_nat</code>function tests the &quot;less than&quot; relationship in natural numbers.
Instead of creating a new recursive function, define it using previously defined functions.</p>
<pre><code class="language-rust ignore">Blt_nat (n: Nat) (m: Nat) : Bool
Blt_nat n m = ?</code></pre>
<pre><code class="language-rust ignore">Test_blt_nat_1 : Equal Bool (Blt_nat 2n 2n) Bool.false
Test_blt_nat_1 = ?

Test_blt_nat_2 : Equal Bool (Blt_nat 2n 4n) Bool.true
Test_blt_nat_2 = ?

Test_blt_nat_3 : Equal Bool (Blt_nat 4n 2n) Bool.false
Test_blt_nat_3 = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="proof-by-simplification"><a class="header" href="#proof-by-simplification">Proof by Simplification</a></h2>
<p>Now that we have defined some data types and functions, let's start proving properties of their behaviors. In fact, we have already been doing this: each function in the previous sections that starts with <code>Test</code> makes a precise assertion about the behavior of some function for specific inputs. The proofs of these assertions were always the same: use <code>Equal.refl</code> to check that both sides are indeed identical.</p>
<p>The same type of &quot;proof by simplification&quot; can be used to prove more interesting properties. For example, the fact that <code>Nat.zero</code> is a &quot;neutral element&quot; on the left-hand side of addition can be proven simply by observing that <code>Plus Nat.zero n</code> reduces to <code>n</code>, regardless of what <code>n</code> is, a fact that can be read directly from the definition of <code>Plus</code>.</p>
<pre><code class="language-rust ignore">Plus_Z_n (n: Nat) : Equal Nat (Plus Nat.zero n) n
Plus_Z_n n = Equal.refl</code></pre>
<p>Other similar theorems can be proven in a similar way.</p>
<pre><code class="language-rust ignore">Plus_1_l (n: Nat) : Equal Nat (Plus (Nat.succ Nat.zero) n) (Nat.succ n)
Plus_1_l n = Equal.refl

Mult_0_l (n: Nat) : Equal Nat (Mult Nat.zero n) Nat.zero
Mult_0_l n = Equal.refl </code></pre>
<p>The <code>_l</code> indicates that the proof involves the value on the left-hand side. For example: the proof of adding 1 on the left-hand side <code>(Plus_1_l)</code> or the proof of multiplying by zero on the left-hand side <code>(Mult_0_l)</code>.</p>
<p>Although simplification is powerful enough to prove some general facts, there are several statements that cannot be demonstrated with simplification alone. For example, we cannot use it to prove that <code>Nat.zero</code> is a neutral element for addition on the right-hand side.</p>
<pre><code class="language-rust ignore">Plus_n_Z (n: Nat) : Equal Nat n (Plus n Nat.zero)
Plus_n_Z n = Equal.refl</code></pre>
<pre><code class="language-diff">- ERROR Type mismatch  

   • Got      : Equal Nat n n
   • Expected : Equal Nat n (Plus n 0n)

   • Context: 
   •   n : Nat 

   Plus_n_Z n = Equal.refl
                ┬─────────
                └Here!
</code></pre>
<p>(Can you explain why this is?)</p>
<p>The next chapter will introduce the concept of induction, a powerful technique that can be used to demonstrate this theorem. For now, however, let's see some more simple types of proof.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="proof-by-application"><a class="header" href="#proof-by-application">Proof by Application</a></h2>
<p>Our first tool for proving non-trivial theorems will be applying functions to both sides of an equality. For this, we will use the function <code>Equal.apply</code>, which takes an equality (<code>Equal</code>) and a function, and applies this function to both sides of the equality, generating a new equality.</p>
<p>For example:</p>
<pre><code class="language-rust ignore">Example_apply (n: Nat) (m: Nat) (e: Equal Nat m n) : Equal Nat (Nat.succ m) (Nat.succ n)
Example_apply n m e = ?</code></pre>
<p>What do we have here? We have a proof that takes another proof/equality as argument. This means that we will carry out our proof assuming that the proof given as argument is also true. So, reading the statement of the proof, we have: &quot;Given two naturals, <code>m</code> and <code>n</code>, and a proof that they are equal, prove that <code>Nat.succ m</code> and <code>Nat.succ n</code> are also equal&quot;.</p>
<p>We learned in our math classes that applying a function to both sides of an equality preserves the equality (<code>x/2 = 3 -&gt; 2x/2 = 23</code>), and we can see that to prove what we want, we need to apply the function <code>Nat.succ</code> to both sides of <code>e</code>, using <code>Equal.apply</code>.</p>
<pre><code class="language-diff">+ INFO  Inspection.

  • Expected: (Equal Nat (Nat.succ m) (Nat.succ n)) 

  • Context: 
  •   n : Nat 
  •   m : Nat 
  •   e : (Equal Nat m n) 

  Example_apply n m e = ?
                        ┬
                        └Here!
</code></pre>
<p>How does <code>Equal.apply</code> work: It takes as first argument the function to be applied to both sides, and as second argument the equality to which to apply the function. If you didn't understand the passage of the argument function (<code>x =&gt; Nat.succ x</code>), it is what we call a lambda function, and is also known as an anonymous function. Lambda functions are identified by their arrow <code>=&gt;</code>, where on the left side of the arrow is the name of the function argument - use any name you want - and on the right side is the body of the function: what it returns. Our current lambda function is a function that takes any <code>x</code> and returns <code>Nat.succ x</code>.</p>
<p>We can see the result of this by <code>check</code> the file:</p>
<pre><code class="language-diff">+ INFO  Inspection.

  • Expected: (Equal Nat (Nat.succ m) (Nat.succ n)) 

  • Context: 
  •   n : Nat 
  •   m : Nat 
  •   e       : (Equal Nat m n) 
  •   e_apply : (Equal Nat (Nat.succ m) (Nat.succ n)) 
  •   e_apply = (Equal.apply Nat Nat m n (x =&gt; (Nat.succ x)) e) 

  let e_apply = Equal.apply (x =&gt; Nat.succ x) e
      ?
      ┬
      └Here!
</code></pre>
<p>As <code>e_apply</code> is an equality of type <code>Equal Nat (Nat.succ m) (Nat.succ n)</code>, the proof we are looking for is simply to return it, and we will have concluded our proof.</p>
<pre><code class="language-rust ignore">Example_apply (n: Nat) (m: Nat) (e: Equal Nat m n) : Equal Nat (Nat.succ m) (Nat.succ n)
Example_apply n m e =
  let e_apply = Equal.apply (x =&gt; Nat.succ x) e
  e_apply</code></pre>
<pre><code class="language-terminal">  All terms checked.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="proof-by-case-analysis"><a class="header" href="#proof-by-case-analysis">Proof by Case Analysis</a></h2>
<p>The next tool for formal proofs will be case analysis, which means using <em>pattern matching</em> in the proof. For example, let's prove that the logical AND of anything and False is always False:</p>
<pre><code class="language-rust ignore">Example_case_analysis (b: Bool) : Equal Bool (Andb b1 Bool.false) Bool.false
Example_case_analysis b = ?</code></pre>
<p>Although it may seem like a proof that could be solved simply with <code>Equal.refl</code>, it's not the case. This is because the <code>Andb</code> function pattern matches on the first argument, and we don't have its value in the proof, so it remains &quot;stuck&quot;.</p>
<p>To give a value to it and show that the proof is correct for both <code>Bool</code> values, we <em>pattern match</em> in the proof, creating two different proofs: one for when <code>b</code> is <code>Bool.true</code> and one for when it's <code>Bool.false</code>.</p>
<pre><code class="language-rust ignore">Example_case_analysis (b: Bool) : Equal Bool (Andb b Bool.false) Bool.false
Example_case_analysis Bool.true  = ?
Example_case_analysis Bool.false = ?</code></pre>
<p>And both of these proofs are directly solvable with <code>Equal.refl</code>, since the <em>type checker</em> can reduce both of them to <code>Equal Bool.false Bool.false</code> directly.</p>
<pre><code class="language-rust ignore">Example_case_analysis (b: Bool) : Equal Bool (Andb b Bool.false) Bool.false
Example_case_analysis Bool.true  = Equal.refl
Example_case_analysis Bool.false = Equal.refl</code></pre>
<!-- TODO Reescrita no Kind2 é uma caixa de minhocas por si só,
talvez colocar mais pro final do capítulo,
ao talvez até colocar depois desse capítulo -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="proof-by-rewriting"><a class="header" href="#proof-by-rewriting">Proof by Rewriting</a></h2>
<p>This theorem is a bit more interesting than the previous ones:</p>
<pre><code class="language-rust ignore">Plus_id_example (n: Nat) (m: Nat) (e: Equal Nat n m) : Equal Nat (Plus n n) (Plus m m)</code></pre>
<p>As shown before, this is a proof that has another proof or hypothesis within its arguments: in this case, we have <code>Equal n m</code> - meaning, <code>n</code> and <code>m</code> are equal.</p>
<p>Since n and m are arbitrary numbers, we can't just use simplification to prove the theorem. Instead, we observe that, since we assume <code>Equal n m</code>, we could substitute <code>n</code> for <code>m</code> in the goal and both sides will be equal. The function we use to perform this substitution is <code>Equal.rewrite</code>.</p>
<!-- TODO revisar esse parágrafo -->
<p>Since we can't rewrite directly in the goal, we use another equality and make it equal to the goal. In our case, we will use an <code>Equal.apply</code> on <code>e</code> to obtain this equality.</p>
<pre><code class="language-rust ignore">Plus_id_example (n: Nat) (m: Nat) (e: Equal Nat n m) : Equal Nat (Plus n n) (Plus m m)

Plus_id_example n m e =
  let app = Equal.apply (k =&gt; Plus k n) e
  ? </code></pre>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: Equal Nat (Plus n n) (Plus m m) 

   • Context: 
   •   n   : Nat 
   •   m   : Nat 
   •   e   : Equal Nat n m 
   •   app : Equal Nat (Plus n n) (Plus m n) 
   •   app = Equal.apply Nat Nat n m (k =&gt; (Plus k n)) e
    
   let app = Equal.apply (k =&gt; Plus k n) e
      ?
      ┬
      └Here!
</code></pre>
<p>This <code>app</code> will be of type <code>Equal (Plus n n) (Plus m n)</code>, as shown in the comment. With this done, we need to replace <code>n</code> with <code>m</code> on the right-hand side of the equality, and for that we use rewrite:</p>
<pre><code class="language-rust ignore">Plus_id_example (n: Nat) (m: Nat) (e: Equal Nat n m) : Equal Nat (Plus n n) (Plus m m)
Plus_id_example n m e =
  let app = Equal.apply (k =&gt; Plus k n) e
  let rrt = Equal.rewrite e (x =&gt; Equal (Plus n n) (Plus m x)) app
  rrt</code></pre>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: Equal Nat (Plus n n) (Plus m m) 

   • Context: 
   •   n   : Nat 
   •   m   : Nat 
   •   e   : Equal Nat n m 
   •   app : Equal Nat (Plus n n) (Plus m n) 
   •   app = Equal.apply Nat Nat n m (k =&gt; (Plus k n)) e 
   •   rrt : Equal Nat (Plus n n) (Plus m m) 
   •   rrt = Equal.rewrite Nat n m e (x =&gt; Equal Nat (Plus n n) (Plus m x)) app
</code></pre>
<p>The return value of the <code>Equal.rewrite</code> operation will be the proof we need, so we just return the result directly from the function.</p>
<h4 id="plus_id_exercise"><a class="header" href="#plus_id_exercise">Plus_id_exercise</a></h4>
<p>Prove that:</p>
<pre><code class="language-rust ignore">Plus_id_exercise (n: Nat) (m: Nat) (o: Nat) (e1: Equal Nat n m) (e2: Equal Nat m o) : Equal Nat (Plus n m) (Plus m o)
Plus_id_exercise n m o e1 e2 = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="equalchain-and-equalmirror"><a class="header" href="#equalchain-and-equalmirror">Equal.chain and Equal.mirror</a></h2>
<p>In this section we will not discuss any inherently new tool, but rather some proof utilities to make use of the previous tools easier.</p>
<p>Consider the example:</p>
<pre><code class="language-rust ignore">Example_mirror (a: Nat) (b: Nat) (e: Equal Nat a b) : Equal Nat b a</code></pre>
<p>It seems like a trivial example. If <code>a</code> is equal to <code>b</code>, then <code>b</code> is equal to <code>a</code>, right? Although correct, the type checker of Kind does not recognize this equality, because for it, the order is important. For such situations, we have the function <code>Equal.mirror</code>, which simply swaps the sides of an equality.</p>
<pre><code class="language-rust ignore">Example_mirror (a: Nat) (b: Nat) (e: Equal Nat a b) : Equal Nat b a
Example_mirror a b e = 
   let mir = Equal.mirror e
   mir</code></pre>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: Equal Nat b a 

   • Context: 
   •   a   : Nat 
   •   b   : Nat 
   •   e   : Equal Nat a b
   •   mir : Equal Nat b a 
   •   mir = Equal.mirror Nat a b e
</code></pre>
<p>Although it may not seem very useful at the moment, this operation is very useful for our second utility: <code>Equal.chain</code>. <code>Equal.chain</code> is a specific case of <code>Equal.rewrite</code>, in which you rewrite an entire side of an equality using another.</p>
<pre><code class="language-rust ignore">Example_chain (a: Nat) (b: Nat) (c: Nat) (e1: Equal Nat b (Plus a a)) (e2 : Equal Nat c (Plus a a)) : Equal Nat b c</code></pre>
<p>Since we already know <code>Equal.rewrite</code>, we could use it to solve this theorem, but instead we will use <code>Equal.chain</code>.<code>Equal.chain</code> works by &quot;chaining&quot; two equalities that have the same expression on the right side of the first equality and on the left side of the second, &quot;gluing&quot; these equalities together by the common expression, generating a new equality with the other two expressions (<code>Equal.chain (a = b) (b = c) = (a = c)</code>). For example, in our example, the right side of the two equalities is equal. If we use <code>Equal.mirror</code> on one of them, we can then use <code>Equal.chain</code> on them:</p>
<pre><code class="language-rust ignore">Example_chain (a: Nat) (b: Nat) (c: Nat) (e1: Equal Nat b (Plus a a)) (e2 : Equal Nat c (Plus a a)) : Equal Nat b c
Example_chain a b c e1 e2 =
  let e3 = Equal.mirror e2
  let chn = Equal.chain e1 e3
</code></pre>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: Equal Nat b c

   • Context: 
   •   a   : Nat 
   •   b   : Nat 
   •   c   : Nat 
   •   e1  : Equal Nat b (Plus a a) 
   •   e2  : Equal Nat c (Plus a a) 
   •   e3  : Equal Nat (Plus a a) c
   •   e3  = Equal.mirror Nat c (Plus a a) e2
   •   chn : Equal Nat b c
   •   chn = Equal.chain Nat b (Plus a a) c e1 e3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="more-exercises"><a class="header" href="#more-exercises">More Exercises</a></h2>
<h4 id="boolean_functions"><a class="header" href="#boolean_functions">Boolean_functions</a></h4>
<p>Use the knowledge taught so far to solve the theorem:</p>
<pre><code class="language-rust ignore">Identity_fn_applied_twice (f: Bool -&gt; Bool) (e: (x: Bool) -&gt; Equal Bool (f x) x) (b : Bool) : Equal Bool (f (f b)) b
Identity_fn_applied_twice f e b = ?</code></pre>
<p>Then, solve the <code>negation_fn_applied_twice</code> theorem, which is the same as the previous one, but changing the hypothesis to <code>Equal (f x) (Not x)</code></p>
<h4 id="andb_eq_orb"><a class="header" href="#andb_eq_orb">Andb_eq_orb</a></h4>
<p>Prove the following theorem (Remember that you can prove intermediate theorems separately):</p>
<pre><code class="language-rust ignore">Andb_eq_orb (b: Bool) (c: Bool) (e: Equal Bool (Andb b c) (Orb b c)) : Equal Bool b c
Andb_eq_orb b c prf = ?</code></pre>
<h4 id="binary"><a class="header" href="#binary">Binary</a></h4>
<p>Consider a different representation of natural numbers using a binary system instead of unary. That is, instead of having only zero or one successor of a number, we can have:</p>
<ul>
<li>zero;</li>
<li>twice a number;</li>
<li>twice a number plus 1.</li>
</ul>
<ol>
<li>First, write an inductive definition of this type, calling it <code>Bin</code>. (Remember that, in essence, the definition of <code>Nat</code> as <code>zero</code> or <code>succ n</code> has no intrinsic meaning. It only says that an element of <code>Nat</code> can be a <code>zero</code> or a s<code>ucc n</code> if <code>n</code> is also <code>Nat</code>. The interpretation of this as a system of values 0, 1, 2, etc., comes from how we work with this type <code>Nat</code>. Your definition of <code>Bin</code> ideally will be as simple as well. It will be the functions you make on <code>Bin</code> that will give mathematical sense to it).</li>
<li>Then write an <code>Incr</code> function to increment a <code>Bin</code>, and a <code>Bin_to_nat</code> function to convert from <code>Bin</code> to <code>Nat</code>.</li>
<li>Write five proofs that test your increment and conversion functions. Note that incrementing a binary and then converting it should result in the same result as converting it first and then incrementing the <code>Nat</code>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="induction-proof-by-induction"><a class="header" href="#induction-proof-by-induction">Induction: Proof by Induction</a></h1>
<h2 id="induction"><a class="header" href="#induction">Induction</a></h2>
<p>In this chapter, we will learn about proof by induction. Before we move on to induction itself, we can analyze simple cases where the reflection of the case already proves the theorem.</p>
<pre><code class="language-rust ignore">Problems.t0 (n: Nat) : Equal Nat (Plus Nat.zero n) n</code></pre>
<p>When checking the theorem statement, we receive the following response:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: (Equal Nat n n) 

   • Context: 
   •   n : Nat 

    Problems.t0 n = ?
                    ┬
                    └Here!
</code></pre>
<p>In <em>Problems.t0</em>, Kind automatically reduces the sum of <code>0 + n</code> to <em>n</em>, and we need to prove the equality between <em>n</em> and <em>n</em>. In this case, we simply write <code>Equal.refl</code> and we get the confirmation response:</p>
<pre><code class="language-terminal">All terms check.

</code></pre>
<pre><code class="language-rust ignore">Problems.t1 (n: Nat) : Equal Nat (Plus n Nat.zero) n</code></pre>
<p>After solving the first problem, the next one is very similar, it is the sum of <code>n + 0 = n</code> and this similarity may lead us to believe that invoking the reflection is enough. However, in the first case, Kind automatically reduces and in this one, we get the following response:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: (Equal Nat (Plus n 0n) n) 

   • Context: 
   •   n   : Nat 

   Problems.t1 n = ?
                   ┬
                   └Here!
</code></pre>
<p>In the first case, Kind reduces because <code>zero</code> is on the right side and the <code>Type Checker</code> automatically reduces the sum between <code>0</code> and <code>n</code> to <code>n</code>. However, when the first <em>input</em> is a variable, Kind needs to check for each case and as it is a natural number, there are infinitely many cases to be tested, that is, from zero to infinity.</p>
<p>At first, we may think that there are so many cases and it is impossible to analyze all of them, as there are infinitely many, but soon we realize that it is possible to reduce them to two, one is the number <code>zero</code> and the other is a number that <code>succeeds</code> <code>zero n</code> times after.</p>
<p>Analyzing the case of zero, our goal is to prove that <code>zero</code> is equal to <code>zero</code>:</p>
<pre><code class="language-rust ignore">• Expected: Equal Nat Nat.zero Nat.zero</code></pre>
<p>Now, we just need to give the <code>Equal.refl</code> and the zero case has been proven, we just need to respond to the <code>successor</code> of <code>zero</code>.</p>
<p>Our goal is to prove that for every number <code>n</code>, adding <code>0</code> will result in <code>n</code>, but we already have a new tool that helps us in this proof and it is the proof for the <code>zero</code> case, we just need to reduce <code>n</code> until the only thing needed is reflection, and we can do this by recursion and to do that we define the new <code>n</code> as its predecessor. In Kind, we can simply do this by defining the current <code>n</code> as the successor of the next n and recursively calling the function for <code>n</code>. This is done as follows:</p>
<pre><code class="language-rust ignore">Problems.t1 (Nat.succ n)   = ?</code></pre>
<p>and our new goal is to prove that the successor of the sum between <code>n</code> and <code>0</code> is equal to the successor of <code>n</code>.</p>
<pre><code class="language-rust ignore">- Expected: Equal Nat (Nat.succ (Plus n Nat.zero)) (Nat.succ n)</code></pre>
<p>To work with induction in this recursion, we must define a variable for the original case of <code>n</code>.</p>
<pre><code class="language-rust ignore">Problems.t1 (n: Nat)       : Equal (Plus n Nat.zero) n
Problems.t1 Nat.zero       = Equal.refl
Problems.t1 (Nat.succ n)   =
    let ind = Problems.t1 n
    ?</code></pre>
<p>When we give the <code>Type Check</code>, we get the following response:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: (Equal Nat (Nat.succ (Plus n 0n)) (Nat.succ n)) 

   • Context: 
   •   n   : Nat 
   •   ind : (Equal Nat (Plus n 0n) n) 
   •   ind = (Problems.t1 n) 

   let ind = Problems.t1 n
     ?
     ┬
     └Here!
</code></pre>
<p>When analyzing our goal and induction, we realize that the only difference between the goal and our variable <code>ind</code> is the <code>Nat.succ</code>. Therefore, we just need to increment the <code>ind</code> variable with <code>Nat.succ</code>. To do this, we create a new variable and use a <code>lambda</code> function:</p>
<pre><code class="language-rust ignore">let app = Equal.apply (x =&gt; (Nat.succ x)) ind</code></pre>
<p>In the above case, we call the <code>Equal.apply</code> function to apply our <code>lambda</code> function to <code>ind</code>. The <code>x =&gt; (Nat.succ x)</code> function serves to add <code>Nat.succ</code> to every element received in the variable. Since our <code>ind</code> variable is a function that takes another variable <code>n</code>, our <code>lambda</code> function increments <code>n</code> with <code>Nat.succ</code>, which returns exactly our goal:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: (Equal Nat (Nat.succ (Plus n 0n)) (Nat.succ n)) 

   • Context: 
   •   n   : Nat 
   •   ind : (Equal Nat (Plus n 0n) n) 
   •   ind = (Problems.t1 n) 
   •   app : (Equal Nat (Nat.succ (Plus n 0n)) (Nat.succ n)) 
   •   app = (Equal.apply Nat Nat (Plus n 0n) n (x =&gt; (Nat.succ x)) ind)  

   let app = Equal.apply (x =&gt; (Nat.succ x)) ind
      ?
      ┬
      └Here!
</code></pre>
<p>We can see that the <code>app</code> is exactly the same as the <code>Expected</code>, which is our goal, and we just need to return it, the app, for the <code>Type Check</code> to validate our proof:</p>
<pre><code class="language-terminal">All terms check.

</code></pre>
<p>There are cases where induction is even simpler - all we need to do is understand what is happening. Let's say we want to prove that a number <code>n</code> minus itself is always equal to <code>zero</code>, regardless of what that number is. How would we do it?
First, we check the case where n is <code>zero</code>, and it is a true equality - <code>zero</code> minus <code>zero</code> is equal to <code>zero</code>. Then, we induct the case to the case of <code>zero</code>, which we know is true. Seems complicated? It's not - it's ridiculously simple. Let's see how it looks in <code>Kind</code>:</p>
<pre><code class="language-rs ignore">Minus_diag (n: Nat)     : Equal Nat (Minus  n n) Nat.zero
Minus_diag Nat.zero     = Equal.refl
Minus_diag (Nat.succ n) = Minus_diag n
</code></pre>
<p>Notice, this is a simple induction - we say the proof holds for the number and its predecessor, and through recursion, for all predecessors up to <code>zero</code>, which we verified to be true.
In other words, we prove, in just three lines, that a natural number minus itself will always result in <code>zero</code>, regardless of what that number is.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<p>Prove the following using induction. You may need previously proven results.</p>
<pre><code class="language-rust ignore">Mult_0_r (n: Nat) : Equal Nat (Mult n Nat.zero) Nat.zero
Mult_0_r n = ?

Plus_n_sm (n: Nat) (m: Nat) : Equal Nat (Nat.succ (Plus n m)) (Plus n (Nat.succ m))
Plus_n_sm n m = ?

Plus_comm (n: Nat) (m: Nat) : Equal Nat (Plus n m) (Plus m n)
Plus_comm n m = ?

Add_0_r (n: Nat) : Equal Nat (Plus n Nat.zero) n
Add_0_r n = ?

Plus_assoc (n: Nat) (m: Nat) (p: Nat) : Equal Nat (Plus n (Plus m p)) (Plus (Plus n m) p)
Plus_assoc n m p = ?</code></pre>
<p>Consider the following function that doubles its input.</p>
<pre><code class="language-rust ignore">Double (n: Nat)     : Nat
Double Nat.zero     = Nat.zero
Double (Nat.succ n) = Nat.succ (Nat.succ (Double n))</code></pre>
<p>Use induction to prove the following theorems about <code>Double</code>:</p>
<pre><code class="language-rust ignore">Double_plus (n: Nat) : Equal Nat (Double n) (Plus n n)
Double_plus n = ?</code></pre>
<p>Some theorems require analyzing the best way to prove them, for example, to prove that a number is even, we could prove it for its successor, but that would require us to prove it for the successor of the successor, making the proof of <code>Evenb</code> more difficult by induction. So it's important to realize when it is necessary and when it is not.</p>
<pre><code class="language-rust ignore">Evenb_s (n: Nat) : Equal Bool (Evenb (Nat.succ n)) (Notb  (Evenb n))
Evenb_s n = ?</code></pre>
<h2 id="another-case"><a class="header" href="#another-case">Another case</a></h2>
<p>Let's verify if the equality <code>n +(m + 1) = 1 + (n + m)</code> is true.</p>
<p>First, our problem:</p>
<pre><code class="language-rust ignore">Problems.t2 (n: Nat) (m: Nat) : Equal Nat (Plus n (Nat.succ m)) (Nat.succ(Plus n m))</code></pre>
<p>We verify the base case, when <code>n</code> is zero:</p>
<pre><code class="language-rust ignore">Problems.t2 Nat.zero m = Equal.refl</code></pre>
<p>and move on to the next case</p>
<pre><code class="language-rust ignore">Problems.t2 (Nat.succ n) m = ?</code></pre>
<p>and our current goal becomes:</p>
<pre><code class="language-rust ignore">• Expected: Equal Nat (Nat.succ (Plus n (Nat.succ m))) (Nat.succ (Nat.succ (Plus n m)))</code></pre>
<p>Translating, the successor of the addition of <code>n</code> and the successor of <code>m</code> is equal to the successor of the successor of the addition of <code>n</code> and <code>m</code>. To solve this problem, we will invoke induction:</p>
<pre><code class="language-rust ignore">let ind = Problems.t2 n m</code></pre>
<p>and our current goal is to prove that:</p>
<pre><code class="language-rust ignore">• Expected: Equal Nat (Nat.succ (Plus n (Nat.succ m))) (Nat.succ (Nat.succ (Plus n m)))</code></pre>
<p>Again, translating, that the <code>successor</code> of the addition of <code>n</code> and the <code>successor</code> of <code>m</code> is equal to the <code>successor</code> of the <code>successor</code> of the addition of <code>n</code> and <code>m</code>.</p>
<p>But now we have a very useful tool, our variable ind which is:</p>
<pre><code class="language-rust ignore">Equal Nat (Plus n (Nat.succ m)) (Nat.succ (Plus n m))</code></pre>
<p>Now, analyzing our goal and our variable ind, we can see that it is enough to add <code>Nat.succ</code> to both sides of the induction, and it will be exactly the same as our goal. To do this, we will use a <code>lambda</code> function:</p>
<pre><code class="language-rust ignore">let app = Equal.apply (x =&gt; (Nat.succ x)) ind</code></pre>
<p>And our variable <code>app</code> will return our goal:</p>
<pre><code class="language-rust ignore">Equal Nat (Nat.succ (Plus n (Nat.succ m))) (Nat.succ (Nat.succ (Plus n m)))</code></pre>
<p>Just return app and Kind will give us the coveted <code>All terms check</code>.</p>
<h1 id="using-other-theorems"><a class="header" href="#using-other-theorems">Using other theorems</a></h1>
<p>In Kind, as in informal mathematics, large proofs are often divided into a sequence of theorems, with later proofs referring to earlier theorems. But sometimes a proof will require some varied fact that is too trivial and of too little general interest to give it its own higher-level name. In these cases, it is convenient to be able to simply state and prove the necessary &quot;sub-theorem&quot; exactly at the point where it is used.</p>
<p>Let's analyze the following addition commutation theorem:</p>
<pre><code class="language-rust ignore">Problems.t3 (n: Nat) (m: Nat) : Equal Nat (Plus n  m) (Plus m n)</code></pre>
<p>In the first case, for <code>n</code> and <code>m</code> equal to zero we have a reflection:</p>
<pre><code class="language-rust ignore">Problems.t3 Nat.zero Nat.zero = Equal.refl</code></pre>
<p>So we move on to the next case:</p>
<pre><code class="language-rust ignore">Problems.t3 (Nat.succ n) m = ?</code></pre>
<p>And here it seems that we have a new problem:</p>
<pre><code class="language-rust ignore">Expected: Equal Nat (Nat.succ (Plus n m)) (Plus m (Nat.succ n))
</code></pre>
<p>Analyzing the problem, we realize that there is a theorem already proven within it, that the <code>successor</code> of the addition of two numbers is equal to the addition of one number with its <code>successor</code>, so we can use that to our advantage.</p>
<p>We will start by applying a <code>Nat.succ</code> to our original problem:</p>
<pre><code class="language-rust ignore">let ind_a = Equal.apply (x =&gt; (Nat.succ x)) (Problems.t3 n m )</code></pre>
<p>Then we invoke our already solved problem, <code>Problems.t2</code>:</p>
<pre><code class="language-rust ignore">let ind_b = Problems.t2 m n</code></pre>
<p>When we give the <code>Type Check</code>, the terminal returns:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: (Equal Nat (Nat.succ (Plus n m)) (Plus m (Nat.succ n))) 

   • Context: 
   •   n     : Nat 
   •   m     : Nat 
   •   ind_a : (Equal Nat (Nat.succ (Plus n m)) (Nat.succ (Plus m n))) 
   •   ind_a = (Equal.apply Nat Nat (Plus n m) (Plus m n) (x =&gt; (Nat.succ x)) (Problems.t3 n m)) 
   •   ind_b : (Equal Nat (Plus m (Nat.succ n)) (Nat.succ (Plus m n))) 
   •   ind_b = (Problems.t2 m n) 
 
   let ind_b = Problems.t2 m n
     ?
     ┬
     └Here!
</code></pre>
<p>Now we can see that the first part of <code>ind_a</code> is the inverse of the first part of our goal and the first part of <code>ind_b</code> is equal to the second part of the goal, we just need to organize and join the necessary parts. To do this, we will use <code>Equal.mirror</code> and <code>Equal.chain</code>.</p>
<pre><code class="language-rust ignore">let ind_c = Equal.chain ind_b Equal.mirror ind_a</code></pre>
<p>And <code>ind_c</code> returns a value similar to the desired one:</p>
<pre><code class="language-rust ignore">• Expected: Equal Nat (Nat.succ (Plus n m)) (Plus m (Nat.succ n))
•   ind_c : Equal Nat (Plus m (Nat.succ n)) (Nat.succ (Plus n m))</code></pre>
<p>We can see that one is the other mirrored, to make them equal, we will use <code>Equal.mirror</code> again:</p>
<pre><code class="language-rust ignore">let app = Equal.mirror ind_c</code></pre>
<p>When we call <code>app</code>, the <code>Type Check</code> returns the message <code>All terms checked</code> and thus we prove, through induction and using another proof, the commutation of addition, that the sum of <code>n</code> and <code>m</code> is equal to the sum of <code>m</code> and <code>n</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="more-exercises-1"><a class="header" href="#more-exercises-1">More exercises</a></h2>
<p>You can use <code>rewrite</code> or <code>chain</code> in this proof, choose whichever you find easiest.</p>
<pre><code class="language-rust ignore">Plus_swap (n: Nat) (m: Nat) (p: Nat) : Equal Nat (Plus n (Plus m p)) (Plus m (Plus n p))
Plus_swap n m p = ?</code></pre>
<p>Now prove the commutativity of multiplication. (You will probably need to define and prove a separate auxiliary theorem to be used in the proof of this. You may find <code>Plus_swap</code> useful.)</p>
<pre><code class="language-rust ignore">Mult_comm (n: Nat) (m: Nat) : Equal Nat (Mult n m) (Mult m n)
Mult_comm n m = ?</code></pre>
<p>Take a piece of paper. For each of the following theorems, first think whether (a) it can be proven using just simplification and rewriting, (b) also requires case analysis (destruction), or (c) also requires induction. Write down your prediction.</p>
<p>Then, fill in the proof. (There is no need to submit your piece of paper; this is just to encourage you to reflect before hacking!)</p>
<pre><code class="language-rust ignore">Lte_refl (n: Nat) : Equal Bool Bool.true (Lte n n)
Lte_refl n = ?

Zero_nbeq_s (n: Nat) : Equal Bool (Eql (Nat.zero) (Nat.succ n)) Bool.false
Zero_nbeq_s n = ?

And_false_r (b: Bool) : Equal Bool (Andb b Bool.false) Bool.false
And_false b = ?

S_nbeq_0 (n: Nat) : Equal Bool (Eql (Nat.succ n) Nat.zero) Bool.false

Mult_1_l (n: Nat) : Equal Nat (Mult (Nat.succ Nat.zero) n) n
Mult_1_l n = ?

All3_spec (b: Bool) (c: Bool) : Equal Bool (Orb (Orb (Andb b c) (Notb  b)) (Notb  c)) Bool.true
All3_spec b c = ?

Mult_plus_distr_r (n: Nat) (m: Nat) (p: Nat) : Equal Nat (Mult (Plus n m) p) (Plus (Mult n p) (Mult m p))
Mult_plus_distr_r n m p = ?

Mult_assoc (n: Nat) (m: Nat) (p: Nat) : Equal Nat (Mult (Mult m p)) (Mult (Mult n m) p)
Mult_assoc n m p = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h1>
<h2 id="lists--working-with-structured-data"><a class="header" href="#lists--working-with-structured-data">Lists : Working with Structured Data</a></h2>
<p>From now on, we will see structured data, especially lists and pairs, which can contain elements of various types. In the type definition, we will already show them with <code>polymorphic</code> types, but don't worry, we will talk about it in the next chapter. For now, let's just ignore the type and follow the explanation. It will make more sense as we progress in our study.</p>
<h3 id="data-structures-1"><a class="header" href="#data-structures-1">Data Structures</a></h3>
<p>In an inductive type definition, each constructor can receive any number of arguments -- none like <code>Bool</code>, <code>Empty</code>, or one like <code>Nat</code> -- and we have the <code>Pair</code> that receives two arguments (which can even be other two pairs) and returns a type:</p>
<pre><code class="language-rust ignore">record Pair (a) (b) </code></pre>
<p>The two received arguments are transformed into the first component, <code>fst</code>, and the second, <code>snd</code>.</p>
<pre><code class="language-rust ignore">record Pair (a) (b) {
  fst : a
  snd : b
} </code></pre>
<p>The way to construct a pair of <code>Nat</code> is as follows:</p>
<pre><code class="language-rust ignore">Pair.new Nat Nat a b  : (Pair a b)</code></pre>
<p>Here are two simple functions to extract the first and second components of a pair. The definitions also illustrate how to pattern match on two constructor arguments.</p>
<pre><code class="language-rust ignore">Fst (pair: Pair Nat Nat) : Nat
Fst (Pair.new Nat Nat fst snd) = fst</code></pre>
<pre><code class="language-bash">Example 1: (Fst Nat (List Nat) (Pair 2n [1n,2n,3n])) -&gt;  2n
</code></pre>
<pre><code class="language-rust ignore">Snd (pair: Pair Nat Nat) : Nat
Snd (Pair.new Nat Nat fst snd) = snd</code></pre>
<pre><code class="language-bash">Example 2: (Snd Nat (List Nat) (Pair 2n [1n,2n,3n])) -&gt; [1n,2n,3n]
</code></pre>
<h4 id="some-proofs"><a class="header" href="#some-proofs">Some proofs</a></h4>
<p>Let's try to prove some simple facts about pairs. If we declare things in a particular (and slightly peculiar) way, we can complete proofs with just reflexivity:</p>
<pre><code class="language-rust ignore">Surjective_pairing (p: Pair Nat Nat) : Equal (Pair Nat Nat) p (Pair.new (Fst p) (Snd p))
Surjective_pairing (Pair.new Nat Nat fst snd) = Equal.refl</code></pre>
<p>But <code>Equal.refl</code> is not enough if the statement is:</p>
<pre><code class="language-rust ignore">Surjective_pairing (Pair.new Nat Nat fst snd) = Equal.refl</code></pre>
<p>Since Kind expects</p>
<pre><code class="language-rust ignore">Equal (Pair Nat Nat) p (Pair.new (Fst p) (Snd p))</code></pre>
<p>And received</p>
<pre><code class="language-rust ignore">Equal p p</code></pre>
<p>We must &quot;expose&quot; the internal structure of the <code>pair</code> so that the <code>Type Checker</code> can verify whether <code>p</code> is really equal to <code>Pair.new (Fst p) (Snd p)</code>.</p>
<h4 id="snd_fst_is_swap"><a class="header" href="#snd_fst_is_swap">Snd_fst_is_swap</a></h4>
<pre><code class="language-rust ignore">Snd_fst_is_swap (p: Pair Nat Nat ) : Equal (Pair Nat Nat) (Pair.swap Nat Nat (Pair.swap Nat Nat p) p)
Snd_fst_is_swap (Pair.new Nat Nat fst snd) = ? </code></pre>
<h4 id="fst_swap_is_snd"><a class="header" href="#fst_swap_is_snd">Fst_swap_is_snd</a></h4>
<pre><code class="language-rust ignore">Fst_swap_is_inverse (p: Pair Nat Nat) (a: Nat) (b: Nat) : Equal (Pair Nat Nat) (Pair.swap Nat Nat (Pair.new a b) (Pair.new b a))
Fst_swap_is_inverse p a b = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="number-lists"><a class="header" href="#number-lists">Number Lists</a></h2>
<p>Generalizing the definition of pairs, we can describe the type of number lists as follows: &quot;A list is either the empty list or a set of one element and another list&quot;, this type is not composed of a <code>head</code> and a <code>tail</code>.</p>
<pre><code class="language-rust ignore">type List (t) {
  nil
  cons (head: t) (tail: List t)
}</code></pre>
<p>As we are dealing with only one type, it is interesting to rewrite the list type for a defined one, the chosen one was <code>Nat</code>:</p>
<pre><code class="language-rust ignore">type NatList {
  nil
  cons (head: Nat) (tail: NatList)
}</code></pre>
<p>or</p>
<pre><code class="language-rust ignore">type NatList {
   List Nat
}</code></pre>
<p>We can see that in both notations, there is a <code>head</code> and a <code>tail</code>, with the
<code>head</code> receiving an element of type <code>Nat</code> and the <code>tail</code> receiving a list of type <code>Nat</code>.</p>
<p>For example, a list of three natural numbers 1n, 2n, and 3n would be written as follows:</p>
<p><code>[1n, 2n, 3n]</code></p>
<p>However, the Kind reads it differently:</p>
<p><code>[1n, [2n, 3n]]</code></p>
<p>where <code>1n</code> is the head and <code>[2n, 3n]</code> is the tail. Likewise, looking at a
list of 4 elements <code>[1n, 2n, 3n, 4n]</code>, we now see it as follows:</p>
<p><code>[1n, [2n, [3n, 4n]]]</code></p>
<p>The list has the <code>head</code> <code>1n</code> and the <code>tail</code> <code>[2n, [3n, 4n]]</code>, which, in turn, has the
<code>head</code> <code>2n</code> and the <code>tail</code> <code>[3n, 4n]</code> which also has its <code>head</code> <code>3n</code> and its <code>tail</code> <code>4n</code>.</p>
<p>It may seem scary, but it's a friendly monster:</p>
<p><img src="Book/chapter_04/../../Imgs/listmonster.png" alt="img" /></p>
<p>[fonte da imagem: http://learnyouahaskell.com/starting-out]</p>
<h3 id="repeat"><a class="header" href="#repeat">Repeat</a></h3>
<p>The function <code>repeat</code> takes a number <code>n</code> and a value, returning a list of size <code>n</code> where all elements are the declared value.</p>
<pre><code class="language-rust ignore">// Exemplo: (Repeat 3 Bool.true) -&gt; [True, True, True]
Repeat (x: Nat) (count: Nat) : List Nat
Repeat x Nat.zero            = [] 
Repeat x (Nat.succ count)    = List.cons Nat x (Repeat count x)</code></pre>
<h3 id="length"><a class="header" href="#length">Length</a></h3>
<p>The function <code>length</code> calculates the size of the list.</p>
<pre><code class="language-rust ignore">// Exemplo: (Length [1,2,3]) -&gt; 3
Length (xs: List Nat) : Nat
Length List.nil              = 0n
Length (List.cons head tail) = (Nat.succ (Length tail))</code></pre>
<h3 id="concat"><a class="header" href="#concat">Concat</a></h3>
<p>The function <code>concat</code> concatenates (appends) two lists.</p>
<pre><code class="language-rust ignore">Concat (xs: List Nat) (ys: List Nat) : List Nat
Concat (List.nil)            ys = ys
Concat (List.cons head tail) ys = List.cons Nat head (Concat tail ys)</code></pre>
<h3 id="head-and-tail"><a class="header" href="#head-and-tail">Head and Tail</a></h3>
<p>The head function returns the first element (the &quot;head&quot;) of the list, while tail returns everything except the first element (the &quot;tail&quot;). Of course, an empty list has no first element, so we must handle this case with a <code>Maybe</code> type, receiving a <code>Maybe.none</code> if the list is empty or a <code>Maybe.some</code> if it has a value.</p>
<pre><code class="language-rust ignore">// Exemplo: (Head 0n [1n,2n,3n]) -&gt; 1n
Head (default: Nat) (xs: List Nat) :  Nat
Head default (List.nil)            = default
Head default (List.cons head tail) = head</code></pre>
<pre><code class="language-rust ignore">// Exemplo: (Tail Nat [1,2,3]) -&gt; [2,3]
Tail (xs: List Nat)        : List Nat
Tail (List.nil)            = []
Tail (List.cons head tail) = tail</code></pre>
<pre><code class="language-rust ignore">Test_head1 : Equal Nat (Head 0n [1n,2n,3n]) 1n
Test_head1 = Equal.refl</code></pre>
<pre><code class="language-rust ignore">Test_head2 : Equal Nat (Head 0n List.nil) 0n
Test_head2 = Equal.refl</code></pre>
<pre><code class="language-rust ignore">Test_head3 : Equal (List Nat) (Tail [1n, 2n, 3n]) [2n, 3n]
Test_head3 = Equal.refl</code></pre>
<h3 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h3>
<h4 id="list_funs"><a class="header" href="#list_funs">List_funs</a></h4>
<p>Complete the definitions of Nonzeros, Oddmembers, and Countoddmembers below. Take a look at the tests to understand what these functions should do.</p>
<pre><code class="language-rust ignore">Nonzeros (xs: List Nat) : List Nat
Nonzeros xs = ?</code></pre>
<pre><code class="language-rust ignore">Test_nonzeros : Equal (List Nat) (Nonzeros [0n,1n,0n,2n,3n,0n,0n]) [1n,2n,3n]
Test_nonzeros = ?</code></pre>
<pre><code class="language-rust ignore">Oddmembers (xs: List Nat) : List Nat
Oddmembers xs = ?</code></pre>
<pre><code class="language-rust ignore">Test_oddmembers : Equal (List Nat) (Oddmembers [0n,1n,0n,2n,3n,0n,0n]) [1n,3n]
Test_oddmembers = ?</code></pre>
<pre><code class="language-rust ignore">CountOddMembers (xs: List Nat)  : Nat
CountOddMembers xs = ?</code></pre>
<pre><code class="language-rust ignore">Test_countoddmembers1 : Equal Nat (CountOddMembers [1n,0n,3n,1n,4n,5n]) 4n
Test_countoddmembers1 = ?</code></pre>
<h4 id="alternate"><a class="header" href="#alternate">Alternate</a></h4>
<p>Complete the definition of alternate, which <code>compacts</code> two lists into one, alternating between elements taken from the first list and elements from the second. See the tests below for more specific examples.</p>
<pre><code class="language-rust ignore">Alternate (xs: List Nat) (ys: List Nat) : List Nat
Alternate xs ys = ?</code></pre>
<pre><code class="language-rust ignore">Test_alternate1 : Equal (List Nat) (Alternate [1n,2n,3n] [4n,5n,6n]) [1n,4n,2n,5n,3n,6n]
Test_alternate1 = ?</code></pre>
<pre><code class="language-rust ignore">Test_alternate2 : Equal (List Nat) (Alternate [1n] [4n,5n,6n]) [1n,4n,5n,6n]
Test_alternate2 = ?</code></pre>
<pre><code class="language-rust ignore">Test_alternate3 : Equal (List Nat) (Alternate  [1n,2n,3n] [4n]) [1n,4n,2n,3n]
Test_alternate3 = ? </code></pre>
<pre><code class="language-rust ignore">Test_alternate4 : Equal (List Nat) (Alternate [] [20n,30n]) [20n,30n]
Test_alternate4 = ?</code></pre>
<h4 id="functions-1"><a class="header" href="#functions-1">Functions</a></h4>
<p>Complete the following definitions for the count, sum, add, and member functions of natural number lists.</p>
<pre><code class="language-rust ignore">Count (v: Nat) (xs: List Nat) : Nat
Count v xs = ?</code></pre>
<pre><code class="language-rust ignore">Test_count1 : Equal Nat (Count 1n [1n,2n,3n,1n,4n,1n]) 3n
Test_count1 = ?</code></pre>
<pre><code class="language-rust ignore">Test_count2 : Equal Nat (Count 6n [1n,2n,3n,1n,4n,1n]) 0n
Test_count2 = ?</code></pre>
<pre><code class="language-rust ignore">Sum (xs: List Nat) (ys: List Nat) : List Nat
Sum xs ys = ?</code></pre>
<pre><code class="language-rust ignore">Test_sum1 : Equal Nat (Count 1n (Sum [1n,2n,3n] [1n,4n,1n])) 3n
Test_sum1 = ?</code></pre>
<pre><code class="language-rust ignore">Add (n: Nat) (xs: List Nat) : List Nat
Add n xs = ?</code></pre>
<pre><code class="language-rust ignore">Test_add1 : Equal Nat (Count 1n (Add 1n [1n,4n,1n])) 3n
Test_add1 = ?</code></pre>
<pre><code class="language-rust ignore">Test_add2 : Equal Nat (Count 5n (Add 1n [1n,4n,1n])) 0n
Test_add2 = ?</code></pre>
<pre><code class="language-rust ignore">Member (v: Nat) (xs: List Nat) : Bool
Member v xs = ?</code></pre>
<pre><code class="language-rust ignore">Test_member1 : Equal Bool (Member 1n [1n,4n,1n]) Bool.true
Test_member1 = ?</code></pre>
<pre><code class="language-rust ignore">Test_member2 : Equal Bool (Member 2n [1n,4n,1n]) Bool.false
Test_member2 = ?</code></pre>
<h4 id="more_functions"><a class="header" href="#more_functions">More_functions</a></h4>
<p>Here are some more functions of <code>List Nat</code> for you to practice with. When remove_one is applied to a list without the number to be removed, it should return the same unchanged list.</p>
<pre><code class="language-rust ignore">Remove_one (v: Nat) (xs: List Nat) : List Nat
Remove_one v xs = ?</code></pre>
<pre><code class="language-rust ignore">Test_remove_one1 : Equal Nat (Count 5n (Remove_one 5n [2n,1n,5n,4n,1n])) 0n
Test_remove_one1 = ?</code></pre>
<pre><code class="language-rust ignore">Test_remove_one2 : Equal Nat (Count 5n (Remove_one 5n [2n,1n,4n,1n])) 0n
Test_remove_one2 = ?</code></pre>
<pre><code class="language-rust ignore">Test_remove_one3 : Equal Nat (Count 4n (Remove_one 5n [2n,1n,5n,4n,1n,4n])) 2n
Test_remove_one3 = ?</code></pre>
<pre><code class="language-rust ignore">Test_remove_one4 : Equal Nat (Count 5n (Remove_one 5n [2n,1n,5n,4n,5n,1n,4n])) 1n
Test_remove_one4 = ?</code></pre>
<pre><code class="language-rust ignore">Remove_all (v: Nat) (xs: List Nat) : List Nat
Remove_all v xs = ?</code></pre>
<pre><code class="language-rust ignore">Test_remove_all1  : Equal Nat (Count 5n (Remove_all 5n [2n,1n,5n,4n,1n])) 0n
Test_remove_all1  = ?</code></pre>
<pre><code class="language-rust ignore">Test_remove_all2  : Equal Nat (Count 5n (Remove_all 5n [2n,1n,4n,1n])) 0n
Test_remove_all2  = ?</code></pre>
<pre><code class="language-rust ignore">Test_remove_all3  : Equal Nat (Count 4n (Remove_all 5n [2n,1n,5n,4n,1n,4n])) 2n
Test_remove_all3  = ?</code></pre>
<pre><code class="language-rust ignore">Test_remove_all4  : Equal Nat (Count 5n (Remove_all 5n [2n,1n,5n,4n,5n,1n,4n,5n,1n,4n])) 0n
Test_remove_all4  = ?</code></pre>
<pre><code class="language-rust ignore">Subset (xs: List Nat) (ys: List Nat)  : Bool
Subset xs ys = ?</code></pre>
<pre><code class="language-rust ignore">Test_subset1 : Equal Bool (Subset [1n,2n] [2n,1n,4n,1n]) Bool.true
Test_subset1 = ?</code></pre>
<pre><code class="language-rust ignore">Test_subset2 : Equal Bool (Subset [1n,2n,2n] [2n,1n,4n,1n]) Bool.false
Test_subset2 = ?</code></pre>
<h4 id="theorem"><a class="header" href="#theorem">Theorem</a></h4>
<p>Write down an interesting theorem involving the count and add functions and prove it. Note that, as this problem is somewhat open-ended, you may come up with a theorem that is true but whose proof requires techniques you have not yet learned. Feel free to ask for help if you get stuck!</p>
<pre><code class="language-rust ignore">Theorem : ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="reasoning-about-lists"><a class="header" href="#reasoning-about-lists">Reasoning about Lists</a></h2>
<p>Just like numbers, simple facts about list processing functions can sometimes be entirely proven by simplification. For example, the simplification performed by <code>Equal.refl</code> is sufficient for this theorem...</p>
<pre><code class="language-rust ignore">`List.nil`_app (xs: List Nat) : Equal (Concat (List.nil Nat) xs) xs
`List.nil`_app xs = Equal.refl</code></pre>
<p>...this is because the Type &quot;sees&quot; the <code>List.nil</code> and automatically reduces equality just as it does with natural numbers and <code>Nat.zero</code>.</p>
<p>Furthermore, as with numbers, it is sometimes useful to perform a case analysis on the possible forms (empty or non-empty) of an unknown list.</p>
<pre><code class="language-rust ignore">Tl_length_pred (xs: List Nat)         : Equal Nat (Pred (Length xs)) (Length (Tail xs))
Tl_length_pred List.nil               = Equal.refl
Tl_length_pred (List.cons head tail)  = Equal.refl</code></pre>
<p>If the user does not open the cases and uses <code>Equal.refl</code> directly, the Type returns a type error:</p>
<pre><code class="language-diff">- ERROR  Type mismatch

   • Got      : Equal Nat (Nat.pred (Length xs)) (Nat.pred (Length xs)) 
   • Expected : Equal Nat (Nat.pred (Length xs)) (Length (Tail xs)) 

   • Context: 
   •   xs : (List Nat) 

   Tl_length_pred xs = Equal.refl
                       ┬─────────
                       └Here!
</code></pre>
<p>Similarly, some theorems require induction for their proofs.</p>
<ul>
<li><em>Micro-Sermon. Simply reading example proof scripts won't get you very far! It's important to work through the details of each one, using the Type and thinking about what each step achieves. Otherwise, it's more or less guaranteed that the exercises won't make sense when you get to them</em>. ( ಠ ʖ̯ ಠ)</li>
</ul>
<h3 id="induction-on-lists"><a class="header" href="#induction-on-lists">Induction on Lists</a></h3>
<p>Proofs by induction on data types like <code>List</code> are a bit less familiar than standard natural number induction, but the idea is equally simple. Each data declaration defines a set of data values that can be constructed using the declared constructors: a boolean can be True or False; a number can be Zero or Succ applied to another number; a list of naturals can be <code>List.nil</code> or <code>List.cons</code> applied to a number and a list.</p>
<p>Moreover, the applications of the declared constructors to each other are the only possible forms that elements of an inductively defined set can have, and this fact directly gives rise to a way of reasoning about inductively defined sets: a number is Zero or else it is Succ applied to a smaller number; a list is <code>List.nil</code> or else it is a <code>List.cons</code> applied to some number and a smaller list, etc. So, if we have in mind some proposition <code>p</code> that mentions a list<code>l</code> and we want to argue that <code>p</code> holds for all lists, we can reason as follows:</p>
<ul>
<li>First, show that <code>p</code> is true for <code>l</code> when <code>l</code> is <code>List.nil</code>.</li>
<li>Then show that <code>p</code> is true for <code>l</code> when <code>l</code> is <code>List.cons n l</code> for some number <code>n</code> and some smaller list <code>l</code>, assuming that <code>p</code> is true for <code>l</code>.</li>
</ul>
<p>Since larger lists can only be constructed from smaller lists, eventually reaching <code>List.nil</code>, these two arguments together establish the truth of <code>p</code> for all lists <code>l</code>. Here's a concrete example:</p>
<pre><code class="language-rust ignore">Concat_assoc (xs: List Nat) (ys: List Nat) (zs: List Nat) : Equal (Concat (Concat xs ys) zs) (Concat xs (Concat ys zs))
Concat_assoc List.nil                               ys zs = Equal.refl
Concat_assoc (List.cons Nat xs.head xs.tail)        ys zs = 
  let ind = Concat_assoc xs.tail ys zs
  let app = Equal.apply (x =&gt; (List.cons xs.head x)) ind
  app</code></pre>
<p>We are given three lists <code>xs</code>, <code>ys</code>, and <code>zs</code> and we check if concatenating <code>xs</code> and <code>ys</code> with <code>zs</code> is equal to concatenating <code>xs</code> with the concatenation of <code>ys</code> and <code>zs</code>.</p>
<p>For this, we check for the case where <code>xs</code> is an empty list, then we receive a reflection that the concatenation is between <code>ys</code> and <code>zs</code>, and it suffices to give an <code>Equal.refl</code>.</p>
<p>Next, we &quot;open up&quot; <code>xs</code> to obtain <code>xs.tail</code> for our induction, and we receive as the objective:</p>
<pre><code> • Expected: Equal (List Nat) (List.cons Nat xs.head (Concat (Concat xs.tail ys) zs)) (List.cons Nat xs.head (Concat xs.tail (Concat ys zs))) 
</code></pre>
<p>and our <code>ind</code> variable is:</p>
<pre><code> • ind: Equal (List Nat) (Concat (Concat xs.tail ys) zs) (Concat xs.tail (Concat ys zs))
</code></pre>
<p>it is sufficient to apply a L<code>ist.cons xs.head</code> on both sides of the equality to obtain the final objective, which is what we do in <code>app</code>:</p>
<pre><code> • app : Equal (List Nat) (List.cons Nat xs.head (Concat (Concat xs.tail ys) zs)) (List.cons Nat xs.head (Concat xs.tail (Concat ys zs)))
</code></pre>
<p><em>NOTE</em></p>
<p>e Type Check returns types <code>t2</code>, <code>t3</code>, and others generated in the same style, which we can ignore and even delete when comparing the return of variables, as we see in the following case</p>
<pre><code> • Expected: Equal (List Nat) (List.cons Nat xs.head (Concat (Concat xs.tail ys) zs)) (List.cons Nat xs.head (Concat xs.tail (Concat ys zs))) 
 •   app   : Equal (List Nat) (List.cons Nat xs.head (Concat (Concat xs.tail ys) zs)) (List.cons Nat xs.head (Concat xs.tail (Concat ys zs)))
</code></pre>
<!-- e apagando os tipos gerados e os `holes`:

```
- Expected: Equal (List) (List.cons xs.head (Concat (Concat xs.tail ys) zs)) (List.cons xs.head (Concat xs.tail (Concat ys zs))))
- app : Equal (List) (List.cons xs.head (Concat (Concat xs.tail ys) zs)) (List.cons xs.head (Concat xs.tail (Concat ys zs))))
``` -->
<!-- TODO holes -->
<p>This way it's easier to see that <code>app</code> and <code>Expected</code> are identical, so there's no need to be alarmed when seeing these generated types.</p>
<h4 id="reversing-a-list"><a class="header" href="#reversing-a-list">Reversing a list</a></h4>
<p>For a slightly more complicated example of inductive proof about lists, suppose we use <code>Concat</code> to define a list reversal function <code>Rev</code>:</p>
<pre><code class="language-rust ignore">Rev (xs: List Nat)        : List Nat
Rev List.nil              = List.nil Nat
Rev (List.cons head tail) = Concat (Rev tail) [head]

Test_rev1 : Equal (List Nat) (Rev [1n,2n,3n]) [3n,2n,1n]
Test_rev1 = Equal.refl

Test_rev2 : Equal (Rev List.nil) List.nil
Test_rev2 = Equal.refl</code></pre>
<h4 id="properties-of-rev"><a class="header" href="#properties-of-rev">Properties of Rev</a></h4>
<p>Now let's prove some theorems about the <code>Rev</code> we just defined. For something a bit more challenging than what we've seen, let's prove that reversing a list doesn't change its length. Our first attempt gets stuck at the successor case...</p>
<pre><code class="language-rust ignore">Rev_length_firsttry (xs: List Nat)              : Equal Nat (Length (Rev xs)) (Length xs)
Rev_length_firsttry List.nil                    = Equal.refl
Rev_length_firsttry (List.cons xs.head xs.tail) =
   let ind = Rev_length_firsttry xs.tail
   ?</code></pre>
<p>The <code>Type Check</code> returns the following goal and context:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: Equal Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Nat.succ (Length tail)) 

   • Context: 
   •   head : Nat 
   •   tail : (List Nat) 
   •   ind  : Equal Nat (Length (Rev tail)) (Length tail)
   •   ind  = (Rev_length_firsttry tail) 

   let ind = Rev_length_firsttry tail
      ?
      ┬
      └Here!
</code></pre>
<p>Now we have to prove that the length of the concatenation of the reverse of the tail of the list and its head is equal to the successor of the length of the tail, so we'll need to use some other proofs, one of which is that the length of the concatenation of two lists is the same as the sum of the lengths of each of them:</p>
<pre><code class="language-rust ignore">Concat_length (xs: List Nat) (ys: List Nat)  : Equal Nat (Length (Concat xs ys)) (Plus (Length xs) (Length ys))
Concat_length List.nil ys                    = Equal.refl
Concat_length (List.cons xs.head xs.tail) ys =
   let ind = Concat_length xs.tail ys
   let app = Equal.apply (x =&gt; (Nat.succ x)) ind
   app</code></pre>
<p>In addition to this proof, we'll use others already proven in previous chapters:</p>
<pre><code class="language-rust ignore">Plus_n_z (n: Nat)     : Equal Nat n (Plus n Nat.zero)
Plus_n_sn (n: Nat) (m: Nat) : Equal Nat (Nat.succ (Plus n m)) (Plus n (Nat.succ m))
Plus_comm (n: Nat) (m: Nat) : Equal Nat (Plus n m) (Plus m n)</code></pre>
<p>And now we can prove our theorem:</p>
<pre><code class="language-rust ignore">Rev_length (xs: List Nat)               : Equal Nat (Length (Rev xs)) (Length xs)
Rev_length List.nil                     = Equal.refl
Rev_length (List.cons Nat head tail)  =
   let ind   = Rev_length tail
   ?</code></pre>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: Equal Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Nat.succ (Length tail)) 

   • Context: 
   •   head : Nat 
   •   tail : (List Nat) 
   •   ind  : Equal Nat (Length (Rev tail)) (Length tail) 
   •   ind  = (Rev_length tail) 

   let ind   = Rev_length tail
      ?
      ┬
      └Here!
</code></pre>
<p>We create a variable with our auxiliary <code>Concat_length</code>:</p>
<pre><code class="language-rust ignore">Rev_length (xs: List Nat)             : Equal Nat (Length (Rev xs)) (Length xs)
Rev_length List.nil                   = Equal.refl
Rev_length (List.cons Nat head tail)  =
   let ind  = Rev_length tail
   let aux1 = Concat_length (Rev xs.tail) [xs.head]
   ?</code></pre>
<p>We receive a new context for our auxiliaries...</p>
<pre><code> • aux1: Equal Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Plus (Length (Rev tail)) 1n)
</code></pre>
<p>... the <code>aux1</code> is equal to the left side of our <code>Expected</code>, so half the work is already done, we just need the other side of the equality and for that we create a new variable, <code>aux2</code>:</p>
<pre><code class="language-rust ignore">let aux2 = Plus_comm (Length (Rev xs.tail)) (1n)</code></pre>
<p>Now our context is even better:</p>
<pre><code class="language-rust ignore"> • aux2: Equal Nat (Plus (Length (Rev tail)) 1n) (Nat.succ (Length (Rev tail))) </code></pre>
<p>As we make progress in our formal proofs, we can see that the left side of <code>aux2</code> is equal to the right side of <code>aux1</code>, and we can chain them together using <code>Equal.chain</code>:</p>
<pre><code class="language-rust ignore">let chn = Equal.chain aux1 aux2</code></pre>
<p>When we Type Check, we see our new context:</p>
<pre><code class="language-Terminal"> • chn : Equal Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Nat.succ (Length (Rev tail)))
</code></pre>
<p>Nossa variável <code>chn</code> é praticamente idêntica ao nosso <code>Expected</code> só diferindo na parte final, pois <code>Expected</code> espera um <code>Nat.succ (Length xs.tail)</code> e o <code>chn</code> nos dá <code>Nat.succ (Length (Rev xs.tail))</code>, mas nós temos a variável <code>ind</code> que nos retorna essa igualdade. Vamos relembrar:</p>
<p>Our <code>chn</code> variable is practically identical to our <code>Expected</code>, differing only in the final part, since <code>Expected</code> expects a <code>Nat.succ (Length xs.tail)</code> and <code>chn</code> gives us <code>Nat.succ (Length (Rev xs.tail))</code>, but we have the <code>ind</code> variable that returns us this equality. Let's remember:</p>
<pre><code class="language-Terminal"> • ind: Equal Nat (Length (Rev tail)) (Length tail) 
</code></pre>
<p>Incredible, isn't it? It returns exactly what we need, that the size of the reverse of the <code>tail</code> is equal to the size of the <code>tail</code>, so we just need to rewrite the <code>ind</code> variable in our <code>chn</code>:</p>
<pre><code class="language-rust ignore">let rrt = Equal.rewrite ind (x =&gt; Equal Nat (Length (Concat (Rev tail) (List.cons head (List.nil)))) (Nat.succ x )) chn</code></pre>
<p>Let's see our new context, only hiding the types for easier reading:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: Equal Nat (Length (Concat (Rev tail) (List.cons _ head (List.nil _)))) (Nat.succ (Length tail)) 

   • Context: 
   •   head : Nat 
   •   tail : (List Nat) 
   •   ind  : Equal Nat (Length (Rev tail)) (Length tail) 
   •   ind  = (Rev_length tail) 
   •   aux1 : Equal Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Plus (Length (Rev tail)) 1n) 
   •   aux1 = (Concat_length (Rev tail) (List.cons Nat head (List.nil Nat))) 
   •   aux2 : Equal Nat (Plus (Length (Rev tail)) 1n) (Nat.succ (Length (Rev tail))) 
   •   aux2 = (Plus_comm (Length (Rev tail)) 1n) 
   •   chn  : Equal Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Nat.succ (Length (Rev tail)))
   •   chn  = Equal.chain Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Plus (Length (Rev tail)) 1n) (Nat.succ (Length (Rev tail))) aux1 aux2 
   •   rrt  : Equal Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Nat.succ (Length tail)) 
   •   rrt  = Equal.rewrite Nat (Length (Rev tail)) (Length tail) ind (x =&gt; Equal Nat (Length (Concat (Rev tail) (List.cons Nat head (List.nil Nat)))) (Nat.succ x))) chn
</code></pre>
<p>Now it's much easier to see that our <code>rrt</code> is exactly our <code>Expected</code>, so our proof is as follows:</p>
<pre><code class="language-rust ignore">Rev_length (xs: List Nat)            : Equal Nat (Length (Rev xs)) (Length xs)
Rev_length List.nil                  = Equal.refl
Rev_length (List.cons Nat head tail) =
   let ind   = Rev_length tail
   let aux1  = Concat_length (Rev tail) [head]
   let aux2  = Plus_comm (Length (Rev tail)) (1n)
   let chn   = Equal.chain aux1 aux2
   let rrt = Equal.rewrite ind (x =&gt; Equal Nat (Length (Concat (Rev tail) [head])) (Nat.succ x)) chn
   rrt</code></pre>
<h3 id="list-exercises-part-1"><a class="header" href="#list-exercises-part-1">List Exercises, Part 1</a></h3>
<h4 id="list_exercises"><a class="header" href="#list_exercises">List_exercises</a></h4>
<p>Let's practice a little more with lists:</p>
<pre><code class="language-rust ignore">Concat_nil_r (xs: List Nat) : Equal (Concat xs List.nil) xs
Concat_nil_r xs = ?

Concat_assoc (xs: List Nat) (ys: List Nat) (zs: List Nat) : Equal (Concat (Concat xs ys) zs) (Concat xs (Concat ys zs))
Concat_assoc xs ys zs = ?

Rev_app_distr (xs: List Nat) (ys: List Nat) : Equal (Rev (Concat xs ys)) (Concat (Rev ys) (Rev xs))
Rev_app_distr xs ys = ?

Rev_involutive (xs: List Nat) : Equal (Rev (Rev xs)) xs
Rev_involutive xs = ?</code></pre>
<p>There is a short solution to the next one. If you find it too difficult or it starts to get too long, step back and try to find a simpler way.</p>
<pre><code class="language-rust ignore">Concat_assoc4 (l1: List Nat) (l2: List Nat) (l3: List Nat) (l4: List Nat) : Equal (List Nat) (Concat l1 (Concat l2 (Concat l3 l4))) (Concat (Concat (Concat l1 l2) l3) l4)
Concat_assoc4 l1 l2 l3 l4 = ? </code></pre>
<p>An exercise on your implementation of <code>Nonzeros</code>:</p>
<pre><code class="language-rust ignore">Nonzeros_app (xs: List Nat) (ys: List Nat) : Equal (List Nat) (Nonzeros (Concat xs ys)) (Concat (Nonzeros xs) (Nonzeros ys))
Nonzeros_app xs ys = ?</code></pre>
<h4 id="beq_natlist"><a class="header" href="#beq_natlist">Beq_NatList</a></h4>
<p>Fill in the definition of <code>beq_NatList</code>, which compares lists of numbers for equality. Prove that <code>beq_NatList</code> xs ys produces <code>Bool.true</code> for each list.</p>
<pre><code class="language-rust ignore">Beq_NatList (xs: List Nat) (ys: List Nat) : Bool
Beq_NatList xs ys = ? 

Test_beq_natlist1 : Equal Bool (Beq_list List.nil List.nil) Bool.true
Test_beq_natlist1 = ?

Test_beq_natlist2 : Equal Bool (Beq_list [1n,2n,3n] [1n,2n,3n]) Bool.true
Test_beq_natlist2 = ?

Test_beq_natlist3 : Equal Bool (Beq_list [1n,2n,3n] [1n,2n,4n]) Bool.false
Test_beq_natlist3 = ?

Beq_natlist_refl (xs: List Nat) : Equal Bool Bool.true (Beq_list xs xs)
Beq_natlist_refl xs = ?</code></pre>
<h3 id="list-exercises-part-2"><a class="header" href="#list-exercises-part-2">List Exercises, Part 2</a></h3>
<h4 id="proofs"><a class="header" href="#proofs">Proofs</a></h4>
<p>Prove the following theorem, it will help you in the next proof:</p>
<pre><code class="language-rust ignore">Ble_n_succ_n (n: Nat) : Equal Bool (Lte n (Nat.succ n)) Bool.true
Ble_n_succ_n n = ? </code></pre>
<p>Prove the following theorem, it will help you in the next proof:</p>
<pre><code class="language-rust ignore">Count_member_nonzero (xs: List Nat) : Equal Bool (Lte 1n (Count 1n (List.cons 1n xs))) Bool.true
Count_member_nonzero xs = ?</code></pre>
<h4 id="rev_injective"><a class="header" href="#rev_injective">Rev_injective</a></h4>
<p>Prove that the <code>Rev</code> function is injective - that is,</p>
<pre><code class="language-rust ignore">Rev_injective (xs: List Nat) (ys: List Nat) (e: Equal (List Nat) (Rev xs) (Rev ys)) :tail Equal (List Nat) xs ys
Rev_injective xs ys e = ?  </code></pre>
<h4 id="opcional-count_sum"><a class="header" href="#opcional-count_sum">Opcional: Count_sum</a></h4>
<p>Write an interesting theorem about Lists involving the functions count and sum, and prove it. (You may find that the difficulty of the test depends on how you set the count!)</p>
<pre><code class="language-rust ignore">Count_sum : ?
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="maybe"><a class="header" href="#maybe">Maybe</a></h2>
<p>Suppose we want to write a function that returns the nth number of a list.
We then define a number that is applied to a list of naturals and returns the number that occupies that position. Therefore, we need to define a number to be returned if the number is greater than the size of the list.</p>
<pre><code class="language-rust ignore">Nth_bad (n: Nat) (xs: List Nat)            : Nat
Nth_bad n List.nil                         = 42n // arbitrary value 
Nth_bad Nat.zero (List.cons head tail)     = head
Nth_bad (Nat.succ n) (List.cons head tail) = Nth_bad n tail</code></pre>
<p>This solution is not so good: if nth_bad returns 0, we cannot tell if that value actually appears in the input without further processing. A better alternative is to change the return type of nth_bad to include an error value as a possible result.</p>
<p>We call this type <code>Maybe</code>, because it may or may not have something; if it has, it is a <code>Maybe.some</code> of that something, if it does not have, it is a <code>Maybe.none</code>.</p>
<pre><code class="language-rust ignore">type Maybe (t) {
  none 
  some (value: t)
}</code></pre>
<p>We can then change the above definition of nth_bad to return None when the list is too short and Some when the list has enough members and appears at the position n. We call this new function nth_error to indicate that it may result in an error.</p>
<p>This proof also serves to introduce us to another feature of Kind, conditional expressions, the <code>if</code> and <code>else</code>.</p>
<pre><code class="language-rust ignore">Nth_error (n: Nat) (xs: List Nat) : Maybe Nat
Nth_error n List.nil              = Maybe.none
Nth_error n (List.cons head tail) = 
  let ind = Nth_error (Pred n) tail
  Bool.if (Eql n 0n) (Maybe.some Nat head) (ind)

Test_nth_error1 : Equal (Nth_error 0n [4n,5n,6n,7n]) (Maybe.some 4n)
Test_nth_error1 = Equal.refl

Test_nth_error2 : Equal (Nth_error 3n [4n,5n,6n,7n]) (Maybe.some 7n)
Test_nth_error2 = Equal.refl

Test_nth_error3 : Equal (Nth_error 9n [4n,5n,6n,7n]) Maybe.none
Test_nth_error3 = Equal.refl</code></pre>
<!-- TODO -->
<pre><code class="language-rust ignore">Extract (d: Nat) (o: Maybe Nat) : Nat
Extract d (Maybe.some k)        = k
Extract d (Maybe.none)          = d</code></pre>
<h4 id="head_error"><a class="header" href="#head_error">Head_error</a></h4>
<p>Using the same idea, correct the <code>Head</code> function from before so that we don't have to pass a default element for the case <code>List.nil</code>.</p>
<pre><code class="language-rust ignore">Head_error (xs: List Nat) : Maybe Nat
Head_error xs = ?

Test_head_error1 : Equal (Head_error List.nil) Maybe.none
Test_head_error1 = ?

Test_head_error2 : Equal (Head_error [1n]) (Maybe.some Nat 1n)
Test_head_error2 = ?

Test_head_error3 : Equal (Head_error  [5n,6n]) (Maybe.some Nat 5n)
Test_head_error3 = ?</code></pre>
<h4 id="opcional-extract_head"><a class="header" href="#opcional-extract_head">Opcional: Extract_head</a></h4>
<p>This exercise relates your new <code>Head_error</code> to the old <code>Head</code>.</p>
<pre><code class="language-rust ignore">Extract_head (l: List Nat) (default: Nat) : Equal Nat (Head default l)  (Extract default (Head_error l))
Extract_head l default = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h1>
<p>In this chapter, we continue our development of basic programming concepts. Our new essential principles are polymorphism (abstraction functions over the data types they manipulate) and higher-order functions (treating functions as data). We begin with polymorphism.</p>
<h2 id="polymorphic-lists"><a class="header" href="#polymorphic-lists">Polymorphic Lists</a></h2>
<p>In the last two chapters, we worked with polymorphic lists, you may just not have realized it. Obviously, interesting programs also need to be able to manipulate lists with elements of other types - lists of strings, lists of booleans, lists of lists, etc. We could just define a new inductive data type for each of them, for example...</p>
<pre><code class="language-rust ignore">type BoolList {
   nil 
   cons (head: Bool) (tail: List Bool) 
}</code></pre>
<p>...but that would quickly become tedious, in part because we have to compensate for different constructor names for each data type, but mainly because we also need to define new versions of all our list manipulation functions (length, rev, etc.) for each new data type definition.</p>
<p>To avoid all this repetition, <strong>Kind</strong> supports definitions of polymorphic inductive types. For example, here is a polymorphic list data type that we already saw in the previous chapter:</p>
<pre><code class="language-rust ignore">type List (t) {
   nil 
   cons (head: t) (tail: List t) 
}</code></pre>
<p>This type already exists in Kind and we can see that it is identical to BoolList, but with a type <code>a</code>, which receives any other type, be it <strong>Nat</strong>, <strong>Bool</strong>, <strong>Maybe</strong>, etc. We don't need to create a list type for each of the data types, we can use this one that adopts all existing forms.</p>
<p>What kind of thing is the List itself? A good way to think about it is that List is a Types function for inductive definitions; or, in other words, List is a Types function for Types. For any specific type x, the type List x is an inductively defined set of lists whose elements are of type x.</p>
<p>With this definition, when we use the constructors <code>List.nil</code> and <code>List.cons</code> to build lists, we need to tell Kind the type of elements in the lists we are building - that is, that <code>List.nil</code> and <code>List.cons</code> are now polymorphic constructors. Note the types of constructors:</p>
<pre><code class="language-rust ignore">record Pair (a) (b) {
  fst : a
  snd : b
}</code></pre>
<p>Our <strong>Pair</strong> type receives two other types, <code>a</code> and <code>b</code>, and returns a pair of the two types. It was not necessary to define whether the pair was of natural numbers, booleans, lists, bits or other pairs, we left the function capable of handling all possible pairs and this is thanks to <em>polymorphism</em>.</p>
<p>Now we can go back and make polymorphic versions of all the processing lists functions we wrote before. Here's the repeat function again, for example:</p>
<pre><code class="language-rust ignore">Repeat &lt;a: Type&gt; (x: a) (count: Nat) : List a
Repeat a x Nat.zero                  = List.nil
Repeat a x (Nat.succ count)          = List.cons x (Repeat x count)</code></pre>
<p>Just like with <code>List.nil</code> and <code>List.cons</code>, we can use repeat by first applying it to a type and then to its list argument:</p>
<pre><code class="language-rust ignore">Test_repeat1 : Equal (Repeat 4n 2n) (List.cons 4n (List.cons 4n List.nil))
Test_repeat1 = Equal.refl</code></pre>
<p>To use repeat to build other types of lists, we simply instantiate it with an appropriate type parameter:</p>
<pre><code class="language-rust ignore">Test_repeat2 : Equal (Repeat Bool.false 1n) (List.cons Bool.false List.nil)
Test_repeat2 = Equal.refl</code></pre>
<h3 id="type-annotation-inference"><a class="header" href="#type-annotation-inference">Type Annotation Inference</a></h3>
<p>Let's write the definition of <code>repeat</code> again, but this time omitting the type. However, please note that this is not a good practice to use the <code>hole</code>, it will only serve to understand the power of Kind and how it can help the user find what they want.</p>
<pre><code class="language-rust ignore">Repeat (x: _) (count: Nat) : List _
Repeat x Nat.zero          = ?</code></pre>
<p>When running the <em>Type Check</em>, the terminal returns:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: (List _) 

   • Context: 
   •   x : _ 

   Repeat x Nat.zero = ?
                       ┬
                       └Here!
</code></pre>
<p>For the case where the count is zero, which is our stopping point, we need to return a list of undefined type.</p>
<p>As we did when our type was defined, we are creating a list that does not repeat the term at all, we return a <code>List.nil</code>, then we check for the case of a list that will repeat the value count times, for this we will use recursion through <code>Nat.succ pred</code>, that is, our count is equal to the successor of its predecessor.</p>
<pre><code class="language-rust ignore">Repeat x (Nat.succ count) = ?</code></pre>
<p>And the <em>Type Check</em> returns:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: (List _) 

   • Context: 
   •   x     : _ 
   •   count : Nat 

   Repeat x (Nat.succ count) = ?
                               ┬
                               └Here!
</code></pre>
<p>Now we just need to construct the list with the value and call the function for the predecessor of count, thus building the list until it reaches zero.</p>
<pre><code class="language-rust ignore">Repeat (x: _) (count: Nat) : List _
Repeat x Nat.zero          = List.nil
Repeat x (Nat.succ count)  = List.cons x (Repeat x count)</code></pre>
<p>We can see that, even though we didn't define the type of <code>x</code>, the <strong>Kind</strong> is powerful enough to discover the type that our x is when we use the <code>_</code> <em>hole</em>. Although it is possible and may even facilitate building an entire application using this notation, it is not a good practice since, depending on the case, a different type than the desired one may be inferred. It is interesting to always define the type of our element, even if it is a polymorphic type.</p>
<p>In the first case, when we define the type <code>a</code>, we already encompass all possible types, so it is not necessary to use the hole and that is the magic of polymorphism, it allows us to use the same function for different types.</p>
<p>To use a polymorphic function, we need to pass one or more types in addition to the other arguments. For example, in the case of repeat, we pass the type <code>&lt;a: Type&gt;</code> and that each element of our list is of that type. We did the same with the <em>Pair</em> type, which received two types <code>a</code> and <code>b</code> as arguments.</p>
<p>Now it is much easier to understand the examples we used in the previous chapter, when we presented functions like length and append:</p>
<pre><code class="language-rust ignore">Length &lt;a&gt; (xs: List a) : Nat
Length (List.nil t)            = Nat.zero
Length (List.cons t head tail) = (Nat.succ (Length tail))

Concat &lt;a: Type&gt; (xs: List a) (ys: List a) : List a
Concat (List.nil)                     ys = ys
Concat (List.cons head tail)          ys = List.cons head (Concat tail ys)
</code></pre>
<p>Note that there are two notations, one where we only use <code>&lt;a&gt;</code> and another where we use <code>&lt;a: Type&gt;</code>, we can use either one, the <strong>Kind</strong> is capable of understanding both forms, it will be up to the developer to choose which one to use and the complexity of what will be developed, since in very complex code, it may be interesting to make explicit to other programmers what each thing is.</p>
<p>Now it's time to implement our functions with implicit typing, using <code>hole</code> and <code>sugar syntax</code>:</p>
<pre><code class="language-rust ignore">Concat_implicito (xs: List _) (ys: List _) : List _
Concat_implicito []                     ys = ys
Concat_implicito (List.cons head tail)  ys = List.cons head (Concat_implicito tail ys)</code></pre>
<p>Here we learned one more thing, the <code>sugar syntax</code> for an empty list is just <code>[]</code>, but this is wrong, since the <code>sugar syntax</code> for kind doesn't work on the left side of the function scope, only on the right side. Using the wrong <code>sugar syntax</code> results in an error shown by <strong>Kind</strong>:</p>
<pre><code class="language-diff">- ERROR  Unexpected token '['.
    Concat_implicito []  ys = ys
                  ┬
                  └Here!
</code></pre>
<p>Therefore, it is always important to know exactly what is being done, especially when using <em>sugar syntax</em>. It is meant to make our lives easier but can cause problems when used incorrectly. This also applies to <code>hole</code> and polymorphic types help us write a safer program that can be used for countless cases.</p>
<p>We can also rewrite the <code>reverse</code> function:</p>
<pre><code class="language-rust ignore">Rev &lt;a&gt; (xs: List a) : List a
Rev List.nil              = [] // sugar syntax de List.nil
Rev (List.cons head tail) = Concat (Rev tail) [head] // sugar syntax de (List.cons head List.nil)

Length &lt;a&gt; (xs: List a) : Nat
Length List.nil              = 0n // sugar syntax de Nat.zero
Length (List.cons head tail) = Nat.succ (Length tail)</code></pre>
<p>After that, we just need to prove that our functions are correct:</p>
<pre><code class="language-rust ignore">Test_rev1 : Equal (Rev [1,2,3]) [3,2,1]
Test_rev1 = Equal.refl

Test_rev2 : Equal (Rev [Bool.true]) [Bool.true]
Test_rev2 = Equal.refl

Test_length1 : Equal (Length [1,2,3]) 3n
Test_length1 = Equal.refl</code></pre>
<h4 id="polymorphic-exercises"><a class="header" href="#polymorphic-exercises">Polymorphic Exercises</a></h4>
<p>Here are some simple exercises, similar to the ones in the Lists section, to practice polymorphism. Complete the proofs below.</p>
<pre><code class="language-rust ignore">Concat_nil_r &lt;a&gt; (xs: List a) : Equal (Concat xs List.nil) xs
Concat_nil_r xs = ?

Concat_assoc &lt;a&gt; (xs: List a) (ys: List a) (zs: List a) : Equal (Concat xs (Concat ys zs)) (Concat (Concat xs ys) zs)
Concat_assoc xs ys zs = ?

Concat_length &lt;a&gt; (xs: List a) (ys: List a) : Equal (Length (Concat xs ys)) (Plus (Length xs) (Length ys))
Concat_length xs ys = ?</code></pre>
<h4 id="more-polymorphic-exercises"><a class="header" href="#more-polymorphic-exercises">More Polymorphic Exercises</a></h4>
<p>Here are some slightly more interesting exercises...</p>
<pre><code class="language-rust ignore">Rev_app_distr &lt;a&gt; (xs: List a) (ys: List a) : Equal (Rev (Concat xs ys)) (Concat (Rev ys) (Rev xs))
Rev_app_distr xs ys = ?

Rev_involutive &lt;a&gt; (xs: List a) : Equal (Rev (Rev xs)) xs
Rev_involutive xs = ?</code></pre>
<h2 id="polymorphic-pairs"><a class="header" href="#polymorphic-pairs">Polymorphic Pairs</a></h2>
<p>Following the same pattern, the type definition for pairs of numbers that we gave in the last chapter can be generalized for polymorphic pairs:</p>
<pre><code class="language-rust ignore">record Pair (a) (b) {
  fst : a
  snd : b
} </code></pre>
<p>This is exactly the first definition of pairs that we saw in the previous chapter, and now we can understand perfectly what the <code>a</code> and <code>b</code> types are in the <strong>Pair</strong> type definition.</p>
<p>We can rewrite the <em>Pairs</em> functions, but now for polymorphic types:</p>
<pre><code class="language-rust ignore">Fst &lt;a&gt; &lt;b&gt; (pair: Pair a b) : a
Fst (Pair.new fst snd) = fst

Snd &lt;a&gt; &lt;b&gt; (pair: Pair a b) : b
Snd (Pair.new fst snd) = snd</code></pre>
<p>The following function takes two lists and combines them into a list of pairs. In functional languages, this is commonly called <strong>Zip</strong>.</p>
<pre><code class="language-rust ignore">Zip &lt;a&gt; &lt;b&gt; (xs: List a) (ys: List b) : (List (Pair a b))
Zip [] ys = []
Zip xs [] = []
Zip (List.cons xs.h xs.t) (List.cons ys.h ys.t) = List.cons (Pair.new xs.h xs.t) (Zip xs.t ys.t)</code></pre>
<h4 id="check"><a class="header" href="#check">Check</a></h4>
<p>Without running the program, try to answer the following question:</p>
<ul>
<li>What will the combination of <code>[1, 2]</code> and <code>[Bool.true, Bool.false, Bool.false, Bool.true]</code> return?</li>
</ul>
<p>Now run the code and see if you got it right.</p>
<h4 id="split"><a class="header" href="#split">Split</a></h4>
<p>The <strong>Split</strong> function is the inverse of <strong>Zip</strong>. It takes a list of pairs and returns a pair of lists. In many functional languages, it is called <strong>Unzip</strong>.</p>
<p>Fill in the definition of the splitting function below. Make sure it passes the unit test provided.</p>
<pre><code class="language-rust ignore">Split &lt;a&gt; &lt;b&gt; (xs: List (Pair a b)) : Pair (List a) (List b)
Split xs = ?

Test_split : Equal (Split [(Pair.new 1 Bool.false), (Pair.new 2 Bool.false)]) (Pair.new ([1, 2]) ([Bool.false, Bool.false]))
Test_split = ?</code></pre>
<h4 id="polymorphism-with-maybe"><a class="header" href="#polymorphism-with-maybe">Polymorphism with Maybe</a></h4>
<p>In the previous chapter, we also saw the Maybe type, but only for natural types. However, as we have seen in this chapter, our data structures can be polymorphic, which means that the Maybe type is also polymorphic, and that is what we will see now.</p>
<pre><code class="language-rust ignore">type Maybe (t) {
  none 
  some (value: t)
}</code></pre>
<p>This way, we can write the function of the nth error to be used with all types of lists:</p>
<pre><code class="language-rust ignore">Nth_error &lt;a&gt; (n: Nat) (xs: List a) : Maybe a
Nth_error a n List.nil              = Maybe.none
Nth_error a n (List.cons head tail) =
  let ind = Nth_error (Pred n) tail
  Bool.if (Eql n 0n) (Maybe.some head) (ind)


Test_nth_error1 : Equal (Nth_error 0n [4n,5n,5n,7n]) (Maybe.some 4n)
Test_nth_error1 = Equal.refl

Test_nth_error2 : Equal (Nth_error 2n [Bool.true]) Maybe.none
Test_nth_error2 = Equal.refl

Test_nth_error3 : Equal (Nth_error 1n [[1n],[2n]]) (Maybe.some [2n])
Test_nth_error3 = Equal.refl
</code></pre>
<h4 id="hd_error"><a class="header" href="#hd_error">Hd_error</a></h4>
<p>Complete the definition of a polymorphic version of the Hd_error function from the last chapter. Make sure it passes the unit tests below.</p>
<pre><code class="language-rust ignore">Hd_error &lt;a&gt; (xs: Lista a) : Maybe a
Hd_error xs = ?

Test_hd_error1 : Equal (Hd_error [1, 2]) (Maybe.some 1)
Test_hd_error1 = ?

Test_hd_error2 : Equal (Hd_error [[1], [2]]) (Maybe.some [1])
Test_hd_error2 = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="functions-as-data"><a class="header" href="#functions-as-data">Functions as data</a></h2>
<p>Functions as data
Like many other modern programming languages -- including all functional languages (ML, Haskell, Scheme, Scala, Clojure, etc.) -- Kind treats functions as first-class citizens, allowing them to be passed as arguments to other functions, returned as results, stored in data structures, etc.</p>
<h3 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher-Order Functions</a></h3>
<p>Functions that manipulate other functions are often called higher-order functions (or &quot;higher-order&quot; for short). Here is a simple example:</p>
<pre><code class="language-rust ignore">Doit3times &lt;x&gt; (f: x -&gt; x) (n: x) : x
Doit3times f x = (f (f (f x)))

Test_doit3times1 : Equal (Doit3times (x =&gt; MinusTwo x) 9n) 3n
Test_doit3times1 = Equal.refl

Test_doit3times2 : Equal (Doit3times (x =&gt; Notb x) Bool.true) (Bool.false)
Test_doit3times2 = Equal.refl</code></pre>
<h3 id="filter"><a class="header" href="#filter">Filter</a></h3>
<p>Here is a more useful higher-order function, taking a list of xs and a predicate on x (a function from x to Bool) and &quot;filtering&quot; the list, returning a new list containing only those elements for which the predicate returns Bool.true.</p>
<pre><code class="language-rust ignore">Filter &lt;x&gt; (test: x -&gt; Bool) (xs: List x) : List x
Filter test List.nil                      = []
Filter test (List.cons head tail)         =
   Bool.if (test head) (List.cons head (Filter test tail)) (Filter test tail)</code></pre>
<p>For example, if we apply the &quot;is even&quot; filter to a list of numbers, it will return another list with only the even numbers.</p>
<pre><code class="language-rust ignore">Test_filter1 : Equal (Filter (x =&gt; Evenb x) [1,2,3,4,5])  [2,4]  
Test_filter1 = Equal.refl

Length_is_one &lt;x&gt; (xs: List x) : Bool
Length_is_one xs               = Eql (Length xs) 1n

Test_filter2 : Equal (Filter (x =&gt; Length_is_one x) ([[1],[1,2],[3],[1,2,3],[21]])) ([[1],[3],[21]])
Test_filter2 = Equal.refl</code></pre>
<p>We can use filter to provide a concise version of the Countoddmembers function from the Lists chapter.</p>
<pre><code class="language-rust ignore">CountOddMembers (xs: List Nat) : Nat
CountOddMembers xs             = Length (Filter (x =&gt; Oddb x) xs)

Test_CountOddMembers1 : Equal (CountOddMembers  [1n,0n,3n,1n,4n,5n]) 4n
Test_CountOddMembers1 = Equal.refl

Test_CountOddMembers2 : Equal (CountOddMembers  [0n 2n,4n]) 0n
Test_CountOddMembers2 = Equal.refl

Test_CountOddMembers3 : Equal (CountOddMembers []) 0n
Test_CountOddMembers3 = Equal.refl</code></pre>
<h3 id="anonymous-functions"><a class="header" href="#anonymous-functions">Anonymous Functions</a></h3>
<p>It is arguably a bit sad, in the example above, to be forced to define the function <strong>Length_is_one</strong> and give it a name just to be able to pass it as an argument to filter, since we will probably never use it again.</p>
<p>Furthermore, this is not an isolated example: when using higher-order functions, we often want to pass &quot;unique&quot; functions as arguments that we will never use again; having to name each of these functions would be tedious.</p>
<p>Fortunately, there is a better way. We can build a function &quot;on the fly&quot; without declaring it at the top level or giving it a name.</p>
<pre><code class="language-rust ignore">Test_anon_fun : Equal (Doit3times (x =&gt; (Mult x x)) 2n) 256n
Test_anon_fun = Equal.refl</code></pre>
<p>The expression <code>x =&gt; (Mult x x)</code> can be read as &quot;the function takes a number <code>n</code> and returns <code>n * n</code>&quot;.</p>
<p>Here is the example of <strong>Filter</strong> rewritten to use an anonymous function:</p>
<pre><code class="language-rust ignore">Test_filter2 : Equal (Filter (x =&gt; (Length_is_one x)) [[1],[1,2],[2],[1,2,3],[21]]) [[1],[2],[21]]
Test_filter2 = Equal.refl
</code></pre>
<h4 id="filter_even_gt7"><a class="header" href="#filter_even_gt7">Filter_even_gt7</a></h4>
<p>Use Filter with anonymous functions (instead of function definitions) to write a function Filter_even_gt7 that takes a list of natural numbers as input and returns a list only of those that are even and greater than 7.</p>
<pre><code class="language-rust ignore">Filter_even_gt7 (xs: List Nat) : List Nat
Filter_even_gt7 xs = ?

Test_filter_even_gt7a: Equal (Filter_even_gt7 [1n,2n,3n,4n,5n,7n,8n,9n,10n,11n,12n]) [8n,10n,12n]
Test_filter_even_gt7a = ?

Test_filter_even_gt7b : Equal (Filter_even_gt7 [5n, 2n, 6n, 19n, 129n]) []
Test_filter_even_gt7b = ?</code></pre>
<p>A small observation, the attentive reader may have noticed that we used a new notation, the n after the numbers. This is a sugar syntax that Kind has. We can write natural numbers by simply adding an n to the number. However, this is a syntax that can end up weighing down Kind. Imagine that the user only wants to add the number <code>1</code> to <code>1000000</code>, it's a simple calculation that Kind can easily handle, but it becomes a bit heavier when using the sugar syntax for natural numbers. The sum will be <code>Plus 1n 1000000n</code>, but Kind will need to check each <code>Nat.succ</code> up to one million and one, in other words, one million and one &quot;<em>Nat.succ</em>&quot; will be computed unnecessarily. This syntax is very useful, but we should use it with care. Ideally, for large numbers, U60.to_nat should be used, which is much lighter for Kind.</p>
<h4 id="partition"><a class="header" href="#partition">Partition</a></h4>
<p>Use Filter to write a Partition function in Kind.</p>
<pre><code class="language-rust ignore">Partition &lt;x&gt; (test: x -&gt; Bool) (xs: List x) : Pair (List x) (List x)
Partition test xs = ?</code></pre>
<p>Given a set x, a test function of type <code>x -&gt; Bool</code>, and a List x, the Partition function should return a pair of lists. The first member of the pair is the sublist of the original list containing the elements that satisfy the test, and the second is the sublist containing those that fail the test. The order of the elements in the two sublists should be the same as the original list.</p>
<pre><code class="language-rust ignore">Test_partition1 : Equal (Partition (x =&gt; Oddb x) [1n,2n,3n,4n,5n]) (Pair.new [1n,3n,5n] [2n,4n])
Test_partition1 = ?

Test_partition2 : Equal (Partition (x =&gt; Bool.false) [5n, 9n, 0n]) (Pair.new [] [5n, 9n, 0n])
</code></pre>
<h3 id="map"><a class="header" href="#map">Map</a></h3>
<p>Another very useful higher-order function is Map.</p>
<pre><code class="language-rust ignore">Map &lt;x&gt; &lt;y&gt; (f: x -&gt; y) (xs: List x)  : List y
Map f List.nil                        = List.nil
Map f (List.cons head tail)           = List.cons (f head) (Map f tail)</code></pre>
<p>It takes a function <code>f</code> and a list <code>xs = [n1, n2, n3, ...]</code> and returns the list <code>[f n1, f n2, f n3, ...]</code>, where <code>f</code> is applied to each element of <code>xs</code>. For example:</p>
<pre><code class="language-rust ignore">Test_map1 : Equal (Map (x =&gt; Plus 3n x) [2n, 0n, 2n]) [5n, 3n, 5n]
Test_map1 = Equal.refl</code></pre>
<p>The types of the elements in the input and output list do not need to be the same, as Map accepts two type arguments, <code>x</code> and <code>y</code>; thus a function of numbers to booleans can be applied to produce a list of booleans:</p>
<pre><code class="language-rust ignore">
Test_map2 : Equal (Map (x =&gt; Nat.is_odd x) [2n, 1n, 2n, 5n]) [Bool.false, Bool.true, Bool.false, Bool.true]
Test_map2 = Equal.refl</code></pre>
<p>It can even be applied to a list of numbers and a function that returns a list of boolean lists:</p>
<pre><code class="language-rust ignore">Test_map3 = Equal (Map (x =&gt; [(Nat.is_even x), (Nat.is_odd x)]) [2n, 1n, 2n, 5n]) [[Bool.true, Bool.false], [Bool.false, Bool.true], [Bool.true, Bool.false], [Bool.false, Bool.true]]
Test_map3 = Equal.refl</code></pre>
<h4 id="map_rev"><a class="header" href="#map_rev">Map_rev</a></h4>
<p>Let's make things a little more difficult. Show the commutativity of Rev and Map; you may need an auxiliary function:</p>
<pre><code class="language-rust ignore">Map_rev &lt;x&gt; &lt;y&gt; (f: x -&gt; y) (xs: List x) : Equal (Map f (Rev xs)) (Rev (Map f xs))
Map_rev f xs = ?</code></pre>
<h4 id="flat_equal"><a class="header" href="#flat_equal">Flat_equal</a></h4>
<p>The Map function maps a <code>List x</code> to a <code>List y</code> using a function of type <code>x -&gt; y</code>. We can define a similar function, Flat_map, that maps a List x to a List y using a function f of type <code>x -&gt; List y</code>. Its definition should work by &quot;flattening&quot; the results of f, like so:</p>
<pre><code class="language-rust ignore">Flat_equal : Equal (Flat_map ( x =&gt; ([x , (Plus x 1n), (Plus x 2n)])) [1n, 5n, 10n]) [1n, 2n, 3n, 5n, 6n, 7n, 10n, 11n, 12n]
Flat_equal = Equal.refl

Flat_map &lt;x&gt; &lt;y&gt; (f: x -&gt; List y) (xs: List x) : List y
Flat_map f xs = ?

Test_flat_map1 : Equal (Flat_map (x =&gt; [x, x, x]) [1n, 5n, 4n]) [1n, 1n, 1n, 5n, 5n, 5n, 4n, 4n, 4n]
Test_flat_map1 = ?</code></pre>
<p>Lists are not the only inductive type for which we can write a Map function. Here's the definition of map for the Maybe type:</p>
<pre><code class="language-rust ignore">Maybe_map &lt;x&gt; &lt;y&gt; (f: x -&gt; y) (a: Maybe x)  : Maybe y
Maybe_map f Maybe.none                      = Maybe.none
Maybe_map f (Maybe.some x)                  = Maybe.some (f x)</code></pre>
<h3 id="fold"><a class="header" href="#fold">Fold</a></h3>
<p>An even more powerful higher-order function is called Fold. This function is the inspiration for the &quot;reduce&quot; operation that is at the heart of Google's map/reduce distributed programming framework.</p>
<pre><code class="language-rust ignore">Fold &lt;x&gt; &lt;y&gt; (f: x -&gt; y -&gt; y) (xs: List x) (a: y)   : y
Fold f List.nil a                                   = a
Fold f (List.cons head tail) a                      = f head (Fold f tail a)

Test_fold1 : Equal (Fold (x =&gt; y =&gt; (Bool.and x y)) [Bool.true, Bool.true, Bool.false] Bool.false) Bool.false
Test_fold1 = ?

Test_fold2 : Equal (Fold (x =&gt; y =&gt; (* x y)) [1, 2, 3, 4] 1) 24
Test_fold2 = ?

Test_fold3 : Equal (Fold (x =&gt; y =&gt; (Concat x y)) [[1], [], [2, 3], [], [4]] [5, 6, 7]) [1, 2, 3, 4, 5, 6, 7]
Test_fold3 = ?</code></pre>
<h4 id="fold_types_different"><a class="header" href="#fold_types_different">Fold_types_different</a></h4>
<p>Note that the type Fold is parameterized by two type variables, x and y, and the parameter f is a binary operator that takes an x and a y and returns a y. Can you think of a situation where it would be useful for x and y to be different?</p>
<h3 id="functions-that-build-functions"><a class="header" href="#functions-that-build-functions">Functions that build functions</a></h3>
<p>Most of the higher-order functions we've talked about so far use functions as arguments. Let's look at some examples that involve returning functions as results of other functions. To start, here's a function that takes a value x (extracted from some type x) and returns a Nat to x function that returns x every time it's called, ignoring its Nat argument.</p>
<pre><code class="language-rust ignore">Constfun &lt;y&gt; (x: y) : Nat -&gt; y
Constfun x = y =&gt; x</code></pre>
<pre><code class="language-rust ignore">Ftrue : Nat -&gt; Bool
Ftrue = Constfun Bool.true</code></pre>
<pre><code class="language-rust ignore">Constfun_example1 : Equal ((Ftrue) 0n) Bool.true
Constfun_example1 = Equal.refl</code></pre>
<pre><code class="language-rust ignore">Constfun_example2 : Equal ((Constfun 5n) 99n) 5n
Constfun_example2 = Equal.refl</code></pre>
<!-- Na verdade, as funções de múltiplos argumentos que já vimos também são exemplos de passagem de funções como dados. Para ver por que, lembre-se do tipo de adição -->
<!-- [>  <] -->
<!-- [> # TODO: <] -->
<!-- [>  <] -->
<!-- ```rust,ignore -->
<!-- Plus Nat -> Nat : Nat -->
<!-- ``` -->
<!-- [> Cada "->" nesta expressão é, na verdade, um operador binário em tipos. Este operador é associativo à direita, então o tipo de Plus é realmente uma abreviação para (Nat -> Nat) -> Nat – ou seja, pode ser lido como dizendo que “Plus é uma função de um argumento que pega um Nat e retorna uma função de um argumento que pega outro Nat e retorna um Nat.” Nos exemplos acima, sempre aplicamos mais a ambos os argumentos ao mesmo tempo, <] -->
<!-- [> mas se quisermos, podemos fornecer apenas o primeiro. Isso é chamado de aplicação parcial <] -->
<!-- [>  <] -->
<!-- [> # fim to todo <] -->
<!--  -->
<pre><code class="language-rust ignore">Plus3 : Nat -&gt; Nat
Plus3 = n =&gt; Plus 3n n</code></pre>
<pre><code class="language-rust ignore">Test_plus3_1 : Equal ((Plus3) 4n) 7n
Test_plus3_1 = Equal.refl</code></pre>
<pre><code class="language-rust ignore">Test_plus3_2 : Equal (Doit3times (Plus3) 0n) 9n
Test_plus3_2 = Equal.refl</code></pre>
<pre><code class="language-rust ignore">Test_plus3_3 : Equal (Doit3times (x =&gt; Plus 3n x) 0n) 9n
Test_plus3_3 = Equal.refl</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="exercícios-adicionais"><a class="header" href="#exercícios-adicionais">Exercícios adicionais</a></h2>
<p>Many common functions on lists can be implemented in terms of <strong>Fold</strong>. For example, here's an alternative definition of length:</p>
<pre><code class="language-rust ignore">Fold_length &lt;x&gt; (xs: List x) : Nat
Fold_length xs = Fold (x =&gt; y Nat.succ y) xs 0n</code></pre>
<pre><code class="language-rust ignore">Test_fold_length1 : Equal (Fold_length [4, 7, 0]) 3n
Test_fold_length1 = Equal.refl</code></pre>
<p>Prove the validity of <strong>Fold_length</strong>:</p>
<pre><code class="language-rust ignore">Fold_length_correct &lt;x&gt; (xs: List x) : Equal (Fold_length xs) (List.length xs)
Fold_length_correct xs = ?</code></pre>
<p>We can also define <strong>Map</strong> in terms of <strong>Fold</strong>. Complete the function:</p>
<pre><code class="language-rust ignore">Fold_map &lt;x&gt; &lt;y&gt; (f: x -&gt; y) (xs: List x) : List y
Fold_map f xs = ?</code></pre>
<p>Write a theorem <code>fold_map_correct</code> in Kind stating that <strong>Fold_map</strong> is correct and prove it:</p>
<pre><code class="language-rust ignore">Fold_map_correct : ?</code></pre>
<p>In Kind, a function <code>f: a -&gt; b -&gt; c</code> actually has type <code>a -&gt; (b -&gt; c)</code>. That is, if you give f a value of type <code>a</code>, it will provide the function <code>g: b -&gt; c</code>. If you give <code>g</code> a value of type <code>b</code>, it will return a value of type <code>c</code>. This allows for partial application, as in <code>Plus3</code>. Processing a list of arguments with functions that return functions is called currying, in honor of the logician Haskell Curry.</p>
<p>On the other hand, we can reinterpret the function <code>f: a -&gt; b -&gt; c</code> as <code>(Pair a b) -&gt; c</code>. This is called uncurrying. With a binary uncurry function, both arguments must be provided at the same time as a pair; there is no partial application.</p>
<p>We can define curry as follows:</p>
<pre><code class="language-rust ignore">Pair_curry &lt;x&gt; &lt;y&gt; &lt;z&gt; (f: (Pair x y) -&gt; z) (x_val: x) (y_val: y) : z 
Pair_curry f x_val y_val = ?</code></pre>
<p>As an exercise, define its inverse, <strong>Pair_uncurry</strong>. Then prove the theorems below to show that the two are inverses.</p>
<pre><code class="language-rust ignore">Pair_uncurry &lt;x&gt; &lt;y&gt; &lt;z&gt; (f: x -&gt; y -&gt; z) (p: Pair x y) : z
Pair_uncurry f p = ?</code></pre>
<p>As a (trivial) example of the usefulness of curry, we can use it to shorten one of the examples we saw above:</p>
<pre><code class="language-rust ignore">Test_map2 : Equal (Map (x =&gt; Plus 3n x) [2n,0n,2n]) [5n,3n,5n]
Test_map2 = Equal.refl</code></pre>
<p>Reflection exercise: before executing the following commands, can you calculate the types of <strong>Pair_curry</strong> and <strong>Pair_uncurry</strong>?</p>
<pre><code class="language-rust ignore">Uncurry_curry &lt;x&gt; &lt;y&gt; &lt;z&gt; (f: x -&gt; y -&gt; z) (x_val: x) (y_val: y) : 
   Equal z (Pair_curry (p =&gt; Pair_uncurry f p) x_val y_val) (f x_val y_val)
Uncurry_curry f x_val y_val = ?</code></pre>
<pre><code class="language-rust ignore">Curry_uncurry &lt;x&gt; &lt;y&gt; &lt;z&gt; (f:(Pair x y) -&gt; z) (p: Pair x y) : 
   Equal z (Pair_uncurry (x =&gt; y =&gt; Pair_curry f x y) p) (f p)
Curry_uncurry f p = ?</code></pre>
<p>Remember the definition of the function <strong>Nth_error</strong>(Nth_error_informal):</p>
<pre><code class="language-rust ignore">Nth_error_informal &lt;x&gt; (l: List x) (n: Nat) : Maybe x
Nth_error_informal List.nil n = Maybe.none 
Nth_error_informal (List.cons head tail) Nat.zero = Maybe.some head 
Nth_error_informal (List.cons head tail) (Nat.succ n) = Nth_error tail n</code></pre>
<p>Write an informal proof of the following theorem:</p>
<pre><code class="language-rust ignore">Nat -&gt; List -&gt; (Equal (Length List) Nat) : Equal (Nth_error_informal List Nat) Maybe.none</code></pre>
<p>We can explore an alternative way of defining natural numbers, using <em>Church numerals</em>, named after the mathematician Alonzo Church. We can represent a natural number n as a function that takes a function <code>s</code> as a parameter and returns <code>s</code> iterated n times.</p>
<pre><code class="language-rust ignore">Num &lt;x&gt; : Type
Num x = (x -&gt; x) -&gt; x -&gt; x</code></pre>
<p>Let's see how to write some numbers with this notation. Iterating a function once should be the same as just applying it. In this way:</p>
<pre><code class="language-rust ignore">One : Num
One = s =&gt; z =&gt; s z 
</code></pre>
<p>Note that the function applies an <code>s</code> to a <code>z</code>, if we read the <code>s</code> as <em>successor</em> and the <code>z</code> as <em>zero</em>, we have that <em>One</em> is equal to the <em>successor of zero</em>.</p>
<p>Similarly, <strong>Two</strong> applies the function <code>s</code> twice to <code>z</code>:</p>
<pre><code class="language-rust ignore">Two : Num
Two = s =&gt; z =&gt; s (s z)</code></pre>
<p>Defining zero is a bit more complicated: how can we &quot;apply a function zero times&quot;? The answer is actually simple: just return the argument untouched.</p>
<pre><code class="language-rust ignore">Zero : Num
Zero = s =&gt; z =&gt; z</code></pre>
<p>More generally, a number n can be written as <code>s =&gt; z =&gt; s (s ... (s z) ...)</code>, with n occurrences of <code>s</code>. Note in particular how the function doit3times that we defined earlier is actually just the Church representation of 3.</p>
<pre><code class="language-rust ignore">Three : Num
Three = s =&gt; z =&gt; Doit3times s z</code></pre>
<p>Complete the definitions of the following functions. Make sure the corresponding unit tests pass, proving them with <strong>Equal.refl</strong>.</p>
<h4 id="successor"><a class="header" href="#successor">Successor</a></h4>
<p>Successor of a natural number:</p>
<pre><code class="language-rust ignore">Succ (n: Num) : Num
Succ n = ?

Succ_1 : Equal (Succ Zero) (One)
Succ_1 = ?

Succ_2 : Equal (Succ One) (Two)
Succ_2 = ?

Succ_3 : Equal (Succ Two) (Three)
Succ_3 = ?</code></pre>
<h4 id="addition"><a class="header" href="#addition">Addition</a></h4>
<p>Addition of two natural numbers:</p>
<pre><code class="language-rust ignore">Plus (n: Num) (n: Num) : Num
Plus n m = ?

Plus_1 : Equal (Plus One Zero) (One)
Plus_1 = ?

Plus_2 : Equal (Plus Two One) (Plus One Two)
Plus_2 = ?

Plus_3 : Equal (Plus (Plus Two Two) Three) (Plus One (Plus Three Three))
Plus_3 = ?</code></pre>
<h4 id="multiplication"><a class="header" href="#multiplication">Multiplication</a></h4>
<pre><code class="language-rust ignore">Mult (n: Num) (m: Num) : Num
Mult n m = ?

Mult_1 : Equal (Mult One One) One
Mult_1 = ?

Mult_2 : Equal (Mult Zero (Plus Three Three)) Zero
Mult_2 = ?

Mult_3 : Equal (Mult Two Three) (Plus Three Three)
Mult_3 = ?</code></pre>
<h4 id="exponentiation"><a class="header" href="#exponentiation">Exponentiation</a></h4>
<p>It is not possible to make it work with <code>Exp (n: Num) (m: Num) : Num</code>. Polymorphism plays a crucial role here. However, choosing the right type to iterate over can be tricky. If you encounter an &quot;inconsistency&quot; error, try iterating over a different type: Num itself is usually problematic.</p>
<pre><code class="language-rust ignore">Exp (n: Num) (m: Num -&gt; Num) : Num
Exp n m = ?

Exp_1 : Equal (Exp Two Two) (Plus Two Two)
Exp_1 = ?

Exp_2 : Equal (Exp Three Two) (Plus (Mult Two (Mult Two Two)) One)
Exp_2 = ?

Exp_3 : Equal (Exp Three Zero) One
Exp_3 = ?</code></pre>
<h4 id="predecessor"><a class="header" href="#predecessor">Predecessor</a></h4>
<pre><code class="language-rust ignore">Pred (n: Num -&gt; Num) : Num
Pred n = ?

Pred_1 : Equal (Pred Zero) (Zero)
Pred_1 = ?

Pred_2 : Equal (Pred Two) (One)
Pred_2 = ?

Pred_3 : Equal (Pred Three) (Two)
Pred_3 = ?</code></pre>
<h4 id="subtraction"><a class="header" href="#subtraction">Subtraction</a></h4>
<pre><code class="language-rust ignore">Sub (n: Num) (m: Num) : Num
Sub n m = ?

Sub_1 : Equal (Sub One Zero) (One)
Sub_1 = ?

Sub_2 : Equal (Sub Two Two) (Sub One One)
Sub_2 = ?

Sub_3 : Equal (Sub Three One) Two
Sub_3 = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lógica-em-kind"><a class="header" href="#lógica-em-kind">Lógica em Kind</a></h1>
<p>Nos capítulos anteriores, vimos muitos exemplos de afirmações factuais (proposições) e formas de apresentar evidências de sua veracidade (provas). Em particular, trabalhamos extensivamente com proposições de igualdade da forma <em>e1 = e2</em>, com implicações <em>(p -&gt; q)</em>, e com proposições quantificadas <em>(x -&gt; P(x))</em>. Neste capítulo, veremos como Kind pode ser usado para realizar outras formas familiares de raciocínio lógico.</p>
<p>Antes de mergulhar nos detalhes, vamos falar um pouco sobre o status das declarações matemáticas em Kind. Lembre-se de que Kind é uma linguagem tipada, o que significa que toda expressão sensível em seu mundo tem um tipo associado. As afirmações lógicas não são exceção: qualquer afirmação que possamos tentar provar em Kind tem um tipo, ou seja, Type, o tipo de proposições. Podemos ver isso com o tipo <em>Booleano</em>:</p>
<pre><code class="language-rust ignore">Bool: Type
Bool.true  : Bool
Bool.false : Bool</code></pre>
<p>No tipo <em>Bool</em> nós temos o Bool.<strong>true</strong> e o Bool.<strong>false</strong>. Para criar o
tipo Bool nós declaramos que ele é um tipo (Type) e depois que o
Bool.<strong>true</strong> e o Bool.<strong>false</strong> são do tipo Bool. Vendo como é, fica bem
mais simples. Muitas vezes nos assombramos ao ver o nome &quot;funcional&quot;, mas
Kind é uma linguagem muito amigável, veremos bem sobre isso mais para a
frente.</p>
<p>Outro exemplo possível é o <em>Nat</em>, dos números naturais. Números
naturais são todos os números inteiros maiores ou igual a zero. Ou seja, eles começam com o número zero e vão até o infinito, mas não possuem valores decimais. Ou seja, o <strong>3</strong> é um número natural, mas o <strong>3,14</strong> não é, da mesma forma que o <strong>-3</strong> também não é. Então sabemos que o número natural é feito de <em>zero</em> e dos <em>sucessores</em> dele. Vamos ver como isso é no kind:</p>
<pre><code class="language-rust ignore">Nat: Type
Nat.zero             : Nat
Nat.succ (pred: Nat) : Nat</code></pre>
<p>Percebemos que a construção é similar aos <em>Booleanos</em>, mas há um
elemento extra no Nat.<strong>succ</strong>, que é o &quot;(pred: Nat)&quot;, e isso se deve ao
fato de que, enquanto no outro nós tínhamos apenas duas opções de retorno
(<em>True</em> ou <em>False</em>), agora temos uma infinidade de números que o código
precisa compreender, além de que deve haver uma forma do código parar de rodar
(veremos mais sobre isso ao decorrer desse estudo), uma vez que um código que
nunca para de rodar é um código que nunca nos dará o resultado.</p>
<p>Porém, de qualquer forma, percebemos que a estrutura do <strong>Nat</strong> é basicamente
a mesma do <strong>Bool</strong>, isso nos mostra que podemos criar qualquer tipo,
desde que sigamos a mesma estrutura. Vamos criar o tipo suco:</p>
<pre><code class="language-rust ignore">Suco : Type
Suco.laranja : Suco
Suco.caju    : Suco</code></pre>
<p>O suco de laranja possui dois construtores, o Suco.<strong>laranja</strong> e o
Suco.<strong>caju</strong>. Esse tipo é fictício, ele não existia até então, mas agora
podemos usar ele como um tipo e isso nos mostra que, graças ao design do Kind,
podemos criar uma infinidade de tipos, pois todo tipo é uma função.</p>
<p>Entender a construção dos <em>tipos</em> impedirá que alguns erros de sintaxe ocorram.</p>
<p>Apenas revisando, nosso elemento <em>Suco</em> é do tipo <em>Type</em> e o Suco.<strong>laranja</strong> é do tipo <em>Suco</em>. Desta forma, em termos leigos, temos que o elemento fica a direita dos dois pontos e o tipo a esquerda</p>
<p><code>elemento : Tipo</code></p>
<p>Como dito antes, até mesmo os tipos são funções, logo podemos ter uma função
como tipo. Por exemplo:</p>
<pre><code class="language-rust ignore">Problema : (Equal Bool Bool.true Bool.true</code></pre>
<p>Podemos perceber que temos um elemento chamado &quot;Problema&quot; e ele é do
tipo &quot;(Equal Bool Bool.true Bool.true)&quot;. Nós já vimos essa estrutura diversas vezes nos últimos capítulos e agora é fácil entender que essa função é um tipo e, da mesma forma que <strong>não escrevemos</strong></p>
<pre><code class="language-rust ignore">Suco: Type
Suco.laranja : Type</code></pre>
<p><strong>Não podemos</strong> simplesmente copiar a função para os construtores desse tipo.
O <em>Suco</em> é tipo <em>Type</em>, mas o <em>Suco</em>.<strong>laranja</strong> não é do tipo <em>Type</em>, ele é
do tipo <em>Suco</em>.</p>
<p>Mas atenção, observe que todas as proposições sintaticamente bem formadas têm o tipo Type em Kind, independentemente de serem verdadeiras ou não. Simplesmente ser uma proposição é uma coisa; ser demonstrável é outra coisa!</p>
<p>De fato, as proposições não têm apenas tipos: elas são objetos de primeira classe que podem ser manipulados da mesma forma que as outras entidades no mundo de Kind. Até agora, vimos um local primário onde as proposições podem aparecer: nas assinaturas de tipo das funções.</p>
<pre><code class="language-rust ignore">Plus_2_2_is_4 : Equal (Plus 2n 2n) 4n
Plus_2_2_is_4 = Equal.refl</code></pre>
<p>Mas as proposições podem ser usadas de muitas outras maneiras. Por exemplo, podemos dar um nome a uma proposição como um valor próprio, assim como demos nomes a expressões de outros tipos.</p>
<pre><code class="language-rust ignore">Plus_fact : Type
Plus_fact = Equal (Plus 2n 2n) 4n</code></pre>
<p>Posteriormente, podemos usar esse nome em qualquer situação em que uma proposição seja esperada – por exemplo, em uma declaração de função.</p>
<pre><code class="language-rust ignore">Plus_fact_is_true : Plus_fact
Plus_fact_is_true = Equal.refl</code></pre>
<p>Também podemos escrever proposições parametrizadas – isto é, funções que recebem argumentos de algum tipo e retornam uma proposição. Por exemplo, a seguinte função pega um número e retorna uma proposição afirmando que esse número é igual a três:</p>
<pre><code class="language-rust ignore">Is_three (n: Nat) : Type
Is_three n = Equal Nat n 3n</code></pre>
<p>Em Kind, diz-se que funções que retornam proposições definem propriedades de seus argumentos.
Por exemplo, aqui está uma propriedade (polimórfica) que define a noção familiar de uma função injetiva</p>
<pre><code class="language-rust ignore">Injective &lt;a&gt; &lt;b&gt; (f: a -&gt; b) : Type
Injective a b f = (x: a) -&gt; (y: a) -&gt; (e: Equal b (f x) (f y)) -&gt; (Equal a x y)</code></pre>
<p>Nós podemos instanciar uma regra de injetividade com</p>
<pre><code class="language-rust ignore">Nat.succ_injective : Injective ((x: Nat) =&gt; Nat.succ x)
Nat.succ_injective =
  (a: Nat) =&gt;
  (b: Nat) =&gt;
  (e: Equal Nat (Nat.succ a) (Nat.succ b)) =&gt;
  Equal.apply (x =&gt; Nat.pred x) e</code></pre>
<!-- e criar tipos que precisam de injetividade com

```rust,ignore
type Injective <a: Type> <b: Type> (f: a -> b) {
  new (p: Nat.succ_injective f)
}

InjectiveNat : Injective (n => Nat.succ n)
InjectiveNat = Injective.new Nat.succ_injective
``` -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="conectivos-lógicos"><a class="header" href="#conectivos-lógicos">Conectivos Lógicos</a></h2>
<h3 id="conjunção"><a class="header" href="#conjunção">Conjunção</a></h3>
<p>A conjunção (ou lógico <em>e</em>) em kind recebe duas proposições <em>a</em> e <em>b</em>, que devem retornar um valor <em>booleano</em> <code>true</code> ou <code>false</code>.</p>
<pre><code class="language-rust ignore">Bool.and (a: Bool) (b: Bool) : Bool
Bool.and Bool.true  b = b
Bool.and Bool.false b = Bool.false</code></pre>
<p>Se <em>a</em> é verdadeiro, basta apenas retornar o valor de <em>b</em>, agora se o <em>a</em> for falso, não há a necessidade de verificar o valor do segundo elemento.</p>
<p>Por se tratar de um caso limitado (há apenas duas opções) dá para verificar com uma prova simples:</p>
<pre><code class="language-rust ignore">ConjuntiveBool : Equal Bool (Bool.and Bool.true Bool.false) Bool.false
ConjuntiveBool = Equal.refl</code></pre>
<h4 id="and_exercise"><a class="header" href="#and_exercise">And_exercise</a></h4>
<pre><code class="language-rust ignore">And_exercise : Pair (Equal (Plus 3n 4n) 7n) (Equal (Mult 2n 2n) 4n)
And_exercise = ?</code></pre>
<p>Tanto para provar declarações conjuntivas. Para ir na outra direção – ou seja, usar uma hipótese conjuntiva para ajudar a provar outra coisa – empregamos o pattern matching.
Se o contexto de prova contiver uma hipótese h da forma (a,b), a divisão de caso irá substituí-la por um padrão de pares (a,b).</p>
<pre><code class="language-rust ignore">And_example2 (n: Nat) (m: Nat) (e: Pair (Equal n 0n) (Equal m 0n)) : Equal (Plus n m ) 0n
And_example2 Nat.zero Nat.zero e        = Equal.refl
And_example2 Nat.zero (Nat.succ m ) e   = 
    let p = (Equal.rewrite
    (Pair.snd e)
    (x =&gt; match Nat x {
        zero =&gt; Empty
        succ =&gt; Unit
    })
    (Unit.new))
    Empty.absurd p
And_example2 (Nat.succ n) m e           =
    let p = (Equal.rewrite
    (Pair.fst e)
    (x =&gt; match Nat x {
        zero =&gt; Empty
        succ =&gt; Unit 
    })
    (Unit.new))
    Empty.absurd p</code></pre>
<p>Você pode se perguntar por que nos preocupamos em agrupar as duas hipóteses n = 0 e m = 0 em uma única conjunção, já que também poderíamos ter declarado o teorema com duas premissas separadas:</p>
<pre><code class="language-rust ignore">And_example2a (n: Nat) (m: Nat) (e1: Equal n 0n) (e2: Equal m 0n) : Equal (Plus n m) 0n
And_example2a Nat.zero Nat.zero e1 e2        = Equal.refl
And_example2a Nat.zero (Nat.succ m ) e1 e2   = 
    let p = (Equal.rewrite
    (e2)
    (x =&gt; match Nat x {
        zero =&gt; Empty
        succ =&gt; Unit
    })
    (Unit.new))
    Empty.absurd p
And_example2a (Nat.succ n) m e1 e2           =
    let p = (Equal.rewrite
    (e1)
    (x =&gt; match Nat x {
        zero =&gt; Empty
        succ =&gt; Unit 
    })
    (Unit.new))
    Empty.absurd p
</code></pre>
<p>Para este teorema, ambas as formulações são adequadas. Mas é importante entender como trabalhar com hipóteses conjuntivas porque as conjunções geralmente surgem de etapas intermediárias em provas, especialmente em desenvolvimentos maiores. Aqui está um exemplo simples:</p>
<pre><code class="language-rust ignore">And_example3 (n: Nat) (m: Nat) (e: Equal (Plus n m) 0n) : Equal (Mult n m) 0n
And_example3 Nat.zero m e =  Equal.refl
And_example3 (Nat.succ n) m e =
    let p = (Equal.rewrite 
        (e)
        (x =&gt; match Nat x {
            zero =&gt; Empty 
            succ =&gt; Unit                      
        })
        (Unit.new))
    Empty.absurd p</code></pre>
<p>Outra situação comum com conjunções é que sabemos (a,b), mas em algum contexto precisamos apenas de a (ou apenas b). Os seguintes teoremas são úteis em tais casos:</p>
<pre><code class="language-rust ignore">Proj1 &lt;p&gt; &lt;q&gt; (a: Pair p q) : p
Proj1 (Pair.new fst snd)    = fst</code></pre>
<h4 id="proj2"><a class="header" href="#proj2">Proj2</a></h4>
<pre><code class="language-rust ignore">Proj2 &lt;p&gt; &lt;q&gt; (b: Pair p q) : q
Proj2 (Pair.new fst snd)    = ?</code></pre>
<p>Por fim, às vezes precisamos reorganizar a ordem das conjunções e/ou agrupar as conjunções de múltiplas vias. Os seguintes teoremas de comutatividade e associatividade são úteis em tais casos.</p>
<pre><code class="language-rust ignore">And_commut &lt;p&gt; &lt;q&gt; (c: Pair p q) : Pair q p
And_commut (Pair.new fst snd)    = Pair.new snd fst</code></pre>
<h4 id="and_assoc"><a class="header" href="#and_assoc">And_assoc</a></h4>
<pre><code class="language-rust ignore">And_assoc &lt;p&gt; &lt;q&gt; &lt;r&gt; (a: Pair p (Pair q r))  : Pair (Pair p q) r
And_assoc (Pair.new p (Pair q r) fst (Pair.new snd trd)) = ?</code></pre>
<h3 id="disjunção"><a class="header" href="#disjunção">Disjunção</a></h3>
<p>Outro conectivo importante é a disjunção, ou lógico, de duas proposições:
<code>Either</code> a b é verdadeiro quando a ou b é. O primeiro caso foi marcado com <em>left</em> e o segundo com <em>right</em>.
Para usar uma hipótese disjuntiva em uma prova, procedemos pela análise de caso, que, como para Nat ou outros tipos de dados, pode ser feita com correspondência de padrões. Aqui está um exemplo:</p>
<pre><code class="language-rust ignore">Or_example (n: Nat) (m: Nat) (e: (Either (Equal n 0n) (Equal m 0n))) : Equal (Mult n m) 0n
Or_example Nat.zero m e     = Equal.refl
Or_example n Nat.zero e     = Mult_0_r n
Or_example (Nat.succ n) m (Either.left l r val) = 
    let p = (Equal.rewrite
        (val)
        ( x =&gt; match Nat x {
            zero =&gt; Empty 
            succ =&gt; Unit            
        })
        (Unit.new))
    Empty.absurd p
Or_example (Nat.succ n) (Nat.succ m) (Either.right l r val) = 
    let p = (Equal.rewrite 
        (val)
        ( x =&gt; match Nat x {
            zero =&gt; Empty
            succ =&gt; Unit                   
        })
        (Unit.new))
Empty.absurd p</code></pre>
<p>Inversamente, para mostrar que uma disjunção é válida, precisamos mostrar que um de seus lados é válido. Isso pode ser feito por meio dos construtores Left e Right mencionados acima. Aqui está um uso trivial...</p>
<pre><code class="language-rust ignore"><span class="boring">axiom
</span>Or_intro_left &lt;a&gt; &lt;b&gt; (t: a) : Either a b
Or_intro_left t = Either.left t

<span class="boring">axiom
</span>Or_intro_right &lt;a&gt; &lt;b&gt; (t: b) : Either a b
Or_intro_right t = Either.right t</code></pre>
<p>... e um exemplo um pouco mais interessante exigindo ambos</p>
<pre><code class="language-rust ignore">Zero_or_succ (n: Nat)     : Either (Equal n 0n) (Equal n (Nat.succ (Nat.pred n)))
Zero_or_succ Nat.zero     = Either.left  Equal.refl
Zero_or_succ (Nat.succ n) = Either.right Equal.refl</code></pre>
<h4 id="mult_eq_0"><a class="header" href="#mult_eq_0">Mult_eq_0</a></h4>
<pre><code class="language-rust ignore"><span class="boring">axiom
</span>Mult_eq_0 (n: Nat) (m: Nat) (e: Equal (Mult n m) 0n) : Either (Equal n 0n) (Equal m 0n)
Mult_eq_0 n m e = ?</code></pre>
<h4 id="or_commut"><a class="header" href="#or_commut">Or_commut</a></h4>
<pre><code class="language-rust ignore">Or_commut &lt;p&gt; &lt;q&gt; (e: Either p q) : Either q p
Or_commut e: ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="falsidade-e-negação"><a class="header" href="#falsidade-e-negação">Falsidade e Negação</a></h2>
<p>Até agora, nos preocupamos principalmente em provar que certas coisas são verdadeiras – adição é comutativa, anexação de listas é associativa, etc. Claro, também podemos estar interessados em resultados negativos, mostrando que certas proposições não são verdadeiras. Em Kind, tais declarações negativas são expressas com a função de nível de tipo de negação <em>Not</em>.</p>
<p>Para ver como a negação funciona, relembre a discussão do princípio da explosão do capítulo anterior; ela afirma que, se assumirmos uma contradição, então qualquer outra proposição pode ser derivada. Seguindo essa intuição, poderíamos definir <code>Not p</code> como <code>q -&gt; (p -&gt; q)</code>. Kind realmente faz uma escolha ligeiramente diferente, definindo <em>Not</em> como <em>p -&gt; Empty</em>, onde <em>Empty</em> é uma proposição contraditória específica definida na biblioteca padrão como um tipo de dados sem construtores.</p>
<pre><code class="language-rust ignore">Empty: Type

Not &lt;p: Type&gt;: Type
Not p = p -&gt; Empty</code></pre>
<p>Como <em>Empty</em> é uma proposição contraditória, o princípio da explosão também se aplica a ela. Se obtivermos <em>Empty</em> no contexto de prova, podemos chamá-lo de <em>Empty</em> ou absurd para completar qualquer objetivo:</p>
<pre><code class="language-rust ignore">Ex_falso_quodlibet &lt;p&gt; : Empty -&gt; p
Ex_falso_quodlibet p   = e =&gt; Empty.absurd e</code></pre>
<p>O <em>latim ex falso quodlibet</em> significa, literalmente, “da falsidade segue o que você quiser”; este é outro nome comum para o princípio da explosão.</p>
<h4 id="not_implies_our_not"><a class="header" href="#not_implies_our_not">Not_implies_our_not</a></h4>
<p>Mostre que a definição da negação em Kind implica a intuitiva mencionada acima:</p>
<pre><code class="language-rust ignore">Not_implies_our_not &lt;p&gt; &lt;q&gt; (e: Not p) : q -&gt; (p -&gt; q)
Not_implies_our_not p q e = ?</code></pre>
<p>É assim que usamos Not para afirmar que 0 e 1 são elementos diferentes de Nat:</p>
<pre><code class="language-rust ignore">Zero_not_one : Not (Equal Nat.zero (Nat.succ Nat.zero))
Zero_not_one = 
  (emp =&gt; 
    let app = Equal.apply (x =&gt; Nat.is_zero x) emp
    Equal.rewrite app (e =&gt; if e {Nat} else {Empty}) Nat.zero)</code></pre>
<p>É preciso um pouco de prática para se acostumar a trabalhar com a negação em Kind. Mesmo que você possa ver perfeitamente por que uma afirmação envolvendo negação é verdadeira, pode ser um pouco complicado no começo colocar as coisas na configuração certa para que Kind possa entender! Aqui estão as provas de alguns fatos familiares para você se aquecer:</p>
<pre><code class="language-rust ignore">Not_false : Not Empty
Not_false = e =&gt; Empty.absurd e

Contradiction_implies_anythig &lt;p&gt; &lt;q&gt; (a: Pair p (Not p)) : q
Contradiction_implies_anythig p q (Pair.new fst snd) =
  let app = snd fst
  Empty.absurd app
</code></pre>
<h4 id="double_neg_inf"><a class="header" href="#double_neg_inf">Double_neg_inf</a></h4>
<p>Escreva uma prova informal de Double_neg:
Teorema: Se p, então (não (não p)), para qualquer proposição p.</p>
<h4 id="contrapositive"><a class="header" href="#contrapositive">Contrapositive</a></h4>
<pre><code class="language-rust ignore">Contrapositive &lt;p&gt; &lt;q&gt; (f: p -&gt; q) : (Not q -&gt; Not p)
Contrapositive p q f = ?</code></pre>
<h4 id="not_both_true_and_false"><a class="header" href="#not_both_true_and_false">Not_both_true_and_false</a></h4>
<pre><code class="language-rust ignore">Not_both_true_and_false &lt;p&gt; : Not (Pair p (Not p))
Not_both_true_and_false p = ?</code></pre>
<p>Da mesma forma, já que a desigualdade envolve uma negação, é preciso um pouco de prática para trabalhar com ela de forma fluente. Aqui está um truque útil. Se você estiver tentando provar uma meta que é absurda (por exemplo, o estado final é Bool.false == Bool.true), aplique Empty.absurd para mudar a meta para Empty. Isso facilita o uso de pressupostos do tipo (Not p) que podem estar disponíveis no contexto - em particular, pressupostos do tipo Not (x == y).</p>
<pre><code class="language-rust ignore">Not_true_is_false (b: Bool) (e: Not (Equal Bool b Bool.true)) : Equal Bool b Bool.false
Not_true_is_false Bool.false e = Equal.refl
Not_true_is_false Bool.true e = Empty.absurd (e Equal.refl)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="verdade"><a class="header" href="#verdade">Verdade</a></h2>
<p>Além de Empty, a biblioteca padrão do Kind também define Unit, uma proposição que é trivialmente verdadeira. Para provar isso, usamos a constante:</p>
<pre><code class="language-rust ignore">True_is_true : Unit
True_is_true = Unit.new</code></pre>
<p>Ao contrário de Empty, que é amplamente utilizado, Unit é usado bastante raramente em provas, já que é trivial (e, portanto, pouco interessante) provar como objetivo e não carrega nenhuma informação útil como hipótese. No entanto, pode ser bastante útil ao definir provas complexas usando condicionais ou como um parâmetro para provas de ordem superior. Veremos exemplos desse uso de Unit mais tarde.</p>
<h2 id="equivalência"><a class="header" href="#equivalência">Equivalência</a></h2>
<p>Equivalência Lógica. A útil conectiva &quot;se e somente se&quot;, que afirma que duas proposições têm o mesmo valor de verdade, é apenas a conjunção de duas implicações.</p>
<pre><code class="language-rust ignore">record Equivalence (p: Type) (q: Type) {
 lft: p -&gt; q 
 rgt: q -&gt; p
}</code></pre>
<pre><code class="language-rust ignore">//#axiom
Equivalence.lft &lt;p&gt; &lt;q&gt; (e: Equivalence p q) : p 
Equivalence.lft (Equivalence.new l r)        = r (Equivalence.rgt (Equivalence.new l r))

//#axiom
Equivalence.rgt &lt;p&gt; &lt;q&gt; (e: Equivalence p q) : q 
Equivalence.rgt (Equivalence.new l r)        = l (Equivalence.lft (Equivalence.new l r))</code></pre>
<pre><code class="language-rust ignore">Not_true_iff_false (b: Bool) : Equivalence (Not (Equal Bool b Bool.true)) (Equal Bool b Bool.false)
Not_true_iff_false  b = Equivalence.new (x =&gt; Not_true_is_false b x) (y =&gt; Not_true_and_false b y)</code></pre>
<pre><code class="language-rust ignore">Not_true_and_false (b : Bool) (e: Equal Bool b Bool.false) : Not (Equal Bool b Bool.true)
Not_true_and_false Bool.false Equal.refl = 
 emp =&gt; 
 let p = Equal.rewrite emp
   (x =&gt; match Bool x {
    true =&gt; Empty
    false =&gt; Unit
    }) 
    (Unit.new)
 Empty.absurd p
Not_true_and_false Bool.true e = 
 let p = Equal.rewrite e 
  (x =&gt; if x 
  {Unit} 
  else 
  {Empty}) 
 (Unit.new)
 Empty.absurd p</code></pre>
<h3 id="simétrica"><a class="header" href="#simétrica">Simétrica</a></h3>
<p>Uma relação é simétrica se, para todos os elementos p e q em seu domínio, se p é equivalente a q, então q é equivalente a p. Isso pode ser provado com a seguinte regra:</p>
<pre><code class="language-rust ignore">Equivalence.mirror &lt;p&gt; &lt;q&gt; (e: Equivalence p q) : Equivalence q p
Equivalence.mirror p q (Equivalence.new lft rgt) = (Equivalence.new rgt lft)</code></pre>
<h3 id="reflexividade"><a class="header" href="#reflexividade">Reflexividade</a></h3>
<p>Uma relação é reflexiva se, para todo elemento p em seu domínio, p é equivalente a si mesmo. Isso pode ser provado com a seguinte regra:</p>
<pre><code class="language-rust ignore">Equivalence.refl &lt;p&gt; : Equivalence p p
Equivalence.refl p = ?</code></pre>
<h3 id="transitividade"><a class="header" href="#transitividade">Transitividade</a></h3>
<p>Uma relação é transitiva se, para todos os elementos p, q, e r em seu domínio, se p é equivalente a q e q é equivalente a r, então p é equivalente a r. Isso pode ser provado com a seguinte regra:</p>
<pre><code class="language-rust ignore">Equivalence.chain &lt;p&gt; &lt;q&gt; &lt;r&gt; (e0: Equivalence p q) (e1: Equivalence q r) : Equivalence p r
Equivalence.chain p q r e0 e1 = ?</code></pre>
<h4 id="or_distributes_over_and"><a class="header" href="#or_distributes_over_and">Or_distributes_over_and</a></h4>
<pre><code class="language-rust ignore">Or_distributes_over_and &lt;p&gt; &lt;q&gt; &lt;r&gt; : Equivalence (Either p (Pair q r)) (Pair (Either p q) (Either p r))
Or_distributes_over_and p q r = ?</code></pre>
<p>Equivalência de forma especial, evitando a necessidade de alguma manipulação de estado de prova de baixo nível. Em particular, rewrite e reflexividade podem ser usados com afirmações iff, não apenas igualdades.
Aqui está um exemplo simples demonstrando como essas táticas funcionam com iff. Primeiro, vamos provar algumas equivalências básicas de iff</p>
<pre><code class="language-rust ignore">Mult_0 (n: Nat) (m: Nat) : Equivalence (Equal Nat (Mult n m) 0n) (Either (Equal Nat n 0n) (Equal Nat m 0n))
Mult_0 n m = Equivalence.new (x =&gt; To_mult_0 n m x) (y =&gt; Or_example n m y)

To_mult_0 (n: Nat) (m: Nat) (e: Equal Nat (Mult n m) 0n) : (Either (Equal Nat n 0n) (Equal Nat m 0n))
To_mult_0 Nat.zero Nat.zero Equal.refl = Either.right Equal.refl
To_mult_0 Nat.zero (Nat.succ m) Equal.refl = Either.left Equal.refl
To_mult_0 (Nat.succ n) Nat.zero e = Either.right Equal.refl
To_mult_0 (Nat.succ n) (Nat.succ m) e = 
  let a = Plus_comm (Mult n (Nat.succ m)) (Nat.succ m)
  let b = Equal.chain (Equal.mirror e) a
  let c = (Equal.rewrite b
   (x =&gt; match Nat x {
    zero =&gt; Unit
    succ =&gt; Empty
    })
    (Unit.new)) 
  Empty.absurd c</code></pre>
<pre><code class="language-rust ignore">Or_assoc &lt;p&gt; &lt;q&gt; &lt;r&gt; : Equivalence (Either p (Either q r)) (Either (Either p q) r)
Or_assoc = Equivalence.new (x =&gt; To_or_assoc x) (y =&gt; Fro_or_assoc y)

To_or_assoc &lt;p&gt; &lt;q&gt; &lt;r&gt; (e: Either p (Either q r)) : Either (Either p q) r
To_or_assoc (Either.left e) = Either.left (Either.left e)
To_or_assoc (Either.right p (Either q r) (Either.left e)) = Either.left (Either.right e)
To_or_assoc (Either.right p (Either q r) (Either.right e)) = Either.right e

Fro_or_assoc &lt;p&gt; &lt;q&gt; &lt;r&gt; (e: Either (Either p q) r) : Either p (Either q r)
Fro_or_assoc (Either.left (Either p q) r (Either.left e)) = Either.left e
Fro_or_assoc (Either.left (Either p q) r (Either.right e)) = Either.right (Either.left e)
Fro_or_assoc (Either.right (Either p q) r e) = Either.right (Either.right e)</code></pre>
<p>Agora podemos usar esses fatos com Equal.rewrite e Equal.refl para fornecer provas suaves de afirmações envolvendo equivalências. Aqui está uma versão ternária do resultado anterior de Mult_0:</p>
<pre><code class="language-rust ignore">Mult_0_3 (n: Nat) (m: Nat) (p: Nat) : Equivalence (Equal Nat (Mult n (Mult m p)) 0n) (Either (Equal Nat n 0n) (Either (Equal Nat m 0n) (Equal Nat p 0n)))
Mult_0_3 n m p = Equivalence.new (x =&gt; To_mult_0_3 n m p x) (y =&gt; Fro_mult_0_3 n m p y)

To_mult_0_3 (n: Nat) (m: Nat) (p: Nat) (e: (Equal Nat (Nat.mul n (Nat.mul m p)) 0n)) : (Either (Equal Nat n 0n) (Either (Equal Nat m 0n) (Equal Nat p 0n)))
To_mult_0_3 n m p e = Either.swap (Equivalence.rgt (Or_assoc (Equal m 0n) (Equal p 0n) (Equal n 0n)))

Fro_mult_0_3 (n: Nat) (m: Nat) (p: Nat) (e: Either (Equal Nat n 0n) (Either (Equal Nat m 0n) (Equal Nat p 0n))) : (Equal Nat (Mult n (Mult m p)) 0n)
Fro_mult_0_3 (n: Nat) (m: Nat) (p: Nat) (e: Either (Equal Nat n 0n) (Either (Equal Nat m 0n) (Equal Nat p 0n))) : (Equal Nat (Nat.mul n (Nat.mul m p)) 0n)
Fro_mult_0_3 Nat.zero m p (Either.left Equal.refl) = Equal.refl
Fro_mult_0_3 n Nat.zero p (Either.right a (Either b c) (Either.left Equal.refl)) = Mult_comm 0n n
Fro_mult_0_3 n m Nat.zero (Either.right a (Either b c) (Either.right Equal.refl)) = Equal.chain (Mult_assoc n m 0n) (Mult_0_r (Nat.mul n m))
Fro_mult_0_3 (Nat.succ n) m p (Either.left e) = 
 let p = (Equal.rewrite 
   e
   (x =&gt; match Nat x {
    zero =&gt; Empty
    succ =&gt; Unit
    }) 
    (Unit.new)) 
  Empty.absurd p
Fro_mult_0_3 n (Nat.succ m) p (Either.right a (Either b c) (Either.left e)) = 
 let p = (Equal.rewrite 
   e
   (x =&gt; match Nat x {
    zero =&gt; Empty
    succ =&gt; Unit
    }) 
    (Unit.new)) 
  Empty.absurd p
Fro_mult_0_3 n m (Nat.succ p) (Either.right a (Either b c) (Either.right e)) = 
 let p = (Equal.rewrite 
   e
   (x =&gt; match Nat x {
    zero =&gt; Empty
    succ =&gt; Unit
    }) 
    (Unit.new)) 
  Empty.absurd p</code></pre>
<p>A tática apply também pode ser usada com equivalência. Quando recebe uma equivalência como seu argumento, o apply tenta adivinhar em qual lado da equivalência usar.</p>
<pre><code class="language-rust ignore">Apply_iff_example (n: Nat) (m: Nat) (e: Equal Nat (Mult n m) 0n) : Either (Equal Nat n 0n) (Equal Nat m 0n) 
Apply_iff_example n m e = Equivalence.rgt (Mult_0 n m)
</code></pre>
<h2 id="quantificação-existencial"><a class="header" href="#quantificação-existencial">Quantificação Existencial</a></h2>
<p>Outro importante conectivo lógico é a quantificação existencial. Para dizer que há algum x do tipo Type tal que alguma propriedade p é verdadeira para x, escrevemos (Sigma x p).</p>
<pre><code class="language-rust ignore">record Sigma (x: Type) (p: x -&gt; Type) {
  fst : x
  snd : (p fst)
}</code></pre>
<ul>
<li><em>Atualmente, o Kind-lang tem bug compilador que está afetando a aplicação lambda do Sigma.</em></li>
</ul>
<p>Para provar uma afirmação da forma (Sigma x p), devemos mostrar que p é verdadeira para alguma escolha específica de valor para x, conhecido como testemunho do existencial. Isso é feito em duas etapas: Primeiro, explicitamente informamos ao Kind qual testemunho x temos em mente escrevendo-o no primeiro parâmetro. Então, provamos que p é verdadeira depois que todas as ocorrências de x são substituídas por Type.</p>
<pre><code class="language-rust ignore">Four_is_even : Sigma Nat (n =&gt; (Equal Nat 4n (Nat.add n n)))
Four_is_even = $ 2n Equal.refl</code></pre>
<p>Por outro lado, se temos uma hipótese existencial (Sigma x p) no contexto, podemos fazer um pattern match nela para obter um testemunho x e uma hipótese afirmando que p é verdadeira para x.</p>
<pre><code class="language-rust ignore">Exists_example_2 (n: Nat) (m: Sigma Nat (m =&gt; (Equal Nat n (Nat.add 4n m)))) : Sigma Nat (o =&gt; (Equal Nat n (Nat.add 2n o)))
Exists_example_2 n (Sigma.new Nat s fst snd) = Sigma.new fst ?</code></pre>
<h4 id="dist_not_exists"><a class="header" href="#dist_not_exists">Dist_not_exists</a></h4>
<p>Prove que &quot;p é verdadeira para todos os x&quot; implica &quot;não há x para o qual p não seja verdadeira&quot;.</p>
<pre><code class="language-rust ignore">Dist_not_exists &lt;a&gt; &lt;p: a -&gt; Type&gt; (f: (x: a) -&gt; (p x)) : Not (Sigma a (x =&gt; ( Not (p x))))
Dist_not_exists a p f = ?</code></pre>
<h4 id="dist_exists_or"><a class="header" href="#dist_exists_or">Dist_exists_or</a></h4>
<p>Prove que a quantificação existencial distribui-se sobre a disjunção.</p>
<pre><code class="language-rust ignore">Dist_exists_or &lt;a&gt; &lt;p: a -&gt; Type&gt; &lt;q: a -&gt; Type&gt; : Equivalence (Sigma a (x =&gt; (Either (p x) (q x)))) (Either (Sigma a (x =&gt; (p x))) (Sigma a (x =&gt; (q x))))
Dist_exists_or a p q = ?dist_exists_or_rhs</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programação-com-proposições"><a class="header" href="#programação-com-proposições">Programação com proposições</a></h1>
<p>As conectivas lógicas que vimos fornecem um vocabulário rico para definir proposições complexas a partir de proposições mais simples. Para ilustrar, vamos ver como expressar a afirmação de que um elemento x ocorre em uma lista l. Observe que essa propriedade tem uma estrutura recursiva simples:</p>
<ul>
<li>Se l for a lista vazia, então x não pode ocorrer nela, portanto, a propriedade &quot;x aparece em l&quot; é simplesmente falsa.</li>
<li>Caso contrário, l tem a forma <em>List.cons xh xt</em>. Nesse caso, x ocorre em l se ele é igual a xh ou se ocorre em xt.</li>
</ul>
<p>Podemos traduzir isso diretamente em uma função recursiva simples que recebe um elemento e uma lista e retorna uma proposição:</p>
<pre><code class="language-rust  ignore">In &lt;a&gt; (x: a) (l: List a)    : Type
In a x List.nil              = Empty
In a x (List.cons head tail) = Either (Equal a x head) (In a x tail) </code></pre>
<p>Quando In é aplicado a uma lista concreta, ele se expande em uma sequência concreta de disjunções aninhadas.</p>
<pre><code class="language-rust  ignore">In_example_1 : In 4n [1n, 2n, 3n, 4n, 5n]
In_example_1 = (Either.right (Either.right (Either.right (Either.left Equal.refl))))

In_example_2 (n: Nat) (i: In n [2n, 4n]) : Sigma Nat (m =&gt; Equal Nat n (Nat.mul 2n m))
In_example_2 n (Either.left e)                                  = $ 1n e
In_example_2 n (Either.right l (Either rl rr) (Either.left e))  = $ 2n e
In_example_2 n (Either.right l (Either rl rr) (Either.right e)) = Empty.absurd e</code></pre>
<p>Também podemos provar lemas mais genéricos e de nível superior sobre In. Observe, no próximo exemplo, como In começa sendo aplicado a uma variável e só é expandido quando fazemos análise de casos nessa variável:</p>
<pre><code class="language-rust  ignore">In_map &lt;a&gt; &lt;b&gt; (f: a -&gt; b) (l: List a) (x: a) (i: In x l) : In (f x) (List.map l f) 
In_map a b f (List.nil) x i = Empty.absurd i
In_map a b f (List.cons head tail) x (Either.right e) = Either.right (In_map f tail x e)
In_map a b f (List.cons head tail) x (Either.left e)  = 
    (Equal.rewrite e 
    (y =&gt; (Either (Equal (f x) (f y)) (In (f x) (List.map tail f)))) 
    (Either.left Equal.refl))</code></pre>
<p>Essa forma de definir proposições recursivamente, embora conveniente em alguns casos, também tem algumas desvantagens. Em particular, está sujeita às restrições usuais do Kind em relação à definição de funções recursivas, por exemplo, o requisito de que elas sejam &quot;obviamente terminantes&quot;. No próximo capítulo, veremos como definir proposições indutivamente, uma técnica diferente com seu próprio conjunto de pontos fortes e limitações.</p>
<h4 id="in_map_equiv"><a class="header" href="#in_map_equiv">In_map_equiv</a></h4>
<pre><code class="language-rust  ignore">In_map_equiv &lt;a&gt; &lt;b&gt; (f: a -&gt; b) (l: List a) (y: b) :
   Equivalence (In y (List.map l f)) (Sigma a (x =&gt; (Pair (Equal (f x) y) (In x l))))
In_map_equiv a b f l y = ?</code></pre>
<h4 id="in_app_equiv"><a class="header" href="#in_app_equiv">In_app_equiv</a></h4>
<pre><code class="language-rust  ignore">In_app_equiv &lt;a&gt; (x: a) (l1: List a) (l2: List a) :
  (Equivalence (In x (List.concat l1 l2)) (Either (In x l1) (In x l2)))
In_app_equiv a x l1 l2 = ?</code></pre>
<h4 id="all"><a class="header" href="#all">All</a></h4>
<p>Lembre-se de que funções que retornam proposições podem ser vistas como propriedades de seus argumentos. Por exemplo, se <em>p</em> tem o tipo <code>Nat -&gt; Type</code>, então <code>p n</code> afirma que a propriedade p é verdadeira para n.</p>
<p>Inspirado em <em>In</em>, escreva uma função recursiva <em>All</em> afirmando que alguma propriedade <em>p</em> é verdadeira para todos os elementos de uma lista <em>l</em>. Para garantir que sua definição esteja correta, prove o lema <em>All_In</em> abaixo. (É claro que sua definição não deve apenas repetir o lado esquerdo de <em>All_In</em>.)</p>
<pre><code class="language-rust  ignore">All &lt;t&gt; (p: t -&gt; Type) (l: List t)  : Type
All t p l = ?

All_in &lt;t&gt; (p: t -&gt; Type) (l: List t) : Equivalence ((x: t) -&gt; (i: In x l) -&gt; p x) (All p l)
All_in t p l = ?</code></pre>
<h4 id="combine_odd_even"><a class="header" href="#combine_odd_even">Combine_odd_even</a></h4>
<p>Complete a definição da função combine_odd_even abaixo. Ela recebe como argumentos duas propriedades de números, podd e peven, e deve retornar uma propriedade p tal que p n é equivalente a podd n quando n é ímpar e equivalente a peven n caso contrário.</p>
<pre><code class="language-rust  ignore">Combine_odd_even (podd: Nat -&gt; Type) (peven: Nat -&gt; Type) : Nat -&gt; Type
Combine_odd_even podd peven = ?</code></pre>
<p>Para testar sua definição, prove os seguintes teoremas:</p>
<pre><code class="language-rust  ignore">Combine_odd_even_intro
  (n: Nat)
  (podd:  Nat -&gt; Type)
  (peven: Nat -&gt; Type)
  (p1: (Equal (Nat.is_odd n) Bool.true)  -&gt; podd  n)
  (p2: (Equal (Nat.is_odd n) Bool.false) -&gt; peven n) : (Combine_odd_even (podd) (peven)) n
Combine_odd_even_intro n podd peven p1 p2 = ?

Combine_odd_even_elim_odd
  (n: Nat)
  (podd:  Nat -&gt; Type)
  (peven: Nat -&gt; Type)
  (p: (Combine_odd_even podd peven) n)
  (e: Equal (Nat.is_odd n) Bool.true) : podd n
Combine_odd_even_elim_odd n podd peven p e = ?

Combine_odd_elim_even
  (n: Nat)
  (podd: Nat -&gt; Type)
  (peven: Nat -&gt; Type)
  (p: (Combine_odd_even podd peven) n)
  (e: Equal (Nat.is_odd n) Bool.false) : peven n
Combine_odd_elim_even n podd peven p e = ?</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aplicando-teoremas-a-argumentos"><a class="header" href="#aplicando-teoremas-a-argumentos">Aplicando Teoremas a Argumentos</a></h1>
<p>Uma característica do Kind que o distingue de muitos outros assistentes de prova é que ele trata provas como objetos de primeira classe.</p>
<p>Há muito a ser dito sobre isso, mas não é necessário entender em detalhes para usar o Kind. Esta seção oferece apenas uma amostra, enquanto uma exploração mais profunda pode ser encontrada no capítulo <em>ProofObjects</em>.</p>
<p>Vimos que podemos usar o comando <em>check</em> para pedir ao Kind que imprima o tipo de uma expressão. Também podemos usar <em>check</em> para perguntar a qual teorema um identificador particular se refere.</p>
<pre><code class="language-rust  ignore">PlusCommutative (m: Nat) (n: Nat) : Equal (Nat.add n m) (Nat.add m n)
PlusCommutative m n = ?</code></pre>
<p>Kind imprime a declaração do teorema plusCommutative da mesma forma que imprime o tipo de qualquer termo que pedimos para verificar. Por quê?</p>
<p>A razão é que o identificador plusCommutative se refere na verdade a um objeto de prova - uma estrutura de dados que representa uma derivação lógica estabelecendo a verdade da declaração <em>(n: Nat) (m: Nat) : n + m = m + n</em>. O tipo desse objeto é a declaração do teorema do qual é uma prova.
Intuitivamente, isso faz sentido porque a declaração de um teorema nos diz para que podemos usá-lo, assim como o tipo de um objeto computacional nos diz o que podemos fazer com esse objeto - por exemplo, se temos um termo do tipo Nat -&gt; Nat -&gt; Nat, podemos dar a ele dois Nats como argumentos e obter um Nat de volta. Da mesma forma, se temos um objeto do tipo n = m -&gt; n + n = m + m e fornecemos a ele um &quot;argumento&quot; do tipo n = m, podemos derivar n + n = m + m.
Operacionalmente, essa analogia vai ainda mais longe: aplicando um teorema, como se fosse uma função, a hipóteses com tipos correspondentes, podemos especializar seu resultado sem ter que recorrer a afirmações intermediárias. Por exemplo, suponha que quiséssemos provar o seguinte resultado:</p>
<pre><code class="language-rust  ignore">Plus_comm3a: (n: Nat) (m: Nat) (p: Nat) : Equal (Nat.add n (Nat.add m p)) (Nat.add (Nat.add p m) n)</code></pre>
<p>À primeira vista, parece que deveríamos ser capazes de provar isso abrindo os casos, pra caso <em>zero</em> e <em>succ _</em>, mas isso nos daria um trabalho desnecessário. Vejamos um exemplo:</p>
<pre><code class="language-rust  ignore">Plus_comm3a Nat.zero n p = ?</code></pre>
<p>Nesse caso, o nosso objetivo é provar:</p>
<pre><code class="language-bash  ignore">(Equal _ (Nat.add n p) (Nat.add (Nat.add p 0n) n)) 
</code></pre>
<p>Mas veja, para isso nós precisamos de outra prova, a de que</p>
<pre><code class="language-bash  ignore">Equal Nat (Nat.add p 0n) p
</code></pre>
<p>Para resolver essa prova seria esse o caminho:</p>
<pre><code class="language-rust  ignore">Add_n_z (n: Nat)       : (Equal (Nat.add n Nat.zero) n)
Add_n_z Nat.zero       = Equal.refl
Add_n_z (Nat.succ n)   =
     let ind = Add_n_z n
     let app = (Equal.apply (x =&gt; (Nat.succ x)) ind)
     app</code></pre>
<p>Agora vamos provar:</p>
<pre><code class="language-rust  ignore">Plus_comm3a (n: Nat) (m: Nat) (p: Nat) : Equal (Nat.add n (Nat.add m p)) (Nat.add (Nat.add p m) n)
Plus_comm3a Nat.zero n p = 
  let pzr = Add_z_r p
  let com = Plus_comm n p
  let rwt = Equal.rewrite (Equal.mirror pzr) (x =&gt;(Equal _ (Nat.add n p) (Nat.add (x) n))) com
  rwt</code></pre>
<p>Agora só nos resta provar para o caso de <em>Nat.succ n</em></p>
<pre><code class="language-rust  ignore">Plus_comm3a (Nat.succ m) n p = ?</code></pre>
<p>e o nosso objetivo é <code>(Equal _ (Nat.succ (Nat.add m (Nat.add n p))) (Nat.add (Nat.add p n) (Nat.succ m)))</code> e para isso precisaríamos de outras provas, como a que</p>
<pre><code class="language-rust  ignore">Plus_n_sm (n: Nat) (m: Nat) : (Equal Nat (Nat.succ (Nat.add n m))(Nat.add n (Nat.succ m)))
Plus_n_sm Nat.zero m        = Equal.refl
Plus_n_sm (Nat.succ n) m    = (Equal.apply (x =&gt; (Nat.succ x)) (Plus_n_sm n m))</code></pre>
<p>E reescrever na prova da comutatividade da adição entre <em>n</em> e <em>p</em> e depois usar a prova da comutatividade para isso tudo, um trabalho cansativo e, posso dizer, desnecessário.</p>
<p>Ao invés de abrir os casos, vamos trabalhar com eles como variáveis puras, quase sem valor</p>
<pre><code class="language-rust  ignore">Plus_comm3 (m: Nat) (n: Nat) (p: Nat) : Equal (Nat.add n (Nat.add m p)) (Nat.add (Nat.add p m) n)
Plus_comm3 m n p = ?</code></pre>
<p>Nosso objetivo continua sendo <code>(Equal _ (Nat.add n (Nat.add m p)) (Nat.add (Nat.add p m) n))</code> e para entender isso, vamos analisar o nosso problema e os próximos passos serão triviais demais:</p>
<ul>
<li><em>n + (m + p) = (p + m) + n</em></li>
</ul>
<p>Isso é exatamente a comutatividade da adição, então basta reescrever a nossa prova <em>Plus_comm</em> duas vezes, uma dentro da outra</p>
<pre><code class="language-rust  ignore">let a = Equal.rewrite (Plus_comm p m) (x =&gt; (Equal (Nat.add n (Nat.add m p)) (Nat.add (x) n))) (Plus_comm3 m n p)</code></pre>
<p>e veja o que nossa variável <em>a</em> retorna</p>
<pre><code class="language-bash  ignore">(Equal Nat (Nat.add n (Nat.add m p)) (Nat.add (Nat.add m p) n))
</code></pre>
<p>Estamos quase lá, basta apenas reescrever o segundo <em>Plus_comm</em> na adição mais interna do lado direito</p>
<pre><code class="language-rust  ignore">let b = Equal.rewrite (Plus_comm m p) (x =&gt; (Equal Nat (Nat.add n (Nat.add m p)) (Nat.add (x) n))) a</code></pre>
<p>e o nosso <em>b</em> é exatamente igual ao nosso objetivo</p>
<pre><code class="language-bash  ignore">(Equal Nat (Nat.add n (Nat.add m p)) (Nat.add (Nat.add p m) n)) 
</code></pre>
<p>A prova completa fica:</p>
<pre><code class="language-rust ignore">Plus_comm3 (m: Nat) (n: Nat) (p: Nat) : Equal (Nat.add n (Nat.add m p)) (Nat.add (Nat.add p m) n)
Plus_comm3 m n p = 
  let a = Equal.rewrite (Plus_comm p m) (x =&gt; (Equal (Nat.add n (Nat.add m p)) (Nat.add (x) n))) (Plus_comm3 m n p)
  let b = Equal.rewrite (Plus_comm m p) (x =&gt; (Equal Nat (Nat.add n (Nat.add m p)) (Nat.add (x) n))) a
  b</code></pre>
<p>Muito mais simples e elegante, não precisava de tanto trabalho, uma breve leitura do problema praticamente já nos entregava a solução. Perceba, isso não foi diferente de tudo o que já fizemos até aqui, é até uma repetição dos passos anteriores, é semelhante à aplicação de uma função polimórfica a um argumento de tipo.</p>
<p>Você pode &quot;usar teoremas como funções&quot; desta maneira com quase todas as táticas que recebem um nome de teorema como argumento. Note também que a aplicação de teorema usa os mesmos mecanismos de inferência que a aplicação de função; portanto, é possível, por exemplo, fornecer wildcards como argumentos a serem inferidos, ou declarar algumas hipóteses de um teorema como implícitas por padrão. Esses recursos são ilustrados na prova abaixo.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kind-vs-teoria-dos-conjuntos"><a class="header" href="#kind-vs-teoria-dos-conjuntos">Kind vs Teoria dos Conjuntos</a></h2>
<p>O núcleo lógico do Coq, o Cálculo das Construções Indutivas, difere de algumas maneiras importantes de outros sistemas formais que são usados pelos matemáticos para escrever provas precisas e rigorosas. Por exemplo, na fundação mais popular para a matemática em papel e lápis convencional, a Teoria dos Conjuntos de Zermelo-Fraenkel (ZFC), um objeto matemático pode potencialmente ser membro de muitos conjuntos diferentes; um termo na lógica de Kind, por outro lado, é membro de no máximo um tipo. Essa diferença muitas vezes leva a formas ligeiramente diferentes de capturar conceitos matemáticos informais, mas estes são, em grande parte, bastante naturais e fáceis de trabalhar. Por exemplo, em vez de dizer que um número natural n pertence ao conjunto de números pares, diríamos em Kind que ev n é verdadeiro, onde ev: Nat -&gt; Tipo é uma propriedade que descreve os números pares.</p>
<p>No entanto, há alguns casos em que traduzir o raciocínio matemático padrão para Kind pode ser tanto trabalhoso quanto, às vezes, até impossível, a menos que enriqueçamos a lógica central com axiomas adicionais. Concluímos este capítulo com uma breve discussão de algumas das diferenças mais significativas entre os dois mundos.</p>
<h3 id="extensão-funcional"><a class="header" href="#extensão-funcional">Extensão Funcional.</a></h3>
<p>As afirmações de igualdade que vimos até agora dizem principalmente respeito a elementos de tipos indutivos (Nat, Bool, etc.). Mas como o operador de igualdade de Kind é polimórfico, essas não são as únicas possibilidades - em particular, podemos escrever proposições que afirmam que duas funções são iguais uma à outra:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Function_equality_ex1 : Equal (Nat.succ 3n) (Nat.succ (Nat.pred 4n))
Function_equality_ex1 = Equal.refl
<span class="boring">}</span></code></pre></pre>
<p>Na prática matemática comum, duas funções f e g são consideradas iguais se produzem as mesmas saídas:</p>
<p>(∀𝑥, 𝑓(𝑥) = 𝑔(𝑥)) → 𝑓 = 𝑔</p>
<p>Isto é conhecido como o princípio da extensão funcional.</p>
<p>De forma informal, uma &quot;propriedade extensional&quot; é aquela que diz respeito ao comportamento observável de um objeto. Assim, a extensão funcional significa simplesmente que a identidade de uma função é completamente determinada pelo que podemos observar a partir dela - isto é, em termos de Kind, os resultados que obtemos após aplicá-la.</p>
<p>A extensão funcional não faz parte dos axiomas básicos do Kind. Isso significa que algumas proposições &quot;razoáveis&quot; não são prováveis.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Function_equality_ex2 : Equal ((x: Nat) =&gt; Nat.add x 1n) ((x: Nat) =&gt; Nat.add 1n x)
Function_equality_ex2 = ?
<span class="boring">}</span></code></pre></pre>
<p>No entanto, podemos declarar um teorema e pular a sua prova ou usar um buraco</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Functional_extensionality &lt;a&gt;&lt;b&gt; (f: a -&gt; b) (g: a -&gt; b) (e: (x: a) -&gt; Equal (f x) (g x)) : Equal f g
<span class="boring">}</span></code></pre></pre>
<p>Agora podemos invocar a extensionalidade funcional em provas:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Function_equality_ex2 : Equal ((x: Nat) =&gt; Nat.add x 1n) ((x: Nat) =&gt; Nat.add 1n x)
Function_equality_ex2 =
  Functional_extensionality ((x: Nat) =&gt; Nat.add x 1n) ((x: Nat) =&gt; Nat.add 1n x) (x =&gt; Plus_comm x 1n)
<span class="boring">}</span></code></pre></pre>
<p>Naturalmente, devemos ter cuidado ao adicionar novos axiomas à lógica do Kind, pois eles podem torná-la inconsistente - ou seja, podem tornar possível provar todas as proposições, incluindo Void!</p>
<p>Infelizmente, não há uma maneira simples de saber se um axioma é seguro para adicionar: geralmente é necessário um trabalho árduo para estabelecer a consistência de qualquer combinação particular de axiomas.</p>
<p>No entanto, sabe-se que adicionar a extensionalidade funcional, em particular, é consistente.</p>
<h4 id="tr_rev"><a class="header" href="#tr_rev">Tr_rev</a></h4>
<p>Um problema com a definição da função de reversão de lista &quot;rev&quot; que temos é que ela realiza uma chamada a &quot;++&quot; a cada passo. Executar &quot;++&quot; leva tempo assintoticamente linear no tamanho da lista, o que significa que &quot;rev&quot; tem tempo de execução quadrático.
Podemos melhorar isso com a seguinte definição:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Rev_append &lt;x&gt; (l1: List x) (l2: List x)  : List x
Rev_append x List.nil l2                  = l2
Rev_append x (List.cons xs.h xs.t) l2     = Rev_append xs.t (List.cons xs.h l2)

Tr_rev &lt;x&gt; (l: List x) : List x
Tr_rev x l = Rev_append x l List.nil1
<span class="boring">}</span></code></pre></pre>
<p>Esta versão é dita ser tail-recursive, porque a chamada recursiva à função
é a última operação que precisa ser executada (ou seja, não precisamos executar ++
após a chamada recursiva); um compilador decente irá gerar um código muito eficiente neste
caso. Prove que as duas definições são realmente equivalentes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Tr_rev_correct &lt;a&gt; (xs: List a) : Equal (Tr_rev xs) (Rev xs)
Tr_rev_correct a xs = ?
<span class="boring">}</span></code></pre></pre>
<h3 id="proposições-e-booleans"><a class="header" href="#proposições-e-booleans">Proposições e Booleans.</a></h3>
<p>Vimos duas maneiras diferentes de codificar fatos lógicos em Kind: com booleanos (do tipo Bool) e com proposições (do tipo Type).
Por exemplo, para afirmar que um número n é par, podemos dizer que
• (1) evenb n retorna True, ou
• (2) existe um k tal que n = double k. De fato, essas duas noções de paridade são equivalentes, como pode ser facilmente mostrado com um par de lemas auxiliares.
Muitas vezes dizemos que o booleano evenb n reflete a proposição (n =&gt; Equal n (double k)).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Evenb_double (k: Nat)     : Equal (Nat.is_even (Nat.double k)) Bool.true
Evenb_double Nat.zero     = Equal.refl
Evenb_double (Nat.succ k) = Evenb_double k
<span class="boring">}</span></code></pre></pre>
<h4 id="evenb_double_conv"><a class="header" href="#evenb_double_conv">Evenb_double_conv</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Evenb_double_conv (n: Nat):
  Sigma Nat (k =&gt; (Equal n (Bool.if (Evenb n) (Nat.double k) (Nat.succ (Nat.double k)))))
Evenb_double_conv n = ?
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contribuidores"><a class="header" href="#contribuidores">Contribuidores</a></h1>
<ul>
<li><a href="https://github.com/NaoEhSavio">NaoEhSavio</a></li>
<li><a href="https://github.com/SergioBonatto">Bonatto</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
