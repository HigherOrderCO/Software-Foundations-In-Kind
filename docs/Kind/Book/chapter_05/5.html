<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Polymorphism - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="../../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        
        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="README.html">Introduction</a></li><li><a href="guide/Started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li><a href="guide/About.html"><strong aria-hidden="true">1.1.</strong> About Kind</a></li><li><a href="guide/Installation.html"><strong aria-hidden="true">1.2.</strong> Installation</a></li><li><a href="cli/World.html"><strong aria-hidden="true">1.3.</strong> Hello World!</a></li><li><a href="cli/kind.html"><strong aria-hidden="true">1.4.</strong> Hello Kind!</a></li></ol></li><li><a href="Book/chapter_02/2,1.html"><strong aria-hidden="true">2.</strong> Basics: Introduction</a></li><li><ol class="section"><li><a href="Book/chapter_02/2,2.html"><strong aria-hidden="true">2.1.</strong> Enumerated Types</a></li><li><ol class="section"><li><a href="Book/chapter_02/2,2,1.html"><strong aria-hidden="true">2.1.1.</strong> Days of the Week</a></li></ol></li><li><a href="Book/chapter_02/2,3.html"><strong aria-hidden="true">2.2.</strong> Booleans</a></li><li><a href="Book/chapter_02/2,4.html"><strong aria-hidden="true">2.3.</strong> Function Types</a></li><li><a href="Book/chapter_02/2,5.html"><strong aria-hidden="true">2.4.</strong> Modules</a></li><li><a href="Book/chapter_02/2,6.html"><strong aria-hidden="true">2.5.</strong> Numbers</a></li><li><a href="Book/chapter_02/2,7.html"><strong aria-hidden="true">2.6.</strong> Proof by Simplification</a></li><li><a href="Book/chapter_02/2,8.html"><strong aria-hidden="true">2.7.</strong> Proof by Application</a></li><li><a href="Book/chapter_02/2,9.html"><strong aria-hidden="true">2.8.</strong> Proof by Case Analysis</a></li><li><a href="Book/chapter_02/2,10.html"><strong aria-hidden="true">2.9.</strong> Proof by Rewriting</a></li><li><a href="Book/chapter_02/2,11.html"><strong aria-hidden="true">2.10.</strong> Equal.chain and Equal.mirror</a></li><li><a href="Book/chapter_02/2,12.html"><strong aria-hidden="true">2.11.</strong> More Exercises</a></li></ol></li><li><a href="Book/chapter_03/3.html"><strong aria-hidden="true">3.</strong> Induction: Proof by Induction</a></li><li><ol class="section"><li><a href="Book/chapter_03/3,1.html"><strong aria-hidden="true">3.1.</strong> Exercises</a></li><li><a href="Book/chapter_03/3,2.html"><strong aria-hidden="true">3.2.</strong> More Exercises</a></li></ol></li><li><a href="Book/chapter_04/4.html"><strong aria-hidden="true">4.</strong> Data Structures</a></li><li><ol class="section"><li><a href="Book/chapter_04/4,1.html"><strong aria-hidden="true">4.1.</strong> Lists of Numbers</a></li><li><a href="Book/chapter_04/4,2.html"><strong aria-hidden="true">4.2.</strong> Reasoning about Lists</a></li><li><a href="Book/chapter_04/4,3.html"><strong aria-hidden="true">4.3.</strong> Maybe</a></li></ol></li><li><a href="Book/chapter_05/5.html" class="active"><strong aria-hidden="true">5.</strong> Polymorphism</a></li><li><ol class="section"><li><a href="Book/chapter_05/5,1.html"><strong aria-hidden="true">5.1.</strong> Functions as Data</a></li><li><a href="Book/chapter_05/5,2.html"><strong aria-hidden="true">5.2.</strong> Additional Exercises</a></li></ol></li><li><a href="Book/chapter_06/6.html"><strong aria-hidden="true">6.</strong> Logic in Kind</a></li><li><ol class="section"><li><a href="Book/chapter_06/6,1.html"><strong aria-hidden="true">6.1.</strong> Logical Connectives</a></li><li><a href="Book/chapter_06/6,2.html"><strong aria-hidden="true">6.2.</strong> Falsity and Negation</a></li><li><a href="Book/chapter_06/6,3.html"><strong aria-hidden="true">6.3.</strong> Truth, Equivalence, and Quantification</a></li><li><a href="Book/chapter_06/6,4.html"><strong aria-hidden="true">6.4.</strong> Programming with Propositions</a></li><li><a href="Book/chapter_06/6,5.html"><strong aria-hidden="true">6.5.</strong> Applying Theorems to Arguments</a></li><li><a href="Book/chapter_06/6,6.html"><strong aria-hidden="true">6.6.</strong> Kind vs Set Theory</a></li><li class="spacer"></li></ol></li><li><a href="Contributors.html">Contributors</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="Book/chapter_05/5.html#polimorfismo" id="polimorfismo"><h1>Polimorfismo</h1></a>
<p>Neste capítulo, continuamos nosso desenvolvimento de conceitos básicos de programação. Nossos novos princípios essenciais são o polimorfismo (funções de abstração sobre o
tipos de dados que eles manipulam) e funções de ordem superior (funções de tratamento como dados). Começamos com o polimorfismo.</p>
<a class="header" href="Book/chapter_05/5.html#listas-polimórficas" id="listas-polimórficas"><h2>Listas Polimórficas</h2></a>
<p>Nos últimos dois capítulos, trabalhamos com listas polimórficas, você pode só não ter percebido. Obviamente, programas interessantes também precisam ser capazes de
manipular listas com elementos de outros tipos – listas de strings, listas de booleanos,
listas de listas, etc. Poderíamos apenas definir um novo tipo de dados indutivo para cada um deles,
por exemplo...</p>
<pre><code class="language-rust ignore">type BoolList {
   nil 
   cons (head: Bool) (tail: List Bool) 
}
</code></pre>
<p>.. mas isso rapidamente se tornaria tedioso, em parte porque temos que compensar
nomes de construtor diferentes para cada tipo de dados, mas principalmente porque também
precisamos definir novas versões de todas as nossas funções de manipulação de listas (length, rev, etc.)
para cada nova definição de tipo de dados.</p>
<p>Para evitar toda essa repetição, o <em>Kind</em> suporta definições de tipos indutivos polimórficos.
Por exemplo, aqui está um tipo de dados de lista polimórfica e que já vimos no capítulo anterior:</p>
<pre><code class="language-rust ignore">type List (t) {
   nil 
   cons (head: t) (tail: List t) 
}
</code></pre>
<p>Esse tipo já exite no Kind e podemos perceber que ele é idententico ao BoolList , mas com um tipo <code>a</code>, esse <em>tipo</em> recebe qualquer outro tipo, seja <em>Nat</em>, <em>Bool</em>, <em>Maybe</em> e etc.
Não precisamos criar um tipo de lista para cada um dos tipos de dados, podemos usar esse que adota todas as formas existentes.</p>
<p>Que tipo de coisa é a própria Lista? Uma boa maneira de pensar sobre isso é que List é
uma função de Tipos para defi   nições indutivas; ou, em outras palavras, List é
uma função de Tipos para Tipos. Para qualquer tipo específico x, o tipo List x é um
conjunto indutivamente definido de listas cujos elementos são do tipo x.</p>
<p>Com esta definição, quando usamos os construtores <code>List.nil</code> e <code>List.cons</code> para construir listas,
precisamos dizer ao Kind o tipo dos elementos nas listas que estamos construindo - isto
é, que <code>List.nil</code> e <code>List.cons</code> agora são construtores polimórficos. Observe os tipos de
construtores:</p>
<pre><code class="language-rust ignore">record Pair (a) (b) {
  fst : a
  snd : b
}
</code></pre>
<p>Nosso tipo <em>Pair</em> recebe outros dois tipos, o <code>a</code> e o <code>b</code> e retorna um par dos dois tipos. Não foi necessário definir se o par era de números naturais,
booleanos, listas, bits ou outros pares, nós deixamos a função apta a tratar todos os pares possíveis e isso é graças ao <em>polimorfismo</em>.</p>
<p>Agora podemos voltar e fazer versões polimórficas de todas as listas de processamento
funções que escrevemos antes. Aqui está a repetição, por exemplo:</p>
<pre><code class="language-rust ignore">Repeat &lt;a: Type&gt; (x: a) (count: Nat) : List a
Repeat a x Nat.zero                  = List.nil
Repeat a x (Nat.succ count)          = List.cons x (Repeat x count)
</code></pre>
<p>Tal como acontece com <code>List.nil</code> e Contras, podemos usar repeat aplicando-o primeiro a um tipo e depois a
seu argumento de lista:</p>
<pre><code class="language-rust ignore">Test_repeat1 : Equal (Repeat 4n 2n) (List.cons 4n (List.cons 4n List.nil))
Test_repeat1 = Equal.refl
</code></pre>
<p>Para usar repeat para construir outros tipos de listas, simplesmente instanciamos com um parâmetro de tipo apropriado:</p>
<pre><code class="language-rust ignore">Test_repeat2 : Equal (Repeat Bool.false 1n) (List.cons Bool.false List.nil)
Test_repeat2 = Equal.refl
</code></pre>
<a class="header" href="Book/chapter_05/5.html#inferência-de-anotação-de-tipo" id="inferência-de-anotação-de-tipo"><h3>Inferência de anotação de tipo</h3></a>
<p>Vamos escrever a definição do <code>repeat</code> novamente, mas dessa vez omitindo o tipo, mas atenção, essa não é uma boa prática usar o <code>hole</code>, servirá apenas para compreender o poder do Kind e como ele pode ajudar o usuário a encontrar o que deseja.</p>
<pre><code class="language-rust ignore">Repeat (x: _) (count: Nat) : List _
Repeat x Nat.zero          = ?
</code></pre>
<p>Ao rodar o <em>Type Check</em> o terminal nos retorna:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: (List _) 

   • Context: 
   •   x : _ 

   Repeat x Nat.zero = ?
                       ┬
                       └Here!
</code></pre>
<p>Para o caso do contador ser zero, que é o nosso ponto de parada, nós precisamos retornar uma lista do tipo não definido.
Como fizemos quando nosso tipo era definido, estamos criando uma lista que não repete o termo nenhuma vez, retornamos um <em>List.nil</em>, depois nós verificamos para o caso de uma lista que repetirá o valor <em>count</em> vezes, para isso nós usaremos a recursão por meio do <code>Nat.succ pred</code>, isto é, o nosso <em>count</em> é igual ao sucessor do predecessor dele.</p>
<pre><code class="language-rust ignore">Repeat x (Nat.succ count) = ?
</code></pre>
<p>E o o <em>Type Check</em> nos retorna:</p>
<pre><code class="language-diff">+ INFO  Inspection.

   • Expected: (List _) 

   • Context: 
   •   x     : _ 
   •   count : Nat 

   Repeat x (Nat.succ count) = ?
                               ┬
                               └Here!
</code></pre>
<p>Agora basta construir a lista com o valor e chamar a função para o predecessor de count, assim construindo a lista até que chegue a zero.</p>
<pre><code class="language-rust ignore">Repeat (x: _) (count: Nat) : List _
Repeat x Nat.zero          = List.nil
Repeat x (Nat.succ count)  = List.cons x (Repeat x count)
</code></pre>
<p>Podemos perceber que, apesar de não definir o tipo de <em>x</em>, o <em>Kind</em> é poderoso para descobrir o tipo que é nosso x quando usamos o <em>hole</em> <code>_</code>. Embora seja possível e possa até facilitar construir uma aplicação inteira usando essa notação, não é uma boa prática, já que, a depender do caso, pode ser inferido um tipo diferente do que o desejado. É interessante sempre definir o tipo do nosso elemento, mesmo que seja um tipo polimórfico.</p>
<p>No primeiro caso, quando definimos o tipo <code>a</code>, já abarcamos todos os tipos possíveis, não sendo necessário o uso do hole e essa é a mágica do polimorfismo, ele nos permite usar uma mesma função para diversos tipos diferentes.</p>
<p>Para usar uma função polimórfica, nós precisamos passar um ou mais tipos em adição aos outros argumentos. Por exemplo, no caso do <em>repeat</em>, nós passamos o tipo <code>&lt;a: Type&gt;</code> e que cada elemento da nossa lista é desse tipo. Fizemos o mesmo com o tipo <em>Pair</em>, que recebia como argumento dois tipos <em>a</em> e <em>b</em>.</p>
<p>Agora fica muito mais fácil compreender os exemplos que usamos no capítulo anterior, quando apresentamos funções como a de <em>length</em> e <em>append</em>:</p>
<pre><code class="language-rust ignore">Length &lt;a&gt; (xs: List a) : Nat
Length (List.nil t)            = Nat.zero
Length (List.cons t head tail) = (Nat.succ (Length tail))

Concat &lt;a: Type&gt; (xs: List a) (ys: List a) : List a
Concat (List.nil)                     ys = ys
Concat (List.cons head tail)          ys = List.cons head (Concat tail ys)

</code></pre>
<p>Perceba, há duas notações, uma onde apenas usamos <code>&lt;a&gt;</code> e outra onde usamos <code>&lt;a: Type&gt;</code>, podemos usar qualquer uma delas, o <em>Kind</em> é capaz de compreender as duas formas, será de escolha do desenvolvedor qual ele usará e da complexidade do que será desenvolvido, uma vez que, em códigos muito complexos, talvez seja interessante deixar explícito a outros programadores o que é cada coisa.</p>
<p>Agora é a hora de implementar nossas funções com o tipo implícito, usando o <code>hole</code> e <code>sugar syntax</code>:</p>
<pre><code class="language-rust ignore">Concat_implicito (xs: List _) (ys: List _) : List _
Concat_implicito []                     ys = ys
Concat_implicito (List.cons head tail)  ys = List.cons head (Concat_implicito tail ys)
</code></pre>
<p>Aqui nós aprendemos mais uma coisa, o <em>sugar syntax</em> para uma lista vazia e que é apenas <code>[]</code>, mas isso está errado, uma vez que o <code>sugar syntax</code> no kind não funciona no lado esquerdo do escopo da função, somente do lado direito funciona. Ao usar o <em>sugar syntax</em> errado, o que o <em>Kind</em> apresenta como erro:</p>
<pre><code class="language-diff">- ERROR  Unexpected token '['.
    Concat_implicito []  ys = ys
                  ┬
                  └Here!
</code></pre>
<p>Portanto, é sempre importante saber exatamente o que está sendo feito, ainda mais quando usamos <em>sugar syntax</em>, ela serve pra facilitar a nossa vida, mas pode causar alguns problemas quando usada de forma indevida e isso serve igualmente para o <em>hole</em> e tipos polimórficos nos auxiliam a escrever um programa mais seguro e, ao mesmo tempo, capaz de servir para inúmeros casos.</p>
<p>Outra função que podemos reescrever é a de reverse:</p>
<pre><code class="language-rust ignore">Rev &lt;a&gt; (xs: List a) : List a
Rev List.nil              = [] // sugar syntax de List.nil
Rev (List.cons head tail) = Concat (Rev tail) [head] // sugar syntax de (List.cons head List.nil)

Length &lt;a&gt; (xs: List a) : Nat
Length List.nil              = 0n // sugar syntax de Nat.zero
Length (List.cons head tail) = Nat.succ (Length tail)
</code></pre>
<p>Feito isso, basta apenas provar que nossas funções são verdadeiras:</p>
<pre><code class="language-rust ignore">Test_rev1 : Equal (Rev [1,2,3]) [3,2,1]
Test_rev1 = Equal.refl

Test_rev2 : Equal (Rev [Bool.true]) [Bool.true]
Test_rev2 = Equal.refl

Test_length1 : Equal (Length [1,2,3]) 3n
Test_length1 = Equal.refl
</code></pre>
<a class="header" href="Book/chapter_05/5.html#exercícios-polimórficos" id="exercícios-polimórficos"><h4>Exercícios polimórficos</h4></a>
<p>Aqui estão alguns exercícios simples, semelhantes aos da seção de Listas, para praticar o polimorfismo. Complete as provas abaixo.</p>
<pre><code class="language-rust ignore">Concat_nil_r &lt;a&gt; (xs: List a) : Equal (Concat xs List.nil) xs
Concat_nil_r xs = ?

Concat_assoc &lt;a&gt; (xs: List a) (ys: List a) (zs: List a) : Equal (Concat xs (Concat ys zs)) (Concat (Concat xs ys) zs)
Concat_assoc xs ys zs = ?

Concat_length &lt;a&gt; (xs: List a) (ys: List a) : Equal (Length (Concat xs ys)) (Plus (Length xs) (Length ys))
Concat_length xs ys = ?
</code></pre>
<a class="header" href="Book/chapter_05/5.html#mais-exercícios-polimórficos" id="mais-exercícios-polimórficos"><h4>Mais exercícios polimórficos</h4></a>
<p>Aqui estão alguns um pouco mais interessantes...</p>
<pre><code class="language-rust ignore">Rev_app_distr &lt;a&gt; (xs: List a) (ys: List a) : Equal (Rev (Concat xs ys)) (Concat (Rev ys) (Rev xs))
Rev_app_distr xs ys = ?

Rev_involutive &lt;a&gt; (xs: List a) : Equal (Rev (Rev xs)) xs
Rev_involutive xs = ?
</code></pre>
<a class="header" href="Book/chapter_05/5.html#pares-polimórficos" id="pares-polimórficos"><h2>Pares polimórficos</h2></a>
<p>Seguindo o mesmo padrão, a definição de tipo
que demos no último capítulo para pares de números podem ser generalizados para polimórficos
pares:</p>
<pre><code class="language-rust ignore">record Pair (a) (b) {
  fst : a
  snd : b
} 
</code></pre>
<p>Essa é exatamente a primeira definição de pares que vimos no capítulo anterior e, agora, podemos compreender perfeitamente o que são os tipos <code>a</code> e <code>b</code> na definição do tipo <em>Pair</em>.</p>
<p>Nós podemos refazer as funções de <em>Pares</em>, mas agora para tipos polimórficos:</p>
<pre><code class="language-rust ignore">Fst &lt;a&gt; &lt;b&gt; (pair: Pair a b) : a
Fst (Pair.new fst snd) = fst

Snd &lt;a&gt; &lt;b&gt; (pair: Pair a b) : b
Snd (Pair.new fst snd) = snd
</code></pre>
<p>A seguinte função recebe duas listas e combina elas numa lista de pares. Nas linguagens funcionais, isso é comumente chamada de <em>Zip</em>.</p>
<pre><code class="language-rust ignore">Zip &lt;a&gt; &lt;b&gt; (xs: List a) (ys: List b) : (List (Pair a b))
Zip [] ys = []
Zip xs [] = []
Zip (List.cons xs.h xs.t) (List.cons ys.h ys.t) = List.cons (Pair.new xs.h xs.t) (Zip xs.t ys.t)
</code></pre>
<a class="header" href="Book/chapter_05/5.html#check" id="check"><h4>Check</h4></a>
<p>Sem rodar o programa, tente responder a seguinte pergunta:</p>
<ul>
<li>O que a combinação de [1, 2] e [Bool.true, Bool.false, Bool.false, Bool.true] retornará?</li>
</ul>
<p>Agora rode o código e veja se acertou.</p>
<a class="header" href="Book/chapter_05/5.html#split" id="split"><h4>Split</h4></a>
<p>A função <em>Split</em> é o inverso da <em>Zip</em>, ela recebe uma lista de pares e retorna um par de listas. Em muitas linguagens funcionais ela é chamada de <em>Unzip</em>.</p>
<p>Preencha a definição de divisão abaixo. Certifique-se de que ela passe no teste unitário fornecido.</p>
<pre><code class="language-rust ignore">Split &lt;a&gt; &lt;b&gt; (xs: List (Pair a b)) : Pair (List a) (List b)
Split xs = ?

Test_split : Equal (Split [(Pair.new 1 Bool.false), (Pair.new 2 Bool.false)]) (Pair.new ([1, 2]) ([Bool.false, Bool.false]))
Test_split = ?
</code></pre>
<a class="header" href="Book/chapter_05/5.html#polimorfismo-com-maybe" id="polimorfismo-com-maybe"><h4>Polimorfismo com maybe</h4></a>
<p>No capítulo anterior, nós também vimos o tipo <em>Maybe</em>, só que para tipos naturais, entretanto, como vimos no capítulo atual, nossas estruturas de dados podem ser polimórficas, o que significa que o tipo <em>Maybe</em> também é polimórfico e é isso o que veremos agora.</p>
<pre><code class="language-rust ignore">type Maybe (t) {
  none 
  some (value: t)
}
</code></pre>
<p>Dessa forma, podemos escrever a função do <em>enésimo</em> erro para ele ser usado com todos os tipos de listas:</p>
<pre><code class="language-rust ignore">Nth_error &lt;a&gt; (n: Nat) (xs: List a) : Maybe a
Nth_error a n List.nil              = Maybe.none
Nth_error a n (List.cons head tail) =
  let ind = Nth_error (Pred n) tail
  Bool.if (Eql n 0n) (Maybe.some head) (ind)


Test_nth_error1 : Equal (Nth_error 0n [4n,5n,5n,7n]) (Maybe.some 4n)
Test_nth_error1 = Equal.refl

Test_nth_error2 : Equal (Nth_error 2n [Bool.true]) Maybe.none
Test_nth_error2 = Equal.refl

Test_nth_error3 : Equal (Nth_error 1n [[1n],[2n]]) (Maybe.some [2n])
Test_nth_error3 = Equal.refl

</code></pre>
<a class="header" href="Book/chapter_05/5.html#hd_error" id="hd_error"><h4>Hd_error</h4></a>
<p>Complete a definição de uma versão polimórfica da função Hd_error do último capítulo. Certifique-se de que ele passe nos testes de unitários abaixo.</p>
<pre><code class="language-rust ignore">Hd_error &lt;a&gt; (xs: Lista a) : Maybe a
Hd_error xs = ?

Test_hd_error1 : Equal (Hd_error [1, 2]) (Maybe.some 1)
Test_hd_error1 = ?

Test_hd_error2 : Equal (Hd_error [[1], [2]]) (Maybe.some [1])
Test_hd_error2 = ?
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="Book/chapter_04/4,3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="Book/chapter_05/5,1.html" class="mobile-nav-chapters next" title="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="Book/chapter_04/4,3.html" class="nav-chapters previous" title="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="Book/chapter_05/5,1.html" class="nav-chapters next" title="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
