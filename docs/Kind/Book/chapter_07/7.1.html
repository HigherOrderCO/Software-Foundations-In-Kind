<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Using Evidence in Proofs</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="../../guide/Started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../guide/About.html"><strong aria-hidden="true">1.1.</strong> About Kind</a></li><li class="chapter-item expanded "><a href="../../guide/Installation.html"><strong aria-hidden="true">1.2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../../cli/World.html"><strong aria-hidden="true">1.3.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="../../cli/kind.html"><strong aria-hidden="true">1.4.</strong> Hello Kind!</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Book</li><li class="chapter-item expanded "><a href="../../Book/chapter_02/2,1.html"><strong aria-hidden="true">2.</strong> Basics: Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Book/chapter_02/2,2.html"><strong aria-hidden="true">2.1.</strong> Enumerated Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Book/chapter_02/2,2,1.html"><strong aria-hidden="true">2.1.1.</strong> Days of the Week</a></li></ol></li><li class="chapter-item expanded "><a href="../../Book/chapter_02/2,3.html"><strong aria-hidden="true">2.2.</strong> Booleans</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_02/2,4.html"><strong aria-hidden="true">2.3.</strong> Function Types</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_02/2,5.html"><strong aria-hidden="true">2.4.</strong> Modules</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_02/2,6.html"><strong aria-hidden="true">2.5.</strong> Numbers</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_02/2,7.html"><strong aria-hidden="true">2.6.</strong> Proof by Simplification</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_02/2,8.html"><strong aria-hidden="true">2.7.</strong> Proof by Application</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_02/2,9.html"><strong aria-hidden="true">2.8.</strong> Proof by Case Analysis</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_02/2,10.html"><strong aria-hidden="true">2.9.</strong> Proof by Rewriting</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_02/2,11.html"><strong aria-hidden="true">2.10.</strong> Equal.chain and Equal.mirror</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_02/2,12.html"><strong aria-hidden="true">2.11.</strong> More Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="../../Book/chapter_03/3.html"><strong aria-hidden="true">3.</strong> Induction: Proof by Induction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Book/chapter_03/3,1.html"><strong aria-hidden="true">3.1.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_03/3,2.html"><strong aria-hidden="true">3.2.</strong> More Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="../../Book/chapter_04/4.html"><strong aria-hidden="true">4.</strong> Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Book/chapter_04/4,1.html"><strong aria-hidden="true">4.1.</strong> Lists of Numbers</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_04/4,2.html"><strong aria-hidden="true">4.2.</strong> Reasoning about Lists</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_04/4,3.html"><strong aria-hidden="true">4.3.</strong> Maybe</a></li></ol></li><li class="chapter-item expanded "><a href="../../Book/chapter_05/5.html"><strong aria-hidden="true">5.</strong> Polymorphism</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Book/chapter_05/5,1.html"><strong aria-hidden="true">5.1.</strong> Functions as Data</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_05/5,2.html"><strong aria-hidden="true">5.2.</strong> Additional Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="../../Book/chapter_06/6.html"><strong aria-hidden="true">6.</strong> Logic in Kind</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Book/chapter_06/6,1.html"><strong aria-hidden="true">6.1.</strong> Logical Connectives</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_06/6,2.html"><strong aria-hidden="true">6.2.</strong> Falsehood and Negation</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_06/6,3.html"><strong aria-hidden="true">6.3.</strong> Truth, Equivalence, and Quantification</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_06/6,4.html"><strong aria-hidden="true">6.4.</strong> Programming with Propositions</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_06/6,5.html"><strong aria-hidden="true">6.5.</strong> Applying Theorems to Arguments</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_06/6,6.html"><strong aria-hidden="true">6.6.</strong> Kind vs Set Theory</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_06/6,7.html"><strong aria-hidden="true">6.7.</strong> Classical vs. Constructive Logic</a></li></ol></li><li class="chapter-item expanded "><a href="../../Book/chapter_07/7.html"><strong aria-hidden="true">7.</strong> Inductively Defined Propositions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Book/chapter_07/7.1.html" class="active"><strong aria-hidden="true">7.1.</strong> Using Evidence in Proofs</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_07/7.2.html"><strong aria-hidden="true">7.2.</strong> Inductive Relations</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_07/7.3.html"><strong aria-hidden="true">7.3.</strong> Case Study: Regular Expressions</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_07/7.4.html"><strong aria-hidden="true">7.4.</strong> Case Study: Improving Reflection</a></li><li class="chapter-item expanded "><a href="../../Book/chapter_07/7.5.html"><strong aria-hidden="true">7.5.</strong> Additional Exercises</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../../Contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="using-evidence-in-proofs"><a class="header" href="#using-evidence-in-proofs">Using Evidence in Proofs</a></h2>
<p>In addition to constructing evidence that numbers are even, we can also reason about such evidence. Introducing Ev with a data statement tells <em>Kind</em> not only that the constructors <code>ev_z</code> and <code>ev_ss</code> are valid ways to construct evidence that a number is even, but also that these two constructors are the only ways to construct evidence that numbers are even (in the sense of <em>Ev</em>).</p>
<p>In other words, if someone gives us evidence and claims it to be of the form <code>Ev n</code>, then we know that e must have one of two forms:</p>
<ul>
<li><code>e</code> is <code>ev_z</code> (and <em>n</em> is <em>Nat.zero</em>), or</li>
<li><code>e</code> is <code>ev_ss</code> applied to induction with <code>n</code> and it is equal to the successor of the successor of <code>n</code>*.</li>
</ul>
<h6 id="weve-already-used-this-strategy-before-remember-the-problemst3-exercise-from-the-induction-chapter-here-the-difference-is-that-theres-only-one-more-natsucc-in-our-induction"><a class="header" href="#weve-already-used-this-strategy-before-remember-the-problemst3-exercise-from-the-induction-chapter-here-the-difference-is-that-theres-only-one-more-natsucc-in-our-induction"><em>We've already used this strategy before, remember the Problems.t3 exercise from the induction chapter, here the difference is that there's only one more &quot;Nat.succ&quot; in our induction</em></a></h6>
<p>This suggests that it should be possible to analyze a hypothesis of the form <code>Ev n</code> in the same way we do with data structures defined inductively; in particular, it should be possible to argue by <em>induction</em> and <em>case analysis</em> on this evidence. Let's see some examples to understand what this means in practice.</p>
<h3 id="pattern-matching-on-evidence"><a class="header" href="#pattern-matching-on-evidence">Pattern Matching on Evidence</a></h3>
<p>Suppose we are proving some fact involving a number n and we are given the hypothesis <code>Ev n</code>. We already know how to perform <em>case analysis</em> on <code>n</code> using the inversion tactic, generating separate subgoals for the case where <code>n = Nat.zero</code> and the case where <code>n = Nat.succ n</code> for some <code>n</code>. But for some proofs, we may want to directly analyze the evidence that <code>Ev n</code> is true.</p>
<p>By the definition of Ev, there are two cases to consider:</p>
<ul>
<li>If the evidence is of the form <code>ev_z</code>,  we know that <code>n = Nat.zero</code>.</li>
<li>Otherwise, the evidence must have the form <code>ev_ss n e</code>, where <code>n = Nat.succ (Nat.succ n)</code> and <code>e</code> is the evidence for <code>Ev n</code>.</li>
</ul>
<p>We can reason about this kind of pattern matching in Kind, again using <em>pattern matching</em>. In addition to allowing us to reason about equalities involving constructors, inversion provides a principle of case analysis for propositions defined inductively. <!-- Quando usada dessa forma, sua sintaxe é semelhante à da função destruct: passamos a ela uma lista de identificadores separados por caracteres | para nomear os argumentos de cada um dos possíveis construtores.--></p>
<pre><code class="language-rust ignore">Ev_minus2 (n: Nat) (e: Ev n) : Ev (Nat.pred (Nat.pred n))
Ev_minus2 Nat.zero e = e
Ev_minus2 (Nat.succ Nat.zero) e = Ev.ev_z
Ev_minus2 (Nat.succ (Nat.succ n)) (Ev.ev_ss e) = e</code></pre>
<p>In words, here is how the pattern matching reasoning works in this proof:</p>
<ul>
<li>If the evidence is of the form <code>ev_z</code>, we know that <code>n = Nat.zero</code>. Therefore, it is sufficient to show that <code>Ev (Nat.pred (Nat.pred Nat.zero))</code> is valid. By the definition of <code>Nat.pred</code>, this is equivalent to showing that <code>Ev Z</code> is valid, which follows directly from <code>ev_0</code>.</li>
<li>Otherwise, the evidence must have the form  <code>ev_ss n e</code>, where <code>n = Nat.succ (Nat.succ n)</code> and <code>e</code> is the evidence for <code>Ev n</code>. We must then show that <code>Ev (Nat.pred (Nat.pred (Nat.succ (Nat.succ n))))</code> is valid, which, after simplification, follows directly from <code>e</code>.</li>
</ul>
<pre><code class="language-rust ignore">Evss_ev (n: Nat) (e: Ev (Nat.succ (Nat.succ n))) : Ev n</code></pre>
<p>Intuitively, we know that the evidence for the hypothesis cannot consist solely of the constructor <code>ev_z</code>, since <code>Nat.zero</code> and <code>Nat.succ</code> are different constructors of the type Nat; therefore, <code>ev_ss</code> is the only applicable case. Unfortunately, <em>pattern matching</em> is not smart enough to realize this and still generates two subgoals. Even worse, by doing so, it leaves the final goal unchanged, failing to provide any useful information to complete the proof.</p>
<p>The inversion tactic, on the other hand, can detect (1) that the first case does not apply and (2) that the n appearing in the Ev_SS case must be the same as n. This allows us to conclude the proof.</p>
<pre><code class="language-rust  ignore">Evss_ev n (Ev.ev_ss e) = e </code></pre>
<p>Using dependent pattern matching, we can also apply the principle of explosion to &quot;obviously contradictory&quot; hypotheses involving inductive properties. For example:</p>
<pre><code class="language-rust  ignore">One_not_even : Not (Ev 1n)
</code></pre>
<h3 id="inversion_practice"><a class="header" href="#inversion_practice">Inversion_practice</a></h3>
<p>Prove the following results using pattern matching.</p>
<pre><code class="language-rust  ignore">Ssssev__even (n: Data.Nat) (e: Ev (Data.Nat.succ (Data.Nat.succ (Data.Nat.succ (Data.Nat.succ n))))) : Ev n
Ssssev__even n e = ?

Even5_nonsense (e: Ev 5n) : Prop.Equal (Data.Nat.add 2n 2n) 9n
Even5_nonsense e = ?</code></pre>
<p>The way we use inversion here may seem a bit mysterious at first. So far, we have only used inversion on equality propositions to make use of the injectivity of constructors or to discriminate between different constructors. But we see here that inversion can also be applied to analyze evidence of inductively defined propositions.</p>
<p>Here is how inversion works in general. Suppose the name <strong>I</strong> refers to an assumption <strong>P</strong> in the current context, where <strong>P</strong> was defined by an Inductive statement. Then, for each of the constructors of <strong>P</strong>, inversion of <strong>I</strong> generates a subgoal in which <strong>I</strong> has been replaced by the exact and specific conditions under which this constructor could have been used to prove <strong>P</strong>. Some of these subgoals will be self-contradictory; inversion discards those. The ones that are left represent the cases that must be proven to establish the original goal. For these, inversion adds all the equations to the proof context that must hold true for the arguments supplied to <strong>P</strong> (e.g., <code>Nat.succ (Nat.succ k) = n</code> in the proof of evSS_ev).</p>
<p>The exercise ev_double above shows that our new notion of evenness is implied by the two previous ones (since, by even_bool_prop in the Logic chapter, we already know they are equivalent to each other). To show that the three coincide, we just need the following lemma:</p>
<pre><code class="language-rust  ignore">Ev_even
  (n: Nat)
  (e: Ev n) :
  (Sigma Nat (k =&gt; Prop.Equal n (Nat.double k)))
Ev_even n e = ?</code></pre>
<p>We proceed by case analysis on Ev n. The first case can be resolved trivially.</p>
<pre><code class="language-rust  ignore">Ev_even Nat.zero e = Sigma.new 0n Equal.refl</code></pre>
<p>Unfortunately, the second case is more challenging. We need to show <code>[k: Nat] -&gt; (Equal (Nat.succ (Nat.succ n')) (Nat.double k))</code>, but the only assumption available is <code>e'</code>, which states that <code>Ev n'</code> is true. Since this is not directly useful, it seems like we are stuck and that the case analysis on <code>Ev n</code> was a waste of time.</p>
<pre><code class="language-rust  ignore">Ev_even (Nat.succ Nat.zero) e = Empty.absurd _ //todo</code></pre>
<p>If we take a closer look at our second goal, however, we can see that something interesting happened: by performing case analysis on <code>Ev n</code>, we were able to reduce the original result to a similar one that involves a different evidence for <code>Ev n: e'</code>. More formally, we can conclude our proof by showing that</p>
<pre><code class="language-rust  ignore">Ev_even (Nat.succ (Nat.succ n)) (Ev.ev_ss e) = Ev_even_ss n (Ev_even n e)</code></pre>
<p>which is the same as the original statement, but with <code>n'</code> instead of <code>n</code>. In fact, it is not difficult to convince Kind that this intermediate result is sufficient.</p>
<pre><code class="language-rust  ignore">Ev_even (Nat.succ (Nat.succ n)) (Ev.ev_ss e) = Ev_even_ss n (Ev_even n e)</code></pre>
<h3 id="induction-on-evidence"><a class="header" href="#induction-on-evidence">Induction on Evidence</a></h3>
<p>If this seems familiar, it's no coincidence: we encountered similar problems in the Induction chapter when trying to use case analysis to prove results that required induction. And once again, the solution is... induction!</p>
<!--TL:DR O comportamento da indução sobre evidências é o mesmo que o seu comportamento sobre dados: 
ela faz com que o Kind gere uma submeta para cada construtor que poderia ter sido usado para construir aquela evidência, ao mesmo tempo em que fornece uma hipótese de indução para cada ocorrência recursiva da propriedade em questão. -->
<p>Let's try our current lemma again:</p>
<pre><code class="language-rust  ignore">Ev_even
  (n: Nat)
  (e: Ev n) :
  (Sigma Nat(k =&gt; Equal n ( Nat.double k)))
Ev_even Nat.zero e = Sigma.new 0n Equal.refl
Ev_even (Nat.succ Nat.zero) e = Empty.absurd _
Ev_even (Nat.succ (Nat.succ n)) (Ev.ev_ss e) = Ev_even_ss n (Ev_even n e)
// Ev_even (Nat.succ (Nat.succ n)) Ev.ev_z = Caso impossível</code></pre>
<!--TL:DR
Aqui, podemos ver que o Kind produziu uma HI que corresponde a E', a única ocorrência recursiva de ev em sua própria definição. Como E' menciona n', a hipótese de indução fala sobre n', em oposição a n ou algum outro número. -->
<p>The equivalence between the second and third definitions of evenness now follows.</p>
<pre><code class="language-rust ignore">
Ev_even_equiv (n: Nat)  : Equivalence (Ev n) (Sigma Nat (k =&gt; Equal n (Nat.double k)))
Ev_even_equiv n         = Equivalence.new (x =&gt; Ev_even n x) (y =&gt; From_eee n y)

From_eee (n: Nat) (s: Sigma Nat (k =&gt; Equal n (Nat.double k))) : Ev n
From_eee n (Sigma.new a b fst snd) =
  Equal.rewrite (Equal.mirror (specialize b into #0 in snd)) (x =&gt;(Ev x)) (Ev_double fst)

Ev_double (n: Nat)      : Ev (Nat.double n)
Ev_double Nat.zero      = Ev.ev_z
Ev_double (Nat.succ n)  = Ev.ev_ss (Ev_double n)
</code></pre>
<p>As we will see in the upcoming chapters, induction on evidence is a recurring technique in various areas, especially in the formalization of programming language semantics, where many properties of interest are defined inductively.</p>
<p>The following exercises provide simple examples of this technique to help you become familiar with it.</p>
<h4 id="ev_sum"><a class="header" href="#ev_sum">Ev_sum</a></h4>
<pre><code class="language-rust ignore">Ev_sum (n: Nat) (m: Nat) (e1: Ev n) (e2: Ev m) : Ev (Nat.add n m)
Ev_sum n m e1 e2 = ?
</code></pre>
<h4 id="ev_alternate"><a class="header" href="#ev_alternate">Ev_alternate</a></h4>
<p>In general, there can be multiple ways to define a property inductively. For example, here is an alternative (somewhat forced) definition for Ev:</p>
<pre><code class="language-rust ignore">type Evn ~ (n: Nat){
  z : Evn Nat.zero
  d : Evn (Nat.succ (Nat.succ Nat.zero))
  sum &lt;n : Nat&gt; &lt;m: Nat&gt; (evn: Evn n) (evm: Evn m) : Evn (Nat.add n m)
} </code></pre>
<p>Prove that this definition is logically equivalent to the old one. (You may want to refer to the previous theorem when you reach the induction step.)</p>
<pre><code class="language-rust ignore">Ev_evn (n: Nat): Equivalence (Ev n) (Evn n)
Ev_evn n = ?
</code></pre>
<h4 id="ev_ev__ev"><a class="header" href="#ev_ev__ev">Ev_ev__ev</a></h4>
<p>Finding the appropriate thing to induct on is a bit tricky here:</p>
<pre><code class="language-rust ignore">
Ev_ev_ev (n: Nat) (m: Nat) (e: Ev (Nat.add n m)) (en: Ev n) : Ev m
Ev_ev_ev Nat.zero m e en = ?</code></pre>
<h4 id="ev_plus_plus"><a class="header" href="#ev_plus_plus">Ev_plus_plus</a></h4>
<p>This exercise only requires the application of existing lemmas. No induction or even case analysis is needed, although some of the rewrites may be tedious.</p>
<pre><code class="language-rust ignore">Ev_pp 
  &lt;n: Nat&gt; 
  &lt;m: Nat&gt; 
  &lt;p: Nat&gt; 
  (e1: Ev (Nat.add n m))
  (e2: Ev (Nat.add n p))
  : Ev (Nat.add m p)
Ev_pp Nat.zero m p e1 e2 =
``</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../Book/chapter_07/7.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../Book/chapter_07/7.2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../Book/chapter_07/7.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../Book/chapter_07/7.2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
