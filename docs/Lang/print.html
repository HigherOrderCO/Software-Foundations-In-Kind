<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="Welcome.html">A Kind Welcome!</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="Guide/About.html"><strong aria-hidden="true">1.</strong> About Kind</a></li><li class="chapter-item expanded "><a href="Guide/Learning.html"><strong aria-hidden="true">2.</strong> Learning Kind Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Guide/Terminal.html"><strong aria-hidden="true">2.1.</strong> Terminal</a></li><li class="chapter-item expanded "><a href="Guide/Installation.html"><strong aria-hidden="true">2.2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="Guide/IDE.html"><strong aria-hidden="true">2.3.</strong> Text Editors</a></li><li class="chapter-item expanded "><a href="Guide/Hello.html"><strong aria-hidden="true">2.4.</strong> Hello Kind!</a></li></ol></li><li class="chapter-item expanded "><a href="Basic/Basics.html"><strong aria-hidden="true">3.</strong> Kind Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Basic/Types.html"><strong aria-hidden="true">3.1.</strong> Types</a></li><li class="chapter-item expanded "><a href="Basic/Constructors.html"><strong aria-hidden="true">3.2.</strong> Constructors</a></li><li class="chapter-item expanded "><a href="Basic/Functions.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="Basic/TypeChecker.html"><strong aria-hidden="true">3.4.</strong> Type Checker</a></li><li class="chapter-item expanded "><a href="Basic/Examples/Examples.html"><strong aria-hidden="true">3.5.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Basic/Examples/Basic.html"><strong aria-hidden="true">3.5.1.</strong> Type Examples</a></li><li class="chapter-item expanded "><a href="Basic/Examples/Constructors.html"><strong aria-hidden="true">3.5.2.</strong> Constructors Examples</a></li><li class="chapter-item expanded "><a href="Basic/Examples/Function.html"><strong aria-hidden="true">3.5.3.</strong> Function Examples</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">Voyage</li><li class="chapter-item expanded "><a href="Voyage/Voyage.html"><strong aria-hidden="true">4.</strong> A Kind Voyage!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Voyage/Constructors.html"><strong aria-hidden="true">4.1.</strong> Constructors with Value</a></li><li class="chapter-item expanded "><a href="Voyage/Polymorphic.html"><strong aria-hidden="true">4.2.</strong> Polymorphic Types</a></li><li class="chapter-item expanded "><a href="Voyage/Accessing.html"><strong aria-hidden="true">4.3.</strong> Accessing Constructor Values</a></li><li class="chapter-item expanded "><a href="Voyage/Functions.html"><strong aria-hidden="true">4.4.</strong> More about Functions</a></li><li class="chapter-item expanded "><a href="Voyage/Examples/Examples.html"><strong aria-hidden="true">4.5.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Voyage/Examples/Maybe_Pair_Basics.html"><strong aria-hidden="true">4.5.1.</strong> Maybe and Pair Basics</a></li><li class="chapter-item expanded "><a href="Voyage/Examples/Maybe_Pair_Variation.html"><strong aria-hidden="true">4.5.2.</strong> Maybe and Pair</a></li><li class="chapter-item expanded "><a href="Voyage/Examples/Intermediate_Types.html"><strong aria-hidden="true">4.5.3.</strong> Intermediate Types</a></li><li class="chapter-item expanded "><a href="Voyage/Examples/Intermediate_Funtions.html"><strong aria-hidden="true">4.5.4.</strong> Intermediate Functions</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">Discovery</li><li class="chapter-item expanded "><a href="Discovery/Discovery.html"><strong aria-hidden="true">5.</strong> A Kind Discovery!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Discovery/Currying.html"><strong aria-hidden="true">5.1.</strong> Currying</a></li><li class="chapter-item expanded "><a href="Discovery/Numbers.html"><strong aria-hidden="true">5.2.</strong> Natural Numbers</a></li><li class="chapter-item expanded "><a href="Discovery/Recursive.html"><strong aria-hidden="true">5.3.</strong> Recursive Algorithms</a></li><li class="chapter-item expanded "><a href="Discovery/Examples/Syntax.html"><strong aria-hidden="true">5.4.</strong> Syntax Sugar</a></li><li class="chapter-item expanded "><a href="Discovery/Examples/Sugar.html"><strong aria-hidden="true">5.5.</strong> Sugar</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="Contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="a-kind-welcome"><a class="header" href="#a-kind-welcome">A Kind Welcome</a></h1>
<p>To an efficient, minimal, and practical language, that aims to rethink functional programming from the scratch, with a modern and consistent design.</p>
<h2 id="navigation"><a class="header" href="#navigation">Navigation</a></h2>
<p>The goal of this documentation is to be as simple as it is to learn Kind. Therefore, we decided to adopt a minimalist and simple design, so you can promptly find what you need.</p>
<h2 id="fast-navigation-index"><a class="header" href="#fast-navigation-index">Fast navigation index</a></h2>
<ul>
<li><a href="./Guide/About.html">About Kind</a>;</li>
<li>Installation Guide for <a href="./Guide/Installation.html#linux-or-macos">MacOS</a>, <a href="./Guide/Installation.html#linux-or-macos">Linux</a> and <a href="./Guide/Installation.html#Windows">Windows</a>;</li>
<li><a href="./Guide/Learning.html">Learning Kind Basics</a> ;</li>
<li><a href="https://app.gitbook.com/o/f5pmVKXE0zdcMOu6WXHf/s/MAbwOd8IAba3qXSYTi00/">Reference Material</a>;</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-kind"><a class="header" href="#about-kind">About Kind</a></h1>
<p>Kind aims to be more practical and conventional-like as a language. It is statically typed, and its types are so powerful that you can even prove mathematical theorems with them.</p>
<p>A possible description for Kind is to imagine it as the Universe when you try to capture an image of it from the outside. When you create a new file in Kind, it's like the whole Universe is there except the piece you're looking for is not specified.</p>
<p>Ok, it is weird to think about the universe from the outside, it can get a bit confusing, so let's use a little story to better understand it:</p>
<p><em>We are Astronauts, Kind Astronauts. One day, in this fruitful little exploration, our spaceship comes across a planet that already has a name: &quot;Boolean Logics&quot;. In this planet, we discover the functions &quot;AND&quot;, &quot;NOT&quot; and &quot;OR&quot;, and then decide to formally prove those beings. With all proved and documented, we have a hard time finding another Boolean logic function. Therefore, by thinking &quot;our job is done&quot;, we jump back into the Kind Spaceship to look for new planets to explore.</em></p>
<p><em>Nonetheless, a few days later there are news all over the universe, people are talking about other new types of functions discovered in planet Boolean Logics: &quot;XOR&quot;, &quot;NAND&quot;  and &quot;XNOR&quot;. Just before our departure from the planet, another Kind astronaut arrived there and encountered those new functions.</em></p>
<p><em>Even with all the work, we couldn't find those functions the other astronaut did. But they were there. So, just because a function has not been discovered yet, it doesn't mean that it didn't exist before.</em></p>
<p>Above, the <a href="https://en.wikipedia.org/wiki/Boolean_data_type">Boolean</a> Type is used to better elucidate our example. It is like a planet in our Universe, and its Definitions and Functions are the Biome and Ecosystem from the planet.</p>
<p>This Kind Universe is as big as your imagination, in fact, it is probably bigger than that. There are endless planets, ecosystems and biomes to explore. With that in mind, would you like to become a Kind Astronaut and embark in this fun (and not that perilous) adventure with many other astronauts?</p>
<p>If you don't like the idea of exploring the Universe, it's okay, we could use another analogy, a shorter and easy one. Just imagine Kind Lang as a Book Recipe, an empty one, with an endless amount of ingredients, and as long as you can find recipes you can write in the recipe book for other people to use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-kind-basics"><a class="header" href="#learning-kind-basics">Learning Kind Basics</a></h1>
<p>A quick guide for new recruits.</p>
<p>If this is your first time studying Kind, it may take some time to get used with its syntax and other details. So, before exploring this vast Universe, take a look in these eight topics:</p>
<ul>
<li><a href="Guide/./Terminal.html">Terminal</a>;</li>
<li><a href="Guide/./Installation.html">Installation</a>;</li>
<li><a href="Guide/./IDE.html">Text Editors</a>;</li>
<li><a href="Guide/./Hello.html">Hello Kind!</a> (A Hello Kind Guide);</li>
<li><a href="Guide/../Basic/Types.html">Types</a> - Part 1;</li>
<li><a href="Guide/../Basic/Constructors.html">Constructors</a> - Part 1;</li>
<li><a href="Guide/../Basic/Functions.html">Functions</a> - Part 1;</li>
<li><a href="Guide/../Basic/TypeChecker.html">Type Checker</a>;</li>
</ul>
<p>They are necessary to better understand deeper contexts as we proceed towards our goal. After some preparation to start the journey, you'll have a first contact with the basic about Functions and how to build some of them, Boolean Logics, working with Bool types and constructors.</p>
<p>This learning method was tested before with many other Kind Astronaut Recruits, generating data about the best outcome and learning curve. Hoping that you feel comfortable with this approach, welcome to Kind Basics!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminal"><a class="header" href="#terminal">Terminal</a></h1>
<p>The exploration is not terminating, we are just getting started.</p>
<p>If you already know how to work with terminals, skip to the <a href="Guide/./Installation.html">Installation</a> step.</p>
<h2 id="what-is-a-terminal"><a class="header" href="#what-is-a-terminal">What is a Terminal</a></h2>
<p>A terminal can be described as an interface for users to communicate with the computer.</p>
<p>They are our command-line interface, a place where we type commands and the computer process it.</p>
<p>Let's open our terminal:</p>
<h3 id="opening-the-terminal-on-linux"><a class="header" href="#opening-the-terminal-on-linux">Opening the terminal on Linux</a></h3>
<p>TODO</p>
<h3 id="opening-the-terminal-on-windows-wsl2"><a class="header" href="#opening-the-terminal-on-windows-wsl2">Opening the terminal on Windows (WSL2)</a></h3>
<p>TODO</p>
<h3 id="opening-the-terminal-on-macos"><a class="header" href="#opening-the-terminal-on-macos">Opening the terminal on MacOS</a></h3>
<p>TODO</p>
<h3 id="opening-the-terminal-on-windows"><a class="header" href="#opening-the-terminal-on-windows">Opening the terminal on Windows</a></h3>
<p>TODO</p>
<p>if you are using Linux or Windows your terminal would probably look like this:</p>
<p>If you are using MacOS your terminal would probably like this:</p>
<p>You can customize your terminal the way you want and feel most comfortable with.</p>
<p>Command-lines in a terminal follow a &quot;left to right&quot; hierarchy, the left side always come first and the computer interprets them in this order.</p>
<p>Before explaining terminal commands to you, there is a very important command that you need to understand, the sudo command. sudo is the abbreviation of &quot;super user do&quot; that, when used, allows a user to get privileges of another user (usually the super user) to securely perform specific tasks within the system in a administrator controllable manner. You will need to use the sudo command in a lot of cases.</p>
<h2 id="terminal-commands"><a class="header" href="#terminal-commands">Terminal Commands</a></h2>
<p>When double clicking a folder in order to open it, your computer basically understand and does the <code>cd folder</code> command; the same happens when renaming a file, the computer will understand it as using the command <code>mv oldfilename.kind2</code> <code>newfilename.kind2</code>.</p>
<p>The terminal is simply a command line where you type those commands directly to your computer. As this is extensively used in this guide book, it is recommended that you get familiar with this by playing with the commands below (just be careful with some of them, like rm).</p>
<p>For now, let's take a look at a few of the most used terminal commands. Even though everything that is used in this guide will be explained, if you want to dive deeper into terminal commands, look up to this this <a href="https://www.git-tower.com/blog/command-line-cheat-sheet/">link</a>.</p>
<h3 id="list-of-commands"><a class="header" href="#list-of-commands">List of Commands</a></h3>
<pre><code>cd
ls
mkdir
rm
mv
touch
clear
</code></pre>
<h4 id="directory-related-commands"><a class="header" href="#directory-related-commands">Directory related commands</a></h4>
<ul>
<li>The command <code>cd</code> stands for &quot;Change Directory&quot;, and it navigates through them.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Command                </th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>cd</code></td><td style="text-align: left"><code>Home</code>: Goes back to your base folder (main folder).</td></tr>
<tr><td style="text-align: left"><code>cd ..</code></td><td style="text-align: left"><code>Back</code>: Moves to the previous folder.</td></tr>
<tr><td style="text-align: left"><code>cd 'folderName'</code></td><td style="text-align: left"><code>Through Files</code>: Will take you to that folder specified.</td></tr>
</tbody></table>
</div><!-- ##### Home

The `cd` command goes back to your base folder (main folder).

##### Back

The `cd ..` command, moves to the previous folder.

##### Through files

The `cd 'folderName'`  command will take you to that folder specified. -->
<ul>
<li>The command <code>ls</code> stands for &quot;List Files&quot;, and lists the content of the current folder.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Command                </th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ls</code></td><td style="text-align: left"><code>Listing</code>: Will show you a list of the files and folders </br> in the current folder that you are in.</td></tr>
<tr><td style="text-align: left"><code>ls -la</code></td><td style="text-align: left"><code>Deeper Listing</code>: Will show a more detailed version of </br> the ls command, with it's hidden files or folders.</td></tr>
</tbody></table>
</div><!-- ##### Listing

The ``ls`` command, by itself, Will show you a list of the files and folders in the current folder that you are in.

##### Deeper Listing

The ``ls -la`` command will show a more detailed version of the ls command, with it's hidden files or folders (and there are a lot of them in your computer). -->
<ul>
<li>The command <code>mkdir</code> , that stands for &quot;Make Directory&quot;, creates a new folder.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Command              </th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>mkdir folderName</code></td><td style="text-align: left"><code>Creating</code>: Works by creating a folder with the specified</br>  name. For example:</br><code>mkdir exampleFolder</code> creates it with the name </br> &quot;exampleFolder&quot;</td></tr>
</tbody></table>
</div><!-- ##### Creating

The ``mkdir folderName`` command works by creating a folder with the specified name.
For example:
``mkdir exampleFolder`` creates it with the name "exampleFolder". -->
<h4 id="file-related-commands"><a class="header" href="#file-related-commands">File related commands</a></h4>
<ul>
<li>The command rm stands for &quot;Remove&quot;, and removes the specified file or folder.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Command                 </th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>rm fileName</code></td><td style="text-align: left"><code>Removing Files</code>: Removes the file specified in it.</td></tr>
<tr><td style="text-align: left"><code>rm -r folderName</code></td><td style="text-align: left"><code>Removing Folders</code>: Removes a folder in the same way </br> as  mkdir creates it, you need to specify which </br> folder you want to remove.</td></tr>
</tbody></table>
</div><!-- ##### Removing Files

The ``rm fileName`` command removes the file specified in it. For example: 
``rm testFile.kind2``removes the file with named testFile.kind2.

##### Removing Folders
The ``rm -r 'folderName'`` command removes a folder in the same way as mkdir creates it, you need to specify which folder you want to remove. For example: 
``rm -r testFolder`` removes a folder named "testFolder". -->
<ul>
<li>
<ul>
<li><em>This command is <strong>VERY DANGEROUS!</strong> If possible, <strong>DO NOT USE IT</strong>, there are a lot of memes on the internet from people using rm to delete important folders. Avoid everything that has the rm command on internet, otherwise, use it by your own discretion and responsibility!</em></li>
</ul>
</li>
<li>
<p>The command <code>mv</code>stands for &quot;Move&quot;, and has two functionalities, to move and rename files or folders.</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Command</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>mv fileName /folderName</code></td><td style="text-align: left"><code>Moving things</code>: Using command moves the fileName </br> file to the folderName folder. In order for this command</br> to work, it is needed to write the file name </br> followed by the name of the directory that you want to</br> send the file to. For example: </br><code>mv kindFile.kind2 /newDirectory</code> to move a file to a </br>  folder inside the current folder.</br><code>mv kindFile.kind2 ../folderName</code>  to take a file to a </br> folder in a previous folder by using &quot;../&quot; before the name </br>of the folder.</td></tr>
<tr><td style="text-align: left"><code>mv oldFileName newFileName</code></td><td style="text-align: left"><code>Renaming things</code>: The command changes the name of a </br> file or folder to the name specified in the second </br> parameter. For example:</br><code>mv oldName.kind2 newName.kind2</code> to rename a file from </br> &quot;oldName.kind2&quot; to &quot;newName.kind2&quot;.</br><code>mv oldKindFolder newKindFolder</code> to rename a folder </br> from &quot;oldKindFolder&quot; to &quot;newKindFolder&quot;.</td></tr>
</tbody></table>
</div>
<ul>
<li>The command touch can do a couple of complicated things, such as update file access and it's modification time. But, right now we are only gonna use it to create new files.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Command                 </th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>touch</code></td><td style="text-align: left"><code>Creating Flies</code>: The command creates (if this file do </br> not exists yet) a new file. For example:</br> <code>touch newfile.kind2</code> will create a .kind2 file with the </br> specified  name.</td></tr>
</tbody></table>
</div>
<h4 id="output-related-command"><a class="header" href="#output-related-command">Output related command</a></h4>
<ul>
<li>The command clear will clear your command line.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Command                 </th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>clear</code></td><td style="text-align: left"><code>Cleaning up the mess</code>: The command will clear the </br>command line window. Use it when your terminal is </br>just a giant text wall and you will have a fresh new </br>terminal. It's very refreshing,</br> trust me!.</td></tr>
</tbody></table>
</div>
<p>The command will clear the command line window. Use it when your terminal is just a giant text wall and you will have a fresh new terminal. It's very refreshing, trust me!</p>
<p>With this basic commands, proceed to the <a href="Guide/./Installation.html">Kind Installation</a>, as we are using the terminal to do so. If you already have Kind installed in your computer, proceed to the section <a href="Guide/./IDE.html">Text Editors</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Prepare your spaceship carefully.</p>
<p>This guide teaches how to download and install Kind through Rust, using <code>Cargo</code>, a tool used for managing packages. It may be necessary to have an internet connection to proceed with this guide.</p>
<p>First, install Rust using this <a href="https://www.rust-lang.org/tools/install">link</a>.</p>
<ul>
<li><em>Currently, <code>Cargo</code> is the only way to install Kind.</em></li>
<li><em>This guide was written when Kind was in the beta version, so it is necessary to install the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly</a> channel version.</em></li>
</ul>
<h3 id="linux-or-macos"><a class="header" href="#linux-or-macos">Linux or MacOS</a></h3>
<p>Use your package manager (Cargo) to install Kind. To do so, open the terminal and type the following code:</p>
<pre><code>cargo +nightly install kind2
</code></pre>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>For Windows users, it is possible to use Kind through CMD or WSL2. If you choose WSL, the installation method is in this <a href="https://harsimranmaan.medium.com/install-and-setup-rust-development-environment-on-wsl2-dccb4bf63700">link</a>.</p>
<p>Use your package manager (Cargo) to install Kind. To do so, open Bash (WSL2) or Terminal (CMD) and type the following command:</p>
<pre><code>cargo +nightly install kind2
</code></pre>
<h3 id="cloning-the-kind-repository---method-1"><a class="header" href="#cloning-the-kind-repository---method-1">Cloning the Kind Repository - Method 1</a></h3>
<p>Clone the Kind repository using the &quot;git clone&quot; command, as follows:</p>
<pre><code>git clone https://github.com/HigherOrderCO/Kind
</code></pre>
<p>After the cloning step, use the following command for installation:</p>
<pre><code>cargo +nightly install --path crates/kind-cli --force
</code></pre>
<h3 id="cloning-the-kind-repository---method-2"><a class="header" href="#cloning-the-kind-repository---method-2">Cloning the Kind Repository - Method 2</a></h3>
<p>Cargo allows you to install using git, without the need to clone any repository, as follows:</p>
<pre><code>cargo +nightly install --git https://github.com/HigherOrderCO/Kind.git
</code></pre>
<p>By following the above steps, we can start using Kind.</p>
<p>Now, let's proceed to <a href="Guide/./IDE.html">Text Editors</a> and finish preparing our spaceship for exploration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-editors"><a class="header" href="#text-editors">Text Editors</a></h1>
<p>For the VVim!</p>
<ul>
<li><em>If you already know what a Text Editor is, and already has your own favorite, proceed to the <a href="Guide/./Hello.html">Hello Kind!</a> section. Otherwise, this page will be very helpful.</em></li>
</ul>
<h2 id="what-is-a-text-editor"><a class="header" href="#what-is-a-text-editor">What is a Text Editor?</a></h2>
<p>It is basically a type of computer software that edits pain text.</p>
<p>When having the first contact with codes and program skills, skimming through different types of programming languages on the internet is very easy. But something may be missing there, so you start to ask yourself things like &quot;How am i going to code?&quot; and &quot;Where am I going to write those codes?&quot;. And it probably is not clear yet. So this guide will try to help you in each and every step of this journey. Coding is meant to be fun, seriously!</p>
<p>First things first, before thinking about which programming language you want to learn (Probably, since you are here, that language is Kind) let's think about which Text Editor to use.</p>
<p>There are actually a lot of them, each one has it's own pros and cons, and probably the best way to choose is by testing them. In <a href="https://kinsta.com/blog/best-text-editors/">This blog</a>, there are 13 different types of Text Editors to look.</p>
<p>But, if you don't want to spend too much time searching an &quot;ideal Text Editor&quot;, it is strongly recommend you to start with <a href="https://code.visualstudio.com/">Visual Studio Code</a>.
&quot;VS Code&quot; is the most popular text editor with the most integrations and syntax highlighting extensions that you can find out there. It's fairly simple to use, and there's a lot of tutorials on &quot;how to use it better&quot; on the internet.</p>
<p>Even so, this is just a recommendation, fell free to choose and use anyone of them.</p>
<p>Now that we have picked our text editor, let's start coding. And as usual, start by doing a <a href="Guide/./Hello.html">Hello Kind!</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-kind"><a class="header" href="#hello-kind">Hello Kind</a></h1>
<p>This is definitely not another &quot;Hello World!&quot; guide. Or is it?</p>
<p>By this point, Kind should already be installed in your machine. If not, please go back to <a href="Guide/./Installation.html">Installation</a> and move along with the instructions.</p>
<p>You are not sure Kind is correctly installed? Try proceeding with this guide, if it doesn't work, well... it's not installed. If it worked, then you're ready to learn how to become a <del>PRO GAMER</del> Kind programmer!~</p>
<p>In this guide, command lines and text editors will be used, so make sure the terminal is open to proceed through the steps. Don't know what is a Terminal and Text Editor? So go back to <a href="Guide/./Terminal.html">Terminal</a> guide and <a href="Guide/./IDE.html">Text Editors</a>.</p>
<h2 id="creating-the-documents"><a class="header" href="#creating-the-documents">Creating the documents</a></h2>
<p>First of all, create a directory to store the Kind files. It is recommended to use a dedicated directory to keep all the exercises and examples, but feel free to do as you want.</p>
<p>The three commands below will create a directory called 'KindExamples' and a file called 'hello_world.kind2' inside the project directory. Use them in order:</p>
<pre><code>//Making a directory
mkdir KindExamples
</code></pre>
<pre><code>//Moving through directories
cd    KindExamples
</code></pre>
<pre><code>//Making a file
touch hello_world.kind2  ////CMD use &quot;copy nul hello_world.kind2 &gt; nul&quot;
</code></pre>
<p>The .kind2 extension is what makes it a Kind file. For example, a file that ends with .exe is an Executable; .js is a JavaScript file; .rs is a Rust file, etc.</p>
<p>If the commands were used correctly, the file hello_world.kind2 should be inside the folder KindExamples. Then it's time for fun, CODING!</p>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h2>
<p>Open the hello_world.kind2 file on the <a href="Guide/./IDE.html">Text Editors</a>, it is going to be empty, but no worries, remember our little story in <a href="Guide/./Guide/About.html">About Kind</a> about exploring a Universe? This is just your first exploration.</p>
<ul>
<li><em>Starting now, there are going to be some advanced concepts. But don't be scared, everything will make sense in the future, ethoses concepts that are pertinent will be explained in it's given time.</em></li>
<li><em>It is recommended that you manually type the codes, instead of copy pasting them in your file.</em></li>
</ul>
<p>Let's write your first code into the hello_world.kind2 file:</p>
<pre><code>//hello_world.kind2
Main {
  &quot;Hello, Kind!&quot;
}
</code></pre>
<p>And that's it! That's how a Kind &quot;Hello World!&quot; is written. A print function in four lines.</p>
<h2 id="type-checking"><a class="header" href="#type-checking">Type Checking</a></h2>
<p>With the code ready, you should use the Type Check to see if everything is in order. The Type Checker is unknown until now in this guide, but will be explained further. Right now, simply understand it as a verifier that checks if the file is correctly typed and &quot;typed&quot; (haha!).</p>
<p>To Type Check a Kind file, just use the command Kind fileName.kind2. For the hello_world.kind2 file it would be:</p>
<pre><code>//Terminal
kind2 check hello_world.kind2
</code></pre>
<p>The message &quot;All terms check.&quot; means your file is ready!</p>
<pre><code>//Terminal
All terms check.
</code></pre>
<p>The Type Check is ok? Then let's run the code.</p>
<h2 id="running-the-code"><a class="header" href="#running-the-code">Running the code</a></h2>
<p>To Run a file in Kind, use the command <code>kind2 run nomeDoArquivo.kind</code>. Yes, the fileName goes without the extension in this case. It should look like this:</p>
<pre><code>//Terminal
kind2 run hello_world.kind2
</code></pre>
<p>And voila! your terminal should print Hello, Kind! back to you.</p>
<!-- To print any other messages, re-open the file and change the Parameters insideIO.print function. An example is to type IO.print("I am amazing!")  and run the file, try it! -->
<p>Just remember every steps above, Type Check it then run!</p>
<pre><code>//Terminal
&quot;Hello, Kind!&quot;
</code></pre>
<p>With that you've finished your first exploration and may call yourself a Kind Astronaut, congratulations! Welcome to the Kind programming world!</p>
<p>In this first mission you explored your first ecosystem, discovered.</p>
<p>You just explored your first ecosystem and discovered your first function. The next section will go deeper into the <a href="Guide/../Basic/Basics.html">Kind Basics</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kind-basics"><a class="header" href="#kind-basics">Kind Basics</a></h1>
<p>Types, Functions and Theorems are the fundamentals of Kind.</p>
<p>The basics of Kind language are: </p>
<ul>
<li>Types</li>
<li>Functions</li>
<li>Theorems</li>
</ul>
<p>But first, let's take a look and get comfortable with the first two. Theorems is a more complicated subject and will be explained later in this book.</p>
<p>By working with basic functions and types in this segment, you'll know and have a better understating of the Kind syntax and how it works. </p>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Throughout this book, you will notice that sometimes there is a &quot;double slash&quot; // followed by a code or a text. This double slash is used to tell the compiler that EVERYTHING that comes after it, in that specific line, will be seen as a comment. So the compiler does not read those comments. </p>
<p>Comments are generally used to describe the functionality of a function, but you can use it to write whatever you want in how many lines you desire as long as you remember to use  &quot;//&quot; in each line.</p>
<p>For example:</p>
<pre><code class="language-rust  ignore">//comments.kind2

This is not a comment.

//This is a comment.
 
This code works. // Anything after the double slash, doesn't work anymore.

//This code doesn't work // Neither does this one

This code works. // This code doesn't // Neither does this // Or this

This works too //</code></pre>
<p>So, when you see a // just know that it is a commented code, and everything to the right of the it will not be interpreted by the compiler. </p>
<p>Now that you, fellow Kind Astronaut, know went through all this preparation, our journey has everything to begin! </p>
<p>Let's start by learning what are these so called &quot;<a href="Basic/../Basic/Types.html">Types</a>&quot;.</p>
<p>&quot;Types of what?! Fruits?&quot; - Recruit nº42.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h1>
<p>What you need to know about Types in Kind.</p>
<p>Types, which is short for &quot;Data Types&quot;, have an important role in Kind's environment. They provide Kind the information about which type of data it's going to work with. That's why the word &quot;Type&quot; appears a lot throughout this guide.</p>
<p>So, it is extremely important that you get as comfortable as possible using it. Please, read this guide as many times as necessary to fell like an expert in this subject.</p>
<h2 id="what-are-types"><a class="header" href="#what-are-types">What are Types?</a></h2>
<p>A Type is how a group of values is seted. Every value within that group is in the same category. Bellow, types system will be represented as boxes in a visual example that makes it more understandable</p>
<p>---Img---</p>
<p>The easiest way to think about Types is to see them as a group that defines other things. Or, in a way that Astronauts can understand, they are like planets in this Kind Universe.</p>
<p>---Img---</p>
<p>This is how it looks when you define a type in Kind using Bool as an example:</p>
<pre><code>//Bool.kind2

type Bool {  
  true
  false
}
</code></pre>
<p>There are basically two things that forms a Type, a name and its Constructors. Let's understand better this syntax:</p>
<p>---Img---</p>
<p>In the first line write <code>type</code> to say it is defining a type, followed by the name of the type. The first letter of this name is always in upper case, unlike <code>type</code>, which is always written in lower case.</p>
<p>---Img---</p>
<p>The curly brackets determines where type definition starts and ends. Everything inside the curly brackets are the constructors of that type, and constructor names must be in lower case as well.</p>
<p>---Img---</p>
<p>It is important to notice that constructos do not have a value unless they are in a function. In other words, inside the Type definition, they don't have it.  For example, constructors like &quot;true&quot; and &quot;false&quot;, that are from the Bool type, do not hold any meaning by themselves, they are just a name. Only when inside functions it is assigned values to them that defines what is true and what is false.</p>
<p>Note that a Type can hod an uncountable number of constructors:</p>
<pre><code>//example.kind2

type Typename { 
  constructor1
  constructor2
  constructor3
  constructor4
  constr...
}
// &quot;...&quot; meaning continuation
</code></pre>
<p>It is very important to name constructors based on what value they will have inside the functions, it improves the readability of the code.</p>
<p>Now that you know Types a little bit better, it's time to dig deeper into what constitutes a type. Let's proceed to <a href="Basic/./Constructors.html">Constructors</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="--basic-constructors"><a class="header" href="#--basic-constructors">- Basic Constructors</a></h1>
<p>What are they building?</p>
<p>Constructor is a short name for &quot;data constructor&quot;. Every one of them belongs to a Type and stores a value. It can be used to store values together, but can also store none. In that last case it is called a Nullary Constructor, meaning that they are constants.</p>
<p>Here is an example of Constructors from the Bool Type:</p>
<pre><code class="language-rs  ignore"> //Bool.kind2

type Bool { // type's declaration + type name
  true      // first  constructor, named true
  false     // second constructor, named false
}           // end of declaration
</code></pre>
<p>In the Boolean type we have two Nullary constructors, true and false, for the sake of simplicity, all constructors examples in the Kind Basics section are going to be Nullary, further along, examples of other types of constructors will be shown.</p>
<h2 id="boxes-for-constructors"><a class="header" href="#boxes-for-constructors">Boxes for constructors</a></h2>
<p>A Type is basically a box to keep the Constructors. The Bool Type, for example, is a box that stores the <code>true</code> and <code>false</code> constructors. But remember, when inside that box, they don't have any value, just a name, in order to have values, they need to be inside functions.</p>
<ul>
<li><em>Reminder: The box is just a container, and so, it is used as an example. A type could be represented by anything with the capability to store things.</em></li>
</ul>
<p>Constructors represents the concrete values stored by a Type, and are called by using it's type name + constructor name:</p>
<pre><code class="language-rs  ignore">// Boolean type
type Bool {
    true
    false
}

// representation of the value
    Bool.true
    //or
    Bool.false
</code></pre>
<p>The <code>Bool.true</code> and <code>Bool.false</code> are the correct way to call those constructors outside their Type. In this case, the Bool Type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-functions"><a class="header" href="#basic-functions">Basic Functions</a></h1>
<p>The life inside Kind Universe.</p>
<h2 id="what-are-functions"><a class="header" href="#what-are-functions">What are Functions</a></h2>
<p>Functions gives types and constructors a meaning. Types, by themselves, are simply a categorization of constructors, but, when applied to functions, that's when the &quot;magic&quot; happens!</p>
<p>Just like the Astronaut from About Kind story, let's explore the Boolean planet to &quot;discover&quot; and document  the functions  &quot;<strong>AND</strong>&quot;, &quot;<strong>NOT</strong>&quot; and &quot;<strong>OR</strong>&quot;  (Don't it just look like some sort of time travel? Are you the Astronaut from the story?).</p>
<p>The Bool still has no concrete use, since it still has no function. True and false is just names for the constructors, but even so, they got to have some logic behind them. Let's start with Not Function, the <strong>Boolean Negation</strong>.</p>
<h2 id="defining-a-function"><a class="header" href="#defining-a-function">Defining a Function</a></h2>
<p>Functions in Kind are like mathematical functions, you tell them how to work, give them something to work with and it will return an answer. Let's see how it works in the example bellow:</p>
<pre><code class="language-rust ignore">// selfReturningFunction.kind2

Identity (b: Bool) : Bool
Identity Bool.true = Bool.true
Identity Bool.false = Bool.false</code></pre>
<p>This is a function that returns the input itself, it is called Identity function. And it is a simple example of the functions' syntax in Kind. In the first line there are a lot of information about the function for us and the machine to interpret it. And so here is a  &quot;translation&quot; of this first line:</p>
<ul>
<li><em>&quot;Hmrm <code>clears throat</code> identity is a function that receives a variable named b , which is of the type Bool, and the function returns something of the type Bool.&quot;</em></li>
</ul>
<h2 id="function-anatomy"><a class="header" href="#function-anatomy">Function Anatomy</a></h2>
<p>--Img--</p>
<p>[Yes, all of that is written up there, functions in Kind always start with their name, the name not necessarily needs to start with a lower case letter, but its my personal preference, you could name it ItSelf or Itself.After you name the function we open brackets and we write the arguments followed to the type of that function (b: Bool) (c: Bool) (d: Bool) and then we close brackets. Once we are done listing all the arguments our function has we add a cólon :  to tell Kind we have named our function and listing the arguments and we proceed to the return, after the Cólon it means that our function is going to give us a result of something of that type, in our example we decided to use Bool as the type of return, but it could be any existing type in Kind, even a type you create yourself. [It is kind erroneous calling it a variable since they are immutable, they are values of that type, but we call them variable]]</p>
<h2 id="return"><a class="header" href="#return">Return</a></h2>
<p>Lets use our box again, when we pattern matched our variable and we got either true or false, now we must specify what to return for those cases, on our example we returned Bool.true when true and Bool.false for false, that means we covered every possibility in the <code>type Bool</code> and we gave a Bool return to the function, which is what it expected.</p>
<p>for the box, it would look like this:</p>
<p>--Img--</p>
<p>You always gotta fill the answer with something of the type you specified in first place, it won't work if you return something of a different type from what you specified, this would be an example;</p>
<pre><code class="language-rust ignore">Wrong (a: Bool) : Bool
Wrong Bool.true = Bool.true
Wrong Bool.false = Nat.zero</code></pre>
<p>Nat.zero is something of the type Nat, but we specified the return as a Bool, therefore the type checker would return an error of type in this situation.</p>
<pre><code class="language-diff">// Type mismatch in the function named wrong.

-   ERROR  Type mismatch

  • Got      : Nat 
  • Expected : Bool 

  Wrong Bool.true = Bool.true
  Wrong Bool.false = Nat.zero
                     ┬───────
                     └Here!
</code></pre>
<p>As we have seen in Type Checker, this is how a code would return with the wrong type</p>
<h2 id="pattern-matching---match"><a class="header" href="#pattern-matching---match">Pattern Matching - match</a></h2>
<p>All a data constructor does is holding values together. When we want to use them we need to deconstruct in order to specify what to do based on which constructor is being used. This is done with pattern matching. Type is the creator, holder, container, match is the deconstructed, analyzer, bond breaker.</p>
<p>Pattern matching is the act of verify possible matches of a given value, this is done sequentially.</p>
<p>On our functions in Kind we call it case and we give the value our variable, like in the second line of our example, we verify within b the possible matches, in that case it can only be true or false, since the Bool type  has only two possible matches.</p>
<p>Let's go back to our boxes, here is the boolean box:</p>
<p>--Img--</p>
<p>~~These are the two possible cases of a value of the type Bool, it's either true or false, because its how we defined in our type Bool , so when we open a match of something from the type Bool,  its like if we were opening the box, looking at every possibility and giving them an answer to what to do when the pattern matches for every of the single cases. ~~</p>
<p>To visualize the options we can use branches to see clearer the possible paths.</p>
<pre><code class="language-rust ignore">  match variable
   /       \ 
 true      false
  |          |     
  ?a         ?b 
</code></pre>
<ul>
<li>
<p>?a is the return for the function <code>MATCH</code> the variable we input is true.</p>
</li>
<li>
<p>?b is the return for the function <code>MATCH</code> the variable we input is false.</p>
</li>
</ul>
<p>in our example itself we returned True case b is true and False case b is false.</p>
<pre><code class="language-rust ignore">    match b
   /      \ 
 true     false
  |         |     
 true     false</code></pre>
<p>The returns are the tips of the branches.</p>
<h2 id="basic-function-example"><a class="header" href="#basic-function-example">Basic Function Example</a></h2>
<p>First things first, create a new file <code>namedNegation.kind2</code>.</p>
<p>In our <code>Negation.kind2</code> file we start with the first line (You can try doing it by yourself, click <a href="Basic/./Examples/Function.html">here</a> for the answer)</p>
<pre><code class="language-rust ignore">Negation.function (b: Bool) : Bool 
Negation.function b = ?help</code></pre>
<h2 id="kind-goals"><a class="header" href="#kind-goals">Kind Goals</a></h2>
<p>A goal can be written as ? followed by a name. For example, <code>?help</code> is a goal named <code>help</code>. Goals are extremely useful when developing algorithms and proofs, as they allow you to keep a part of your program incomplete while you work on the rest. They also allow you to inspect the context and expected type on that part. For example, our <code>help</code> goal in negation will display:</p>
<pre><code class="language-diff">+  INFO  Inspection.

    • Expected: Bool 

    • Context: 
    •   b : Bool 

    Negation.function (b: Bool) : Bool 
    Negation.function b = ?help
                          ┬────
                          └Here!
</code></pre>
<p>Notice how it shows the type it expects on each hole, as well as the context available there.</p>
<p>Our function named <code>function</code>has only one variable for us to work with, now if we had more variables and needed to look even further in our branches of possibilities, we could open a case inside a case (pattern match a value inside another branch). We are going to look further in the following examples.</p>
<h2 id="intermediate-function-example"><a class="header" href="#intermediate-function-example">Intermediate Function Example</a></h2>
<p>After we defined the &quot;<strong>NOT</strong>&quot; function, we still have the &quot;<strong>AND</strong>&quot; and &quot;<strong>OR</strong>&quot; functions, but those functions have two variables as arguments, and we need to verify deeper down inside each case, lets investigate together.</p>
<p>Now that we are done with the <code>Negation.kind2</code> file, we can save it and open a new one named <code>Logics.kind2</code></p>
<p>The logical <strong>AND</strong> operator returns <em>true</em> if both operands are <strong>true</strong> and returns <em>false</em> otherwise, and the result is of type <code>Bool</code>. This is how the function header would look like:</p>
<pre><code class="language-rust ignore">Logics.and (a: Bool) (b: Bool) : Bool
Logics.and a b = ?ab</code></pre>
<p>If you want, you can proceed by yourself. After this line, it is the solution and explanation.</p>
<pre><code class="language-rust ignore">Logics.and (a: Bool) (b: Bool) : Bool
Logics.and Bool.true b = ?a
Logics.and Bool.false b = ?b</code></pre>
<p>We are pattern matching our variable b , in the first branch, we are working with the possibility of b being true, in that case we must analyze a  because the answer depends on that, since its only true if both of our values are true.</p>
<pre><code class="language-rust ignore">      case b
     /       \ 
-&gt; true      false
    |          |     
   ?a         ?b 
</code></pre>
<p>We can open a case in the variable a  when we are analyzing the case of b  being true. It would look like that</p>
<pre><code class="language-rust ignore">Logics.and (a: Bool) (b: Bool) : Bool
Logics.and Bool.true  Bool.true = ?a
Logics.and Bool.false Bool.true = ?b
Logics.and a          Bool.false = ?c</code></pre>
<p>Now we are working with both cases:</p>
<ul>
<li><code>Case b is true and case a is true</code> = Goal a (?a)</li>
<li><code>Case b is true and case a is false</code> = Goal b (?b)</li>
</ul>
<pre><code class="language-rust ignore">       case b
      /      \ 
    true     false
     |         |     
-&gt; case a      ?c
   /    \
 ?a      ?b </code></pre>
<p>Following our logic, when A and B are true, the answer is true, therefore the goal a (?a) is Bool.true, and when B is true but A is false, we have Bool.false as answer:</p>
<pre><code class="language-rust ignore">Logics.and (a: Bool) (b: Bool) : Bool
Logics.and Bool.true  Bool.true = Bool.true
Logics.and Bool.false Bool.true = Bool.false
Logics.and a          Bool.false = ?c</code></pre>
<pre><code class="language-rust ignore">       case b
      /      \ 
    true     false
     |         |     
-&gt; case a      ?c
   /    \
true    false
 |        |
true     false</code></pre>
<p>We have now finished our left branch, or, the  branch with value true. Time for us to go to the false branch.</p>
<p>We do the same as we did before, but we know both values MUST be true in order for the function to return true, therefore if b is already false, it is impossible for it to return true, we would get the function looking like that:</p>
<pre><code class="language-rust ignore">Logics.and (a: Bool) (b: Bool) : Bool
Logics.and Bool.true  Bool.true = Bool.true
Logics.and Bool.false Bool.true = Bool.false
Logics.and a          Bool.false = Bool.false</code></pre>
<pre><code class="language-rust ignore">       case b
      /      \ 
    true     false
     |         |     
   case a    false  &lt;-
   /    \
true    false
 |        |
true     false  </code></pre>
<p>And this is how the And function would look like in Kind .  .  . BUT! you can improve it even further, i wont give you the answer here, but you are more than welcome to do it yourself, don't worry if you cant find the answer now, you can come back later and redo it with way more knowledge! ahh!! the smarter version is in <a href="Basic/./Examples/Function.html">Functions</a> if you want to look for it.</p>
<h2 id="running-a-function"><a class="header" href="#running-a-function">Running a Function</a></h2>
<p>Now that we have learned all about how to build a function, it is time for us to test our logics and if the function is working as intended, if we wrote everything right and all type checked, it means all types and syntaxes are right, and in here, we are going to learn how to run a function.</p>
<p>First we are going to add the name of the file as a function in the code, without arguments just the name and a return, since our file is named <code>Logics.kind2</code>we are going to add it to the bottom of the file, with the return of the function we are going to try out. We are testing the <code>Logics.and</code> function, therefore the return is of the Bool type, we would add a line with the following code:</p>
<pre><code class="language-rust ignore">Main : Bool {
  ...
}</code></pre>
<p><code>Main: type of Return</code></p>
<p>Bellow that line we call our function to run, our <code>Logics.and</code>  function receives two booleans as argument of the variables <code>a</code>  and <code>b</code> , so we are going to test it with two booleans:</p>
<pre><code class="language-rust ignore">Logics.and (a: Bool) (b: Bool) : Bool
Logics.and Bool.true  Bool.true = Bool.true
Logics.and Bool.false Bool.true = Bool.false
Logics.and a          Bool.false = Bool.false

Main : Bool {
  Logics.and Bool.true Bool.false 
}</code></pre>
<p>If you want to try other options, you can change the two arguments as the following examples:</p>
<pre><code class="language-rust ignore">//Examples of function call:
// Logics.and (Bool.true)  (Bool.true)
// Logics.and (Bool.false) (Bool.true)
// Logics.and (Bool.false) (Bool.false)</code></pre>
<p>Note: Kind can only run one function at time, you can have as many functions in a file as you want, but you can only run one at a time.</p>
<p>With all this knowledge, you can do the &quot;<strong>OR</strong>&quot; logics, and you can also find more basic Bool <a href="https://github.com/HigherOrderCO/class/blob/main/Kind/Exercises/ex_00.kind2">exercises in our github</a>. The &quot;<strong>OR</strong>&quot; logic answer can be found <a href="Basic/./Examples/Function.html#function-or-with-pattern-matching">here</a>.</p>
<p>Before proceeding to learn about functions, and how to use constructors inside them, it is important to understand about an important tool in Kind's environment, the Type Checker!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-checker"><a class="header" href="#type-checker">Type Checker</a></h1>
<p>Expected description, found joke.</p>
<p>The Type Checker is one of Kind's strongest features, and throughout this book it will be used very often. Remember back in <a href="Basic/../Guide/Hello.html">Hello Kind!</a> where we &quot;type checked&quot; a file? Now is the time to understand what really happened there.</p>
<h2 id="what-is-a-type-checker"><a class="header" href="#what-is-a-type-checker">What is a Type Checker</a></h2>
<p>A type exists with its rules, and those rules place limits on its constructors. The Type Checker is an algorithm that inspect if the limits of a type are being respected. The action of verifying types is called <strong>type checking</strong>.</p>
<p>The Type checker is a very important tool, because the bigger a code is, the harder it will be to make changes, even small ones, and not compromise something along the way. It guides us in where it is needed to make changes. This, by itself, drastically reduces the chances of bugs in our programs while also helping to keep our codes more concise and readable.</p>
<p>As big as a code can be, the Type Checker will be your best friend when working with it. The bigger the code, the more rewarding it feels to use it.</p>
<p>Type Checkers can be separated in two categories:</p>
<ul>
<li>Static Type Checker</li>
<li>Dynamic Type Checker</li>
</ul>
<p>And this guide addresses the one that Kind uses, the Static Type Checker.</p>
<h3 id="what-it-does"><a class="header" href="#what-it-does">What it does</a></h3>
<p>The Type Checker does two sorts of verifications:</p>
<ul>
<li>Syntax Verification</li>
<li>Types Verification</li>
</ul>
<p>In the first step, the Type Checker checks the syntax of the code. Syntax is the language used in Kind, just like all the other languages in the word. Portuguese, deutsch, english and so on, every one of these has its own rules and methods, and it's used to communicate. Kind syntax works in the same way, and the Type Checker will verify if there it is no mistakes in your writing. If it finds any mistake, Kind's Type Checker will point to you where and what it is.</p>
<pre><code class="language-diff">- ERROR  Unexpected token 'true'.

type Bool  
 true
 ┬───
 └Here!
 false
}
</code></pre>
<p>Above, the Type Checker found an error in the code. See how it says how it was expected a curly bracket, and instead found the letter &quot;true&quot;. That's why this code is missing a &quot;{&quot; to open the constructors' box.
If no syntax error is found in the code, the Type Checker will proceed to its next function, to verify if the Types are correct. Kind is strongly Typed, therefore it's always necessary to explicit the types that are in the code.</p>
<p>Imagine you are reading a code that uses the Bool Type, and in some point you verify that a function returns a Nat type (the type of the natural numbers). The Type Checker mission is to find and point this mismatch. That way, this code can be corrected and will be more safe, reliable and clearer. The Type Checker is like your best friend when writing.</p>
<p>It is called  Static Type Checker because it checks everything before running the program. iIf both syntax and type are ok, the console will show the message: All terms check. This means that the file Syntax and Types are right and ready to run!</p>
<pre><code>//Terminal
All terms check.
</code></pre>
<p>It is strongly recommended to Type Check a file every time before running it, to avoid potential time waste. Because, if the types are wrong, there will be a compilation error message, and it will be necessary to type check it all over again, and that's double of your time wasted!
To type check a file, simply use this command:</p>
<pre><code>//Terminal
kind2 check hello_world.kind2
</code></pre>
<p>You must replace the fileName for the name of the file you're using, and don't forget the extension .kind!
Knowing how to use this powerful tool, let's learn more about what gives life to Kind, the functions.</p>
<p>Thats all of the Kind Basics! if have come all this way congrats! now you can write basic functions in Kind, now, we can proceed to Kind Intermediate! Let's go Rookie, time for us go to a Voyage!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>After learning about Constructors, Types and Functions, you may use this section to see and study some examples from each of them. Simply use the index navigation below:</p>
<ol>
<li><a href="Basic/Examples/./Basic.html">Basic Types Examples</a></li>
<li><a href="Basic/Examples/./Constructors.html">Basic Constructor Examples</a></li>
<li><a href="Basic/Examples/./Function.html">Basic Function Examples</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-type-examples"><a class="header" href="#basic-type-examples">Basic Type Examples</a></h1>
<p>Then, in this section you may find Basic type examples with only Nullary Constructors.</p>
<h2 id="type-single"><a class="header" href="#type-single">Type Single</a></h2>
<pre><code class="language-Rust ignore">// A type with only one constructor that doesn't have a stored value.
type Single { 
  lonely       // :(
}

// Single concrete values: 
  // Single.lonely
</code></pre>
<h2 id="type-bool"><a class="header" href="#type-bool">Type Bool</a></h2>
<pre><code class="language-Rust ignore">// A type with two constructors where both doesn't have a stored value.

type Bool { 
  true
  false
}

// Bool concrete values:
  // Bool.true
  // Bool.false
</code></pre>
<h2 id="type-cardinal"><a class="header" href="#type-cardinal">Type Cardinal</a></h2>
<pre><code class="language-Rust ignore">Type Cardinal
// A type with four constructors and neither of them have a stored value.

type Cardinal { 
  north
  south
  west
  east
}

// Cardinal concrete values: 
  // Cardinal.north
  // Cardinal.south
  // Cardinal.west
  // Cardinal.east
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-constructors-examples"><a class="header" href="#basic-constructors-examples">Basic Constructors Examples</a></h1>
<p>Here are examples of nullary constructors using different Types.</p>
<h2 id="single-constructors"><a class="header" href="#single-constructors">Single Constructors</a></h2>
<pre><code class="language-Rust ignore">// A type with only one constructor without a stored value.

type Single {
  lonely       // :(
}

// Single constructor: 
  // lonely
</code></pre>
<h2 id="bool-constructors"><a class="header" href="#bool-constructors">Bool Constructors</a></h2>
<pre><code class="language-Rust ignore">// A type with two constructors where both do not have a stored value.

type Bool { 
  true
  false 
}

// Bool constructors:
  // true
  // false
</code></pre>
<h2 id="cardinal-constructors"><a class="header" href="#cardinal-constructors">Cardinal Constructors</a></h2>
<pre><code class="language-Rust ignore">// A type with four constructors and neither of them have a stored value.

type Cardinal { 
  north  
  south  
  west   
  east     
}

// Cardinal constructors: 
  // north
  // south
  // west
  // east
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-function-examples"><a class="header" href="#basic-function-examples">Basic Function Examples</a></h1>
<p>And finally, some Basic Function Examples using the Boolean Type.</p>
<h2 id="function-identity"><a class="header" href="#function-identity">Function Identity</a></h2>
<pre><code class="language-Rust ignore">Identity (b: Bool): Bool 
Identity b = b
</code></pre>
<p>The <code>Identity</code> function always returns the input value itself. Therefore, if &quot;b&quot; value is &quot;True&quot; then the output is also &quot;True&quot;. The same would happen if the value of &quot;b&quot; is &quot;False&quot;.</p>
<h2 id="function-negation"><a class="header" href="#function-negation">Function Negation</a></h2>
<pre><code class="language-Rust ignore">Negation (a: Bool) : Bool 
Negation Bool.true = Bool.false
Negation Bool.false = Bool.true  
</code></pre>
<p>The function negation always returns the opposite of the user input. If the input is the Boolean &quot;True&quot;, it returns &quot;False&quot;. The contrary is also correct.</p>
<h2 id="function-and"><a class="header" href="#function-and">Function And</a></h2>
<pre><code class="language-Rust ignore">And (a: Bool) (b: Bool) : Bool
And Bool.true Bool.true = Bool.true
And Bool.true Bool.false = Bool.false
And Bool.false Bool.true = Bool.false
And Bool.false Bool.false = Bool.false 
</code></pre>
<p>This function basically returns True if both inputs are &quot;True&quot;. Taking close attention to the &quot;True&quot; branch inside &quot;case b&quot;, you may realize it does the same as function identity, returns the value of the input itself. Also, you don't really need to examine the &quot;False&quot; branch, because every other input will return False.
So, let's take a look on how to better write this function.</p>
<h2 id="function-and-with-pattern-matching"><a class="header" href="#function-and-with-pattern-matching">Function And with Pattern Matching</a></h2>
<pre><code class="language-Rust ignore">And (a: Bool) (b: Bool) : Bool {
  match Bool a {
    true =&gt; b
    false =&gt; Bool.false
  }
}

</code></pre>
<p>One possible way to write the function is opening the &quot;case a b&quot;, in other worlds, opening both cases at the same time. But, in this situation, there are a lot of Bool.false outcomes. To avoid this repetition you can set a default answer and make the cases that matches this to be implicit. Just like below:</p>
<pre><code class="language-Rust ignore">And (a: Bool) (b: Bool) : Bool
And Bool.true  b = b
And Bool.false b = Bool.false
</code></pre>
<h2 id="function-or"><a class="header" href="#function-or">Function Or</a></h2>
<pre><code class="language-Rust ignore">Or (a: Bool) (b: Bool) : Bool
Or Bool.true Bool.true = Bool.true
Or Bool.true Bool.false = Bool.true
Or Bool.false Bool.true = Bool.true
Or Bool.false Bool.false = Bool.false
</code></pre>
<p>According to the Or logics, if any input to this function is &quot;True&quot;, then the outcome will also be &quot;True&quot;. That's why the &quot;True&quot; branch on &quot;case a&quot; does not depend on the &quot;b&quot; value.
On the other hand, for the &quot;False&quot; branch inside the same case, the outcome depends purely on the &quot;b&quot; value. If it is &quot;True&quot; the function returns &quot;True&quot;, and if it is &quot;False&quot; the return will also be &quot;False&quot;.</p>
<p>Let's see how it is possible to would work using Pattern Matching.</p>
<h2 id="function-or-with-pattern-matching"><a class="header" href="#function-or-with-pattern-matching">Function Or with Pattern Matching</a></h2>
<pre><code class="language-Rust ignore">Or (a: Bool) (b: Bool) : Bool {
 match Bool a {
    true =&gt; Bool.true
    false =&gt; b
  }
}
</code></pre>
<p>It basically happens the same as the function AND example, there is a repetition of the same outcome, in this case the &quot;Bool.true&quot;. So it is possible to do the sabe as we did before, set it as the default answer and implicit some of the pattern match cases. It would look like this:</p>
<pre><code class="language-Rust ignore">Or (a: Bool) (b: Bool) : Bool
Or Bool.true  b = Bool.true
Or Bool.false b = b
</code></pre>
<h2 id="function-equal-with-composition"><a class="header" href="#function-equal-with-composition">Function Equal with composition</a></h2>
<pre><code class="language-Rust ignore">Eql (a: Bool) (b: Bool) : Bool
Eql Bool.true   Bool.true  = Bool.true
Eql Bool.false  Bool.false = Bool.true
Eql a           b          = Bool.false
</code></pre>
<p>You can use functions inside functions as well, that is, hacking the game! We are going to learn about it later, but as you are already here, know that you can compose functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-kind-voyage"><a class="header" href="#a-kind-voyage">A Kind Voyage!</a></h1>
<p>We are here again Kind astronaut, for a new voyage, in this Journey we are going to explore things beyond only syntax in Kind, we are going to see different types, constructors and concepts, everything is listed in the topics bellow: </p>
<ol>
<li><a href="Voyage/./Constructors.html">Constructors with Value</a> - Constructors Part 2</li>
<li><a href="Voyage/./Polymorphic.html">Polymorphic Types</a> - Types Part 2</li>
<li><a href="Voyage/./Accessing.html">Accessing Constructors Values</a></li>
<li><a href="Voyage/./Functions.html">More about Functions</a> - Functions Part 2</li>
</ol>
<p>In our previous exploration we went a little bit deep into the Boolean planet, now we are going to explore some complex Life Forms, the Maybe and Pair Planet.</p>
<p>In our voyage we are going to have a very similar approach that we had in Kind Basics, but instead we are in a Intermediate level, the learning curve here is a little bit higher but nothing impossible, i am sure that together we can understand and work with these types, so, let's go buddy, time for us to learn more things about Constructors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructors-with-value"><a class="header" href="#constructors-with-value">Constructors with Value</a></h1>
<p>Constructors Part 2</p>
<h2 id="atmospheric-entry"><a class="header" href="#atmospheric-entry">Atmospheric Entry</a></h2>
<p>In this Voyage we are going to take larger steps, a lot of abstract concepts are going to be seen here, but we are going to start with a simpler approach and as we proceed, we are going to go deeper on everything we learn in here.
Before we leave on our next trip towards the Pair and Maybe planets, i want to show you some simpler concepts before we fully see their potential, then lets proceed.</p>
<h2 id="beyond-nullary-constructors"><a class="header" href="#beyond-nullary-constructors">Beyond Nullary Constructors</a></h2>
<p>Constructors are made to hold values together, we just learned about the Nullary constructors, or constants, and here we are going to learn about constructors with values.
if it sound confusing don't worry, we are going to explore this concept in order for us to understand all about it, first we proceed with a variation of the type Maybe, then we go for the Pairs.</p>
<h3 id="maybe-variation-and-constructors-with-values"><a class="header" href="#maybe-variation-and-constructors-with-values">Maybe variation and Constructors with Values</a></h3>
<p>The type Maybe in kind is very powerful, but in here we are going to use a variation of that type to explain the concept of constructors with value.
Constructors are functions, Nullary constructors has no arguments, therefore they return nothing but their own value, but constructors with arguments their value can vary, and this is how the constructor with arguments would look:</p>
<pre><code class="language-Rust ignore">type MaybeBool {
  none
  some (value: Bool)
}

</code></pre>
<p>As you can see, the <code>some</code> constructor is a function that has an argument <code>value</code> of the type Bool.</p>
<p>If we think of the type Bool it is a type with two possible values True or False, in this Maybe version it is very similar, but instead, it has a function that stores a value of the type Bool. Therefore, we can notice that this MaybeBool is basically the same as the Boolean type, but instead of only giving us two options, it also stores a value of that type.  In the case of our constructor to be none, it has no value, but if it is some, it has something stored inside the constructor.
Using a bag as example, either you have No bag (none)  or a bag with something inside (some).</p>
<h3 id="building-a-maybe-variation-concrete-value-using-constructors-with-arguments"><a class="header" href="#building-a-maybe-variation-concrete-value-using-constructors-with-arguments">Building a Maybe Variation Concrete value using Constructors with arguments</a></h3>
<p>To build concrete values we are going to do the same as we learned in <a href="Voyage/../Basic/Types.html">Basic Types</a>, we write typename.constructor:</p>
<pre><code class="language-Rust ignore">MaybeBool.none // Right
MaybeBool.some // Wrong

</code></pre>
<p>But that wouldn't work, since MaybeBool is a function, we need to give him something of the type Bool, since the variable value is of the type Bool</p>
<pre><code class="language-Rust ignore">MaybeBool.some (Bool.true)  // Right
MaybeBool.some (Bool.false) // Right
</code></pre>
<p>Either of the options works, since we fulfilled with what Kind asked us, if it doesn't seem very organic to you, we are going to revise this concept multiple time throughout the book.
Then all you gotta do is, typename.constructor(arguments of that type) and you build a concrete value of that type, let us see another example, now with Pairs.</p>
<h3 id="pair-variation-and-constructors-with-values"><a class="header" href="#pair-variation-and-constructors-with-values">Pair variation and Constructors with Values</a></h3>
<p>Same as the Maybe type, the pair also has a constructor with value, but as the name suggest it has TWO values, and instead of being either One or Another, it is always BOTH, can you figure out how? If not thats ok, lets write a variation of the Pair type, a Pair of Bool.</p>
<pre><code class="language-Rust ignore">type PairBool {
  new (fst: Bool) (snd: Bool)
}
</code></pre>
<p>This is how a pair of bool would look like, you have only one constructor because it is ALWAYS that one, you cannot have an either option here! i choose the name new for the constructor.  fst and snd for the arguments just to make it clearer, you could choose any name you want!
Let us build now concrete pair values using the Bool type.</p>
<h3 id="building-a-pair-variation-concrete-value-using-constructors-with-arguments"><a class="header" href="#building-a-pair-variation-concrete-value-using-constructors-with-arguments">Building a Pair Variation Concrete value using Constructors with arguments</a></h3>
<pre><code class="language-Rust ignore">Pair.new // Wrong
</code></pre>
<p>The new constructor receives two values as arguments, the fst and snd, both being of the type Bool, therefore</p>
<pre><code class="language-Rust ignore">Pair.new Bool.true Bool.true
Pair.new Bool.true Bool.false
</code></pre>
<p>There are two other possibilities for this pair, if you want to try to build yourself using the Bool.false, you are more than welcome to, for practice purposes.</p>
<p>Pair is a good type to store two things together, imagine you want to have a name linked to a number? Like:</p>
<pre><code class="language-Rust ignore">1 - Anna
2 - Bruce
3 - Jeorge
4 - Myrna
...
</code></pre>
<p>Or maybe you want to link other two things together, like a list to a boolean.</p>
<pre><code class="language-Rust ignore"> []      - Bool.true
 [1]     - Bool.false
 [1,2]   - Bool.true
 [1,2,3] - Bool.false
 . . .
</code></pre>
<p>That is a lot of different types, we've seen Numbers, Text, List, Booleans (Nat, String, List, Bool) only in this example, there are infinite types out there, imagine creating a Pair type for each and every of the possibilities, or making a Maybe Type for each of the possible types, that would take forever right? Yes, it would take forever, BUT types are very smart and they asked themselves, what if we become a VARIABLE?</p>
<p>Yes, types can be variables, in <a href="Voyage/./Polymorphic.html">Polymorphic Types</a> we are going to learn how to use this powerful Tool to include every possible type.</p>
<p>Let's go partner, it is time for me to take you to the real Pair and Maybe planets, off we go to the <a href="Voyage/./Polymorphic.html">Polymorphic Types</a> planets, FIRST ONE, Pairs!!!!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polymorphic-types"><a class="header" href="#polymorphic-types">Polymorphic Types</a></h1>
<p>Types Part 2</p>
<h2 id="first-encounter"><a class="header" href="#first-encounter">First Encounter</a></h2>
<p>Welcome to this new planet, the Pair planet, in here we are going to learn about a new sort of Type.</p>
<p>In the Pair Planet, every single life form is tied to another, two things walking hands held to each other, we can also notice, all life forms in the Bool Planet they have no specific shape, their shape is NOT YET DEFINED, but let me show you a thing, the portal shaper.</p>
<p>Whenever the pairs pass through the portal shaper, they actually get their shape defined, and once its defined they can't go back, therefore, before the portal shaper they have no defined shape, after they pass through they get their shape defined.</p>
<p>The Pair shape, each one get an individual shape, they can be the same, they can be different, no matter, they can be anything, as long as they pass through the Shaper, this sort of life form is known as Polymorphic.</p>
<h2 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h2>
<p>Whenever i ask you to think of a Pair, i am pretty sure your brain will think of a Pair of somethings am i right? even if you think of a pair of &quot;nothings&quot;, this nothing is a something, on Kind it is the same. Something is abstract and can be anything, this something can be Fruits, can be Cars, can be Number, can be anything of a group, and groups are Types.</p>
<p>The portal shaper is the return of the function, and before the pairs pass through they are variables, and once they pass, the variable becomes a specific Type.</p>
<p>In Kind we name these as Polymorphic Types, they are variables that can assume any type, some types needs these variables in order to encompass multiple things, same for Lists, whenever you think of a list, you think of a list of something, imagine having to define types for every single thing in existence? The way we do it, is having a variable that we can assign it to some specific type we want.</p>
<h2 id="pairs"><a class="header" href="#pairs">Pairs</a></h2>
<p>As we have seen in <a href="Voyage/./Constructors.html">Constructors with Value</a>, the Pair is a type with a single constructor that has two arguments to it, the First (fst) value of the pair and the Second (snd) value of that pair, but now we are going to modify a thing, our Pair was a Pair of Booleans, now we are going to make the type Pair that includes all types in kind using Variables as Polymorphic Types, in this case it would look like this:</p>
<pre><code class="language-Rust ignore">type Pair (a: Type) (b: Type) { 
  new (fst: a) (snd: b)
}
</code></pre>
<p>Well, let us read that right now:</p>
<p>Hmrm <em>clears throat</em> the type <code>Pair</code>  is a type that has <strong>TWO POLYMORPHIC TYPES A and B</strong>, it has one constructor named <em>new</em>,  and this constructor has two (arguments, values, variables. Either of these options work) values, fst is of type A and snd is of the type B.</p>
<p>This would be the anatomy of this type.</p>
<p>--Img--</p>
<p>A and B are type variables, we call these variables Polymorphic Types, to differ them of value variables, to make the code more readable, most of the Type variables are written in Upper case Letter, as the constructor variables usually start in lower case, to make it clearer to the reader.</p>
<p>The Pair type has two variables because you can have a Pair of two distinct things, like we saw earlier, but A and B can be of the same type, that is not a problem, as long as their values belong to the Types you input, Pairs accept them all, even other pairs (Let this part for later! Too deep down!!!).</p>
<p>That changes mainly the way we build our concrete values with Polymorphic Types, as we specify what is the type of each of the values inside the constructor before we fill them, here are some examples of Pairs:</p>
<pre><code class="language-Rust ignore">// Pair of Bools 
Pair.new Bool Bool Bool.true  Bool.true 
Pair.new Bool Bool Bool.false Bool.false

//Pair of Number and Text 
Pair.new Nat String 1n &quot;Anna&quot;
Pair.new Nat String 2n &quot;Bruce&quot;

//Pair of a Numeric List and a Boolean
Pair.new (List Nat) Bool [] Bool.true
Pair.new (List Nat) Bool [1n] Bool.false
</code></pre>
<p>As said above, you gotta be very precise with specifying a type, if you invert A with B you would get errors.</p>
<pre><code class="language-Rust ignore">// Here we said the First type is a Number and we wrote a String (Text)
// We also said the Second type is a String and we wrote a Nat (Number)

Pair.new Nat String &quot;Anna&quot; 1n 
Pair.new Nat String &quot;Bruce&quot; 2n
</code></pre>
<p>Next, let's look for the other type we learned earlier the Maybe type, but now, lets make it work with all Types, having a Polymorphic Type variable.</p>
<h2 id="maybe"><a class="header" href="#maybe">Maybe</a></h2>
<p>We are going to use Maybe a lot, imagine we need to write a function that get the first element of a list, if this list is empty, what would we return? the number 0? a text saying &quot;nothing&quot;? we have the Maybe.none for that, and if that list has something, we take the first element and save him inside our bag, the Maybe.some. Bless the Maybe!!</p>
<p>Like the Pair and many other types are going to work in the future, the Maybe type has a Polymorphic Type variable attached to it, since we can save everything on it, isn't it lovely?(Is it clear my favoritism to the type maybe? no? i gotta make it clear here!) This is how it should look:</p>
<pre><code class="language-Rust ignore">type Maybe (a: Type) {
  none 
  some (value: a)
}
</code></pre>
<p>Well, let us read that:</p>
<p>Hmrm <em>clears throat</em> the type <code>Maybe</code> is a type that has  <strong>ONE POLYMORPHIC TYPE A</strong>, it has two constructors, none and some, and the some constructor has one (argument, value, variable. Either of these options work) variable, named value that is something of the type A.</p>
<p>In this case we only need one Polymorphic Type variable, since it only stores one value of a single Type
Lets build some concrete value on the Maybe type:</p>
<pre><code class="language-Rust ignore">//None examples
Maybe.none Bool
Maybe.none Nat
Maybe.none String
Maybe.none (List Nat)

//Some examples
Maybe.some Bool Bool.true
Maybe.some Bool Bool.false
Maybe.some String &quot;Maria&quot;
Maybe.some String &quot;Anna&quot;
</code></pre>
<p>I like to say that the some constructor &quot;hugs&quot; the value and takes care of him, the Maybe is very lovely with their values!</p>
<p>Since the type Pair stores two values and the type Maybe stores one value, if we need to access them somehow in a function, we are going to do within cases as well, pretty much everything in kind is done with case, let us learn how to in the next section, <a href="Voyage/./Accessing.html">Accessing Constructor Values</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accessing-constructor-values"><a class="header" href="#accessing-constructor-values">Accessing Constructor Values</a></h1>
<p>In case you need to access, case.</p>
<h2 id="a-new-discovery"><a class="header" href="#a-new-discovery">A New Discovery</a></h2>
<p>In the Basic Function section we learned that Case is the desconstrutor, analyzer, bond breaker, and now we are going to understand why it is the desconstrutor. Constructors they Hold the value, and the case gives us access to that value, when we are pattern matching a variable of a type with a constructor that is storing some information.</p>
<p>I am going to write a wrapper function for the Boolean true, that function is going to store the concrete value of Bool.false in a maybe type. Let's make a file named WeLoveMaybe.... ah, okay, we can make a Maybes.kind to test our functions.</p>
<h2 id="accessing-values-in-constructors-using-maybe-as-example"><a class="header" href="#accessing-values-in-constructors-using-maybe-as-example">Accessing Values in Constructors using Maybe as example</a></h2>
<pre><code class="language-Rust ignore">Maybe.wrapper (b: Bool) : Maybe Bool
Maybe.wrapper Bool.true = Maybe.some Bool.true
Maybe.wrapper Bool.false = Maybe.none Bool
</code></pre>
<p>This function isn't very useful, but it works as an example, lets run it and see the results for each input, Bool.true and Bool.false</p>
<p>--Img--</p>
<p>The Maybe.some  saves anything we want to, in this case we decided to save a concrete value of Bool.false, and if we input a Bool.false value, it returns none, we are going to have better usage for the Maybe type in the future.
Now let us do the opposite, an unwrapper, a function that receives a Maybe and returns to us a Bool</p>
<pre><code class="language-Rust ignore">Maybe.unwrapper (b: (Maybe Bool)) : Bool
Maybe.unwrapper Maybe.none = ?a
Maybe.unwrapper (Maybe.some value) = ?b
</code></pre>
<p>This is a very important part that we want you to pay attention, i am going to explain how data saved by constructors can be used, using branches to make it visible and clearer, also within the goals and cases for more visualization, lets proceed.</p>
<p>If we type check this code, Kind is going to give us two paths for us to follow, the none and some, the type checker would look somewhat like that:</p>
<pre><code class="language-diff">+   INFO  Inspection.

  • Expected: Bool 

  Maybe.unwrapper Maybe.none = ?a
                               ┬─
                               └Here!
</code></pre>
<pre><code class="language-diff">+ INFO  Inspection.

  • Expected: Bool 

  • Context: 
    •   b.value : Type 
    •   b.value = Bool 
    •   v       : b.value 

  Maybe.unwrapper (Maybe.some v) = ?b
                                   ┬─
                                   └Here!
</code></pre>
<p>This is how it would look like with the branches</p>
<pre><code>    case b
    /   \
 none   some (value)
  |      |
  ?a     ?b
</code></pre>
<p>The some Constructor carries the saved value with him, and the way it is represented in kind is  constructor.data,</p>
<p>but this value is ONLY ACCESSIBLE BY THAT BRANCH, the none has NO access to concrete value, remember the bag example? the none branch means YOU HAVE NO BAG, but the some means YOU HAVE A BAG and the value is inside that bag.</p>
<p>As you can see, our b.value is something of the type Bool, which is our concrete value, the thing inside the bag, whatever the bag is holding, any value in the Maybe.some constructor is our thing.value whenever we access that variable.</p>
<p>But, what do we return when it is none? well, this is why the type Maybe exists, so our &quot;unwrapper&quot; function isn't very useful, other than to show us how this type works, but don't worry, at the end of this explanation there are going to be some real examples and usage for the type Maybe, lets proceed with the example thou. Our unwrapper version should return to us false if there it is nothing and if there it is something, it should return the value of that boolean saved. In the wrapper we saved False if the boolean given is true.</p>
<pre><code class="language-rs ignore">Maybes.unwrapper (b: Maybe&lt;Bool&gt;): Bool
  case b {
    none: Bool.false
    some: b.value
  }
     case b
    /       \
  none     some (b.value)
   |           |
Bool.false   b.value
</code></pre>
<p>For the Maybe type, this is how we get access to the value stored by it, if you want to see real functions uses, go here for examples or here to practice with the type Maybe. These examples were only to show you how to use the type Maybe and how to access a value stored by it, but this is how every type that has a constructor with arguments works, these are the first steps we take towards some very complex matter. Time for the Pair</p>
<p>Accessing values in constructors using Pairs.</p>
<p>Pairs are incredible and yet a very simple Type, they can see intimidating because it has two Polymorphic Types but they are indeed very simple.</p>
<p>Since Pairs has only one constructor, it branch always carries their values with them, we saw how a branch carries value for the Maybe type in the Maybe.some branch, lets write two functions, one that gets the First element of a pair and one that gets the Second element of a Pair.</p>
<p>Lets write both functions in a file named Pairs.kind, and name the functions first and second, both of the functions won't be Polymorphic at first, but then we write them to be Polymorphic, just for the simplicity of the example. The functions are going to have as argument a variable named pair of the type <code>Pair Bool Bool </code>and the return is just a Bool.</p>
<pre><code class="language-Rust ignore">//this function returns the first value of the pair
Pairs.first (pair: (Pair Bool Bool)) : Bool {
  ?a
}

//this function returns the second value of the pair
Pairs.second (pair: (Pair Bool Bool)) : Bool {
  ?b
  }
</code></pre>
<p>If you want you can try to write the answer by yourself, below this line there will be the answer.
Okay, first things first (hehe) as everything in case, we open a Kind! i mean, we open a Case like we always gonna do in functions.</p>
<pre><code class="language-Rust ignore">Pairs.first (pair: (Pair Bool Bool)) : Bool {
  match Pair pair {
    new =&gt; ?a
  }
}
</code></pre>
<p>The Pair has only one constructor named new, then it is the only thing inside our case, looks cute doesn't it?</p>
<pre><code class="language-diff">+ INFO  Inspection.

  • Expected: Bool 

  • Context:
    •   pair     : (Pair Bool Bool) 
    •   pair.fst : Bool 
    •   pair.snd : Bool 

  match Pair pair {
    new =&gt; ?
           ┬
           └Here!
  }
</code></pre>
<p>When we opened the case, we gained access to both values, fst and snd, this is how it would look like in the branch.</p>
<pre><code>  match pair
         |
        new pair.fst pair.snd
         |
         ?a
</code></pre>
<p>A very simple branch, as said above, pairs are very simple, since we want the first value of that pair, all we need to do is return the pair.fst value.</p>
<pre><code class="language-Rust ignore">Pairs.first (pair: (Pair Bool Bool)) : Bool {
  match Pair pair {
    new =&gt; pair.fst
  }
}
</code></pre>
<p>The second you can try to do by yourself, the answer is in the Function Examples you can find later on, i strongly recommend you to try to do them by yourself.</p>
<p>Well, this function only works for Booleans, imagine if we had to do one for each type in Kind, lucky for us we know Polymorphic Types, we can use them to make functions that accepts every sort of type, and we call that Abstraction, when you can abstract your function to work for every single type in Kind. Some functions won't really work, but a lot of them will, and if you can think how to Abstract them, that is very good, abstraction is one of the keys to be a good Kind Developer, YET it is a very hard concept and thing to get used to, give yourself some time, it is okay.</p>
<p>If you want to practice some pair functions can be found here, and the answers here.</p>
<p>Okay Buddy, now that we have met the Polymorphic Types and Constructor that saves data and how to access that data, lets learn how to work with that information with, learn more about pattern match is going to be very useful for us, let's see <a href="Voyage/./Functions.html">More about Functions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-about-functions"><a class="header" href="#more-about-functions">More about Functions</a></h1>
<p>Functions Part 2</p>
<h2 id="another-research"><a class="header" href="#another-research">Another Research</a></h2>
<p>Whenever we talk about Pattern Matching, a lot of doubt can occur, in here i plan to get rid of most of this doubt about Polymorphic Type functions, so we can proceed to the next section of this Book, lets work in some Case usage, examples and exercises.</p>
<h2 id="case-and-values"><a class="header" href="#case-and-values">Case and Values</a></h2>
<p>As said in <a href="Voyage/../Basic/Functions.html#pattern-matching---match">Basic Functions</a>, &quot;Pattern matching is the act of verify possible matches of a given value, this is done sequentially.&quot; and in here i want to focus in values, now that we know how to access values held by constructors.</p>
<p>We are going to build some functions that work particularly in situations where we need to analyze values, since we know the types Bool, Maybe and Pair, we are going to mostly use them to practice.
Here are some examples of functions using values that we access from the type Maybe.</p>
<h2 id="maybe-first-example"><a class="header" href="#maybe-first-example">Maybe First Example</a></h2>
<p>This first function example can be seen as a function to verify if something you saved is the same as you input, we are going to use this function in a future example with different parameters.</p>
<pre><code class="language-Rust ignore">is_equal (input: Bool) (saved: (Maybe Bool)) : Bool {
	match Maybe saved {
    none =&gt; Bool.false
    some =&gt; ?b
  }
}
</code></pre>
<p>If we Type Check that function we get the following result:</p>
<pre><code class="language-diff">+ INFO  Inspection.

  • Expected: Bool 

  • Context: 
    •   input       : Bool 
    •   saved       : (Maybe Bool) 
    •   saved.value : Bool 

  none =&gt; Bool.false
  some =&gt; ?b
          ┬─
          └Here!
      
</code></pre>
<p>We have an user input that is a Bool and the saved.value that is also a Bool, now it is time for us to open a case for the saved.value, it is a value of the type Bool, then you have either true or false.</p>
<pre><code class="language-Rust ignore">is_equal (input: Bool) (saved: (Maybe Bool)) : Bool {
  match Maybe saved {
    none =&gt; Bool.false
    some =&gt; match Bool saved.value {
      true =&gt; ?a
      false =&gt; ?b
    }
  }
}
</code></pre>
<p>Now we just need to verify each branch, this function idea is to show you that we can open a case in everything that is a concrete value, since saved.value is a concrete value of the type Bool, we can pattern match it.</p>
<p>The answer of this function can be found here, and let's proceed to the next function, in here we are going to build a value inside a function and pattern match it.</p>
<h2 id="maybe-second-example"><a class="header" href="#maybe-second-example">Maybe Second Example</a></h2>
<p>This one is purely meant to show you that we can build values inside function and pattern match it, i am going to write here the same function we just did but version 2.</p>
<pre><code class="language-Rust ignore">Is_equal_2 (input: Bool) (saved: (Maybe Bool)) : Bool {
  match Maybe saved {
    none =&gt; Bool.false
    some =&gt; (
      let eql = Bool.equal Bool.true saved.value
      ?a
    )
  }
}
</code></pre>
<p>Now, to the type check:</p>
<pre><code>+ INFO  Inspection.

  • Expected: Bool 

  • Context: 
    •   input       : Bool 
    •   saved       : (Maybe Bool) 
    •   saved.value : Bool 
    •   eql         : Bool 
    •   eql         = (Bool.equal Bool.true saved.value)

  let eql = Bool.equal Bool.true saved.value
  ?a
  ┬─
  └Here!
</code></pre>
<p>First i need to explain you the let .   We use let to build some value inside a function and assign it to a name, that sometimes makes the code clearer and have better readability,  but we are going to  go without it, it is just for showing purposes. In this case we built something of the type Bool using the function Bool.eql, the result is either true or false, then it is a value of the type Bool
Lets move the Bool.eql out of the let and just pattern match it.</p>
<pre><code class="language-Rust ignore">Is_equal_2(input: Bool) (saved: (Maybe Bool)) : Bool {
  match Maybe saved {
    none =&gt; Bool.false
    some =&gt; match Bool (Bool.eql Bool.true saved.value) {
      true =&gt; ?a
      false =&gt; ?b
    }
  }
}

//If you wanted to use case on a value declared on the let you could
Is_equal_2 (input: Bool) (saved: (Maybe Bool)) : Bool {
  match Maybe saved {
    none =&gt; Bool.false
    some =&gt; (
      let eql = Bool.equal Bool.true saved.value
      match Bool eql {
        true =&gt; ?a
        false =&gt; ?b
      }
    )
  }
}
  
  //They're the same
</code></pre>
<p>That is completely legal and works, you are saying the following:  &quot;If the saved value is true then ?a . else ?b &quot; and ah, that is literally the known if else on Kind.</p>
<h2 id="pair-first-example"><a class="header" href="#pair-first-example">Pair First Example</a></h2>
<p>We are going to dive a little bit here, for us to practice Polymorphic Types, first a function that verifies if any of values of the pair are true.</p>
<pre><code class="language-Rust ignore">//If we open the pair first
Snd(pair: (Pair Bool Bool)) : Bool {
  match Pair pair {
    new fst snd =&gt; snd
  }
}

//If we open the pair afterwards
Snd(pair: (Pair Bool Bool)) : Bool {
  match Pair pair {
    new =&gt; pair.snd
  }
}
</code></pre>
<p>This function gets the second value of the Pair, that in this case is a Bool, but what if we wanted other Types? not only Bool?</p>
<pre><code class="language-Rust ignore">//If we open the pair first
Snd &lt;a&gt; (pair: (Pair a a)) : a {
  match Pair pair {
    new fst snd =&gt; snd
  }
}

//If we open the pair afterwards
Snd &lt;a&gt; (pair: (Pair a a)) : a {
  match Pair pair {
    new =&gt; pair.snd
  }
}
</code></pre>
<p>But the problem is, we limited the Types, the pairs can only have the same Type in this case, what if we wanted a Pair of two different values?</p>
<h2 id="pair-second-example"><a class="header" href="#pair-second-example">Pair Second Example</a></h2>
<pre><code class="language-Rust ignore">//If we open the pair first
Snd &lt;a&gt; &lt;b&gt; (pair: (Pair a b)) : b {
  match Pair pair {
    new fst snd =&gt; snd
  }
}

//If we open the pair afterwards
Snd &lt;a&gt; &lt;b&gt; (pair: (Pair a b)) : b {
  match Pair pair {
    new =&gt; pair.snd
  }
}
</code></pre>
<p>ps: A and B can be of the same Type, they are just variables.</p>
<p>We literally just changed the header of the function, everything else stays the same. This is a complicated step to take, but don't worry, only with practice and time this will clarify in your mind, i wanted to show you Abstraction for you to know that it is possible and have it growing on your mind, you are going to learn with time, don't worry!</p>
<p>You can look for more practicing exercises here, or look for <a href="Voyage/./Examples/Maybe_Pair_Variation.html">Variation Examples</a> or the official <a href="Voyage/./Examples/Maybe_Pair.html">Pair/Maybe example</a>.
This is the end of our Voyage and the start of our <a href="Voyage/../Discovery/Discovery.html">Discovery</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>
<p>After learning about Voyage, you may use this section to see and study some examples from each of them. Simply use the index navigation below:</p>
<ol>
<li><a href="Voyage/Examples/./Maybe_Pair_Basics.html">Maybe and Pair Basics</a></li>
<li><a href="Voyage/Examples/./Maybe_Pair_Variation.html">Maybe and Pair</a></li>
<li><a href="Voyage/Examples/./Intermediate_Types.html">Intermediate Types</a></li>
<li><a href="Voyage/Examples/./Intermediate_Funtions.html">Intermediate Functions</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maybe-and-pair-basics"><a class="header" href="#maybe-and-pair-basics">Maybe and Pair Basics</a></h1>
<p>MaybeBool type and PairBool type</p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<h3 id="maybebool"><a class="header" href="#maybebool">MaybeBool</a></h3>
<pre><code class="language-Rust ignore">type MaybeBool { 
  none 
  some (value: Bool)
 }
  
// MaybeBool concrete values:
  // MaybeBool.none
  // MaybeBool.some Bool.true 
  // MaybeBool.some Bool.false
</code></pre>
<h3 id="pairbool"><a class="header" href="#pairbool">PairBool</a></h3>
<pre><code class="language-Rust ignore">type PairBool {
  new (fst: Bool) (snd: Bool)
}

// PairBool concrete values:
  // PairBool.new Bool.true  Bool.true 
  // PairBool.new Bool.true  Bool.false
  // PairBool.new Bool.false Bool.true 
  // PairBool.new Bool.false Bool.false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maybe-and-pair"><a class="header" href="#maybe-and-pair">Maybe and Pair</a></h1>
<p>Maybe type and Pair type</p>
<h2 id="types-1"><a class="header" href="#types-1">Types</a></h2>
<h3 id="maybe-1"><a class="header" href="#maybe-1">Maybe</a></h3>
<pre><code class="language-Rust ignore">type Maybe (a: Type) { 
  none 
  some (value: Bool)
 }
  
// Maybe concrete values:
  // Maybe.none
  // Maybe.some a value // value can be anything of the type a

//Examples:
  // Maybe.some Bool.true
  // Maybe.some (Pair.new Bool.true Bool.true)
</code></pre>
<h3 id="pair"><a class="header" href="#pair">Pair</a></h3>
<pre><code class="language-Rust ignore">type Pair (a: Type) (b: Type) {
  new (fst: a) (snd: b)
}

// Pair concrete values:
  // Pair.new a b fst snd // fst and snd can be anything of the type a and a
  
//Examples:
  // Pair.new Bool.true Bool.false
  // Pair.new (Maybe.none Bool) Bool.true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intermediate-types"><a class="header" href="#intermediate-types">Intermediate Types</a></h1>
<h2 id="types-2"><a class="header" href="#types-2">Types</a></h2>
<h3 id="type-relationship"><a class="header" href="#type-relationship">type Relationship</a></h3>
<pre><code class="language-Rust ignore">//a type with three constructors, where two of them has no value stored to it, but
//the constructor other has a value named single of the type Single

type Relationship {
  couple
  marriage
  other (single: Single)
}

// Relationship concrete values:
	// Relationship.couple
	// Relationship.marriage
	// Relationship.other (Single.lonely)
</code></pre>
<h2 id="type-multiple"><a class="header" href="#type-multiple">type Multiple</a></h2>
<pre><code class="language-Rust ignore">//a type with two Polymorphic Types named a and b and four constructors,
//
//threethings has 
//          x is a value of the type a
//          y is a value of the type b
//          z is a value of the type Multiple with two Polymorphic types a and b
//
//onething has
//          x is a value of the type b
//
//twothings has
//          x is a value of the type a
//          y is a value of the type b
//
//emtpy has no value store to it 

type Multiple (a: Type) (b: Type) {
  threethings (x: a) (y: b) (z: Multiple a b)
  onething (x: b)
  twothings (x: a) (y: b)
  empty
}

//Since a and b are variables, some of the possibilites as example:
// a = Duo            | b = Duo
// a = Multiple a b   | b = Bool
// a = Bool           | b = Nat
//They can be of any Type, a and b can have the same Type as well.

// Multiple Concrete values:
	// Multiple.threethings Bool.true Bool.false (Multiple.empty)
	// Multiple.onething Bool.false
	// Multiple.twothings Bool.true Bool.false
	// Multiple.empty
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intermediate-functions"><a class="header" href="#intermediate-functions">Intermediate Functions</a></h1>
<h2 id="maybebool-examples"><a class="header" href="#maybebool-examples">MaybeBool Examples</a></h2>
<h3 id="function-create"><a class="header" href="#function-create">Function Create</a></h3>
<pre><code class="language-Rust ignore">Create (a:Bool) : MaybeBool{
 MaybeBool.some a
}
  
</code></pre>
<p>The create function gets the input &quot;a&quot; of the Type Bool and creates a Type MaybeBool where its value is &quot;a&quot;. Therefore, if &quot;a&quot; is Bool.true, the result will be <code>MaybeBool.some Bool.true</code>, note that the value of &quot;a&quot; is now stored inside the constructor &quot;some&quot; of the MaybeBool type.</p>
<h3 id="function-or-1"><a class="header" href="#function-or-1">Function Or</a></h3>
<pre><code class="language-Rust ignore">Or (a: MaybeBool) (b: MaybeBool) : MaybeBool {
  match MaybeBool a {
    none =&gt; b
    some value =&gt; MaybeBool.some value
  }
}
</code></pre>
<p>The function &quot;or&quot; returns the first input that is a Maybe.some</p>
<h2 id="pairbool-examples"><a class="header" href="#pairbool-examples">PairBool Examples</a></h2>
<h3 id="function-neg"><a class="header" href="#function-neg">Function neg</a></h3>
<pre><code class="language-Rust ignore">Neg (riap: PairBool) : PairBool {
  match PairBool riap {
    new fst snd =&gt; 
      match Bool fst {
        true =&gt; 
          match Bool snd {
            true =&gt; PairBool.new Bool.false Bool.false
            false =&gt; PairBool.new Bool.false Bool.true
          }
        false =&gt; 
          match Bool snd {
            true =&gt; PairBool.new Bool.true Bool.false
            false =&gt; PairBool.new Bool.true Bool.true
          }
      }
  }
}
</code></pre>
<p>This function receives a PairBool and returns a new PairBool with the negation of its elements. If you look closely, there is a smarter way to do this function.</p>
<h2 id="function-swap"><a class="header" href="#function-swap">Function swap</a></h2>
<pre><code class="language-Rust ignore">swap (a: PairBool) : PairBool {
   match PairBool a {
    new: PairBool.new a.snd a.fst
  }
}
</code></pre>
<p>The swap functions simply swaps the first with the second element of the pair. Basically it creates a new pair where the second element is the first and vice versa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-kind-discovery"><a class="header" href="#a-kind-discovery">A Kind Discovery!</a></h1>
<p>Black holes and Revelations</p>
<p>Kind's universe is unlimited, there it is countless planets and also countless life forms ,but in here we are going to explore some abstractions, and the most important for this part, recursion and some ways to work with them:</p>
<ol>
<li><a href="Discovery/./Currying.html">Currying</a></li>
<li><a href="Discovery/./Numbers.html">Nat and List Types</a></li>
<li><a href="Discovery/./Recursive.html">Recursive Algorithms</a></li>
</ol>
<p>The <a href="https://en.wikipedia.org/wiki/Natural_number">Natural Number</a> Planet and the Pair Planet.</p>
<p>In our voyage we are going to have a very similar approach that we had in Kind Basics, but instead we are in a Intermediate level, the learning curve here is a little bit higher but nothing impossible, i am sure that together we can understand and work with these types, so, let's go buddy, time for us to learn more things about Constructors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="currying"><a class="header" href="#currying">Currying</a></h1>
<p>Spicing things up</p>
<h2 id="a-different-method-to-represent-a-function"><a class="header" href="#a-different-method-to-represent-a-function">A Different method to represent a function</a></h2>
<p>We learned in <a href="Discovery/../Basic/Functions.html">Basic Functions</a> the standard method to build a function but here things are about to get spicy.</p>
<h2 id="currying-1"><a class="header" href="#currying-1">Currying</a></h2>
<p>Currying is the transformation of a function with multiple arguments into a sequence of single-argument functions. That means converting a function like this f(a) (b) (c). The variables, a, b and c must have a type in Kind, lets name them a,b and c Polymorphic Types, since they can be of any type, and represent them using an Arrow:</p>
<pre><code class="language-rs ignore">f: a -&gt; b -&gt; c
</code></pre>
<p>In this example the function f has an argument of the type a, then one of the type b and return something of the type c, remember, a, b and c are only names for the Polymorphic Types, they can have the same type:</p>
<pre><code class="language-rs ignore">f (a: Bool) (b:Bool) : Bool         // Bool.eql, Bool.or, Bool.and, ...
/////////////////////////
f:    Bool -&gt;  Bool -&gt; Bool        // Bool.eql, Bool.or, Bool.and, ...
/////////////////////////
f:    Bool -&gt;  Bool -&gt; Bool
|      |        |       |
v      v        v       v
f (a: Bool) (b:Bool) : Bool
</code></pre>
<p>This method works for representing Generic Functions, since our function f can be any Bool function that receives two arguments, we don't clearly know which function we are referring to, that means we abstracted the specific function to a generic one.
We are going to use this syntax in some functions and to understand better the <a href="Discovery/./Numbers.html">type Nat</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="natural-numbers"><a class="header" href="#natural-numbers">Natural Numbers</a></h1>
<h2 id="a-new-voyage"><a class="header" href="#a-new-voyage">A New Voyage</a></h2>
<p>Welcome to the new planet, i hope you aren't dizzy from the travel! Let's go partner, I have many things I want to show you, and ah, welcome to the  Natural Number Planet.
Then let me ask you, when i said Natural Numbers, and thinking of types, can you imagine us doing an infinite type, since the natural numbers can go from zero to positive infinite? Well, you could go with:</p>
<pre><code class="language-Rust ignore">type Nat { 
  zero
  one
  two
  three
  ....
}
</code></pre>
<p>And that would take ages (forever i would say), that's what the natural numbers thought as well, then they had to figure out how to have all numbers in a much smaller structure, it had to fit in a Planet. After years, the Nat (We are going to affectionately call them Nat, the type Nat) found out how:</p>
<pre><code>type Nat {
  zero
  succ (pred: Nat)
}
</code></pre>
<p>Within these 2 constructors, the type Nat managed to approach all positive infinite numbers starting with zero, if you can't see how yet, by the end of this page, we are going to be able to!
Also, just to make it clear, succ is a short name for Successor and pred is for Predecessor.</p>
<pre><code>type Nat {
  zero                // Nullary constructor
  succ (pred: Nat)    // constructor with value
}
</code></pre>
<p>As we can see, zero is a constant, a Nullary constructor (which is true), now succ has a variable named pred of the type Nat.</p>
<p>Constructors with value</p>
<p>Lets remember two things here:</p>
<ul>
<li>To declare concrete values, we write typename.constructor, using Bool as example we would have either Bool.true or Bool.false as valid concrete data to Bool type.</li>
<li>Functions have a name, followed to its arguments, the type, then the return.
Now that we know the Nat type, if we were to declare its concrete values we would have:</li>
</ul>
<pre><code class="language-Rust ignore">Nat.zero
Nat.succ
</code></pre>
<p>Lets make a new file, named Numbers.kind and type check both of values, remembering, we can only do it one by one in Kind.</p>
<p>We add a line with Numbers: Nat  to our file and lets test first the Nat.zero:</p>
<pre><code class="language-Rust ignore">Numbers: Nat

All terms check.
</code></pre>
<p>Time for us to do the same with the Nat.succ:</p>
<pre><code>Type mismatch.
- Expected: Nat
- Detected: (pred:Nat) -&gt; Nat
</code></pre>
<p>The type checker acuses a Type mismatch, since it expected something of the type Nat, and found a function that has an argument of the type Nat, and then this function is something of the type Nat.</p>
<ul>
<li>In kind we write a function the way we learned in <a href="Discovery/../Basic/Functions.html">Basic Functions</a>, but we can represent it with arrows -&gt;  as explained in <a href="Discovery/./Currying.html">Currying</a>, you can find more examples about it <a href="Discovery/../Voyage/Examples/Intermediate_Funtions.html">here</a>.</li>
</ul>
<h2 id="succs-and-preds"><a class="header" href="#succs-and-preds">Succs and Preds</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursive-algorithms"><a class="header" href="#recursive-algorithms">Recursive Algorithms</a></h1>
<p>TODO b </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-sugar"><a class="header" href="#syntax-sugar">Syntax Sugar</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sugar"><a class="header" href="#sugar">Sugar</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contribuidores"><a class="header" href="#contribuidores">Contribuidores</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
