## Kind vs Teoria dos Conjuntos

O n√∫cleo l√≥gico do Coq, o C√°lculo das Constru√ß√µes Indutivas, difere de algumas maneiras importantes de outros sistemas formais que s√£o usados pelos matem√°ticos para escrever provas precisas e rigorosas. Por exemplo, na funda√ß√£o mais popular para a matem√°tica em papel e l√°pis convencional, a Teoria dos Conjuntos de Zermelo-Fraenkel (ZFC), um objeto matem√°tico pode potencialmente ser membro de muitos conjuntos diferentes; um termo na l√≥gica de Kind, por outro lado, √© membro de no m√°ximo um tipo. Essa diferen√ßa muitas vezes leva a formas ligeiramente diferentes de capturar conceitos matem√°ticos informais, mas estes s√£o, em grande parte, bastante naturais e f√°ceis de trabalhar. Por exemplo, em vez de dizer que um n√∫mero natural n pertence ao conjunto de n√∫meros pares, dir√≠amos em Kind que ev n √© verdadeiro, onde ev: Nat -> Tipo √© uma propriedade que descreve os n√∫meros pares.

No entanto, h√° alguns casos em que traduzir o racioc√≠nio matem√°tico padr√£o para Kind pode ser tanto trabalhoso quanto, √†s vezes, at√© imposs√≠vel, a menos que enrique√ßamos a l√≥gica central com axiomas adicionais. Conclu√≠mos este cap√≠tulo com uma breve discuss√£o de algumas das diferen√ßas mais significativas entre os dois mundos.

### Extens√£o Funcional. 
As afirma√ß√µes de igualdade que vimos at√© agora dizem principalmente respeito a elementos de tipos indutivos (Nat, Bool, etc.). Mas como o operador de igualdade de Kind √© polim√≥rfico, essas n√£o s√£o as √∫nicas possibilidades - em particular, podemos escrever proposi√ß√µes que afirmam que duas fun√ß√µes s√£o iguais uma √† outra:

```rust 
Function_equality_ex1 : Equal (Nat.succ 3n) (Nat.succ (Nat.pred 4n))
Function_equality_ex1 = Equal.refl
```

Na pr√°tica matem√°tica comum, duas fun√ß√µes f e g s√£o consideradas iguais se produzem as mesmas sa√≠das:

(‚àÄùë•, ùëì(ùë•) = ùëî(ùë•)) ‚Üí ùëì = ùëî

Isto √© conhecido como o princ√≠pio da extens√£o funcional.

De forma informal, uma "propriedade extensional" √© aquela que diz respeito ao comportamento observ√°vel de um objeto. Assim, a extens√£o funcional significa simplesmente que a identidade de uma fun√ß√£o √© completamente determinada pelo que podemos observar a partir dela - isto √©, em termos de Kind, os resultados que obtemos ap√≥s aplic√°-la.

A extens√£o funcional n√£o faz parte dos axiomas b√°sicos do Kind. Isso significa que algumas proposi√ß√µes "razo√°veis" n√£o s√£o prov√°veis.

```rust
Function_equality_ex2 : Equal ((x: Nat) => Nat.add x 1n) ((x: Nat) => Nat.add 1n x)
Function_equality_ex2 = ?
```

No entanto, podemos declarar um teorema e pular a sua prova ou usar um buraco

```rust
Functional_extensionality <a><b> (f: a -> b) (g: a -> b) (e: (x: a) -> Equal (f x) (g x)) : Equal f g
```

Agora podemos invocar a extensionalidade funcional em provas:
```rust
Function_equality_ex2 : Equal ((x: Nat) => Nat.add x 1n) ((x: Nat) => Nat.add 1n x)
Function_equality_ex2 =
  Functional_extensionality ((x: Nat) => Nat.add x 1n) ((x: Nat) => Nat.add 1n x) (x => Plus_comm x 1n)
```

Naturalmente, devemos ter cuidado ao adicionar novos axiomas √† l√≥gica do Kind, pois eles podem torn√°-la inconsistente - ou seja, podem tornar poss√≠vel provar todas as proposi√ß√µes, incluindo Void!

Infelizmente, n√£o h√° uma maneira simples de saber se um axioma √© seguro para adicionar: geralmente √© necess√°rio um trabalho √°rduo para estabelecer a consist√™ncia de qualquer combina√ß√£o particular de axiomas.

No entanto, sabe-se que adicionar a extensionalidade funcional, em particular, √© consistente.

#### Tr_rev 
Um problema com a defini√ß√£o da fun√ß√£o de revers√£o de lista "rev" que temos √© que ela realiza uma chamada a "++" a cada passo. Executar "++" leva tempo assintoticamente linear no tamanho da lista, o que significa que "rev" tem tempo de execu√ß√£o quadr√°tico.
Podemos melhorar isso com a seguinte defini√ß√£o:

```rust
Rev_append <x> (l1: List x) (l2: List x)  : List x
Rev_append x List.nil l2                  = l2
Rev_append x (List.cons xs.h xs.t) l2     = Rev_append xs.t (List.cons xs.h l2)

Tr_rev <x> (l: List x) : List x
Tr_rev x l = Rev_append x l List.nil1
```

Esta vers√£o √© dita ser tail-recursive, porque a chamada recursiva √† fun√ß√£o
√© a √∫ltima opera√ß√£o que precisa ser executada (ou seja, n√£o precisamos executar ++
ap√≥s a chamada recursiva); um compilador decente ir√° gerar um c√≥digo muito eficiente neste
caso. Prove que as duas defini√ß√µes s√£o realmente equivalentes.

```rust
Tr_rev_correct <a> (xs: List a) : Equal (Tr_rev xs) (Rev xs)
Tr_rev_correct a xs = ?
```

### Proposi√ß√µes e Booleans. 

Vimos duas maneiras diferentes de codificar fatos l√≥gicos em Kind: com booleanos (do tipo Bool) e com proposi√ß√µes (do tipo Type).
Por exemplo, para afirmar que um n√∫mero n √© par, podemos dizer que
‚Ä¢ (1) evenb n retorna True, ou
‚Ä¢ (2) existe um k tal que n = double k. De fato, essas duas no√ß√µes de paridade s√£o equivalentes, como pode ser facilmente mostrado com um par de lemas auxiliares.
Muitas vezes dizemos que o booleano evenb n reflete a proposi√ß√£o (n => Equal n (double k)).

```rust
Evenb_double (k: Nat)     : Equal (Nat.is_even (Nat.double k)) Bool.true
Evenb_double Nat.zero     = Equal.refl
Evenb_double (Nat.succ k) = Evenb_double k
```

#### Evenb_double_conv
```rust
Evenb_double_conv (n: Nat):
  Sigma Nat (k => (Equal n (Bool.if (Evenb n) (Nat.double k) (Nat.succ (Nat.double k)))))
Evenb_double_conv n = ?
```
